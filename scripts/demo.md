
demo.py
=======

**[demo.py](demo.py)** demonstrates several features of the Piety system,
including concurrent tasks, a display editor, a windowing system,
and an enhanced shell.

**demo.py** uses the Piety scheduler to run the
[edsel](../editors/edsel) display editor as a task,
concurrently with two timestamp tasks.  Each timestamp task updates an
editor buffer.  You can see these buffers update in their windows as
you edit in another window or on the command line.

Here is a sample session that demonstrates this.  First, at the system
command line, change directory to the Piety scripts directory, then
type the command to set up the Python path to find all the Piety modules, 
then type the command to start the demo:

    $ cd ~/Piety/scripts
    $ . ../bin/asyncio_paths
    $ python3 -im demo

The *edsel* screen with one window appears, showing the *main* buffer
containing the line *This is the main buffer*.  At the bottom of the
screen is a two-line scrolling command entry region, where you type
commands at the *:* editor prompt.

Type commands at the *edsel* command prompt to create
two new windows that show timestamps updating, then traverse to
the original *main* window and edit.  The *o2* command splits the window,
*b ts1* makes *ts1* the current buffer (and displays it in the focus window),
and *o* moves the focus to the next window:

    :o2
    :b ts1
    . * ts1                 61  ts1
    :o2
    :b ts2
    . * ts2                105  ts2
    :o
    :o

Then, at the prompt, type the *edsel* *C* command to change to
display editing mode. (That's a capital *C*, it is case sensitive.)

    :C

The cursor moves into the *main* window.  Type and edit text
in the window in the usual way for [edsel](../editors/edsel).
Notice that the lines generated by the two timestamp
tasks keep appearing and
scrolling up in the *ts1* and *ts2* windows as you edit.

To exit display editing mode and return to the editor command prompt, type
*^Z*  (control-Z).  There you can issue any number of commands.
After that, you can use *C* to return to display editing again.

To exit the demo, use the Python command *piety.stop()* or simply type
^C.  Either will return you to the standard Python prompt *>>>*.  Then
use the command *edsel.edda.cleanup()* to restore full-screen
scrolling in the terminal window.  Then you can exit Python in the
usual way, by *exit()* or ^D.  Alteratively, you can resume the demo
from the Python prompt by the command *main()*.   The demo will resume
in the state you left it, including all the buffer contents and windows.

A program crash will also return you to the standard Python prompt,
where you can exit Python to abandon the crashed demo, or you can
attempt to resume the demo with *main()* -- that sometimes works.

Some interesting commands to type at the *edsel* editor command prompt:

 - *h 12* - Enlarge the scrolling command region to 12 lines, so 
 you can observe multiple commands or multiline output.

 - *n* - List all the editor text buffers.

 - *b ts1* - In the focus window, display the buffer that contains the
 timeout messages from *ts1task*.  This window updates each time the
 task generates a new message, even when another window gets focus
 and updates as its text is edited.

It can be informative to use Python commands while the demo is running.
The *edsel* display editor has the *[wyshka](../shells/wyshka.py)*
shell built-in, so you can use the Python command line without exiting
the editor, by prefixing each Python command at the editor command
prompt with an exclamation point, or by typing just an exclamation
point on the editor command line by itself to switch to a Python
command line.  The *wyshka* Python prompt has just two darts, *>>*,
to distinguish it from the standard Python prompt.  Exit *wyshka* and
return to the editor command line by typing just a colon at the *>>* prompt on
the Python command line.

Some interesting Python commands to try:

 - *piety.tasks()* - show information about tasks

 - *ts1task.enabled=piety.false* - disable *ts1task* so *ts1* buffer stops updating

 - *ts1task.enabled=piety.true* -  enable *ts1task* so *ts1* buffer resumes updating

 - *ts1task.enabled=alternate* - run *ts1task* handler on alternate timeout events

 - *piety.cycle.period=0.1* - cause *ts1* buffer to update ten times a second.  We hav

 - *piety.cycle.period=1.0* - cause *ts1* buffer to resume updating once a second

 - *edsel.ed.a('append line after dot')* - or any other call from the *ed* API.

With *piety.cycle.period=0.0001* -- 10,000 events/second -- we can type
comfortably in the *main* buffer, with no lost characters -- although 
the cursor blinks furiously.   This is on an
early 2011 MacBook Pro, 2.3 GHz Intel Core i5, 4 GB, OS X 10.11.6 El
Capitan, with CPython 3.9.  Even with period 0.000001 we can type with
no lost characters, the display is updating at a blur (but probably not
a million times a second).

### API and data structures ###

You can access the editor API from the Python prompt
by prefixing calls with *edsel.ed.* as in *edsel.ed.n()*, etc.

You can access the storage API and data structures by prefixing identifiers
and calls with *edsel.text.*, as in *edsel.text.buffers* etc.

You can access the display API and data structures by prefixing identifiers
and calls with *edsel.frame.*, as in *edsel.frame.windows* etc.

### Bugs ###

The edsel quit commands *q* and *Q* do not exit the demo cleanly, instead
they put the session into a limbo with no prompt.  In this state you
must type ^C to return to the standard Python prompt so you can exit.

There is a problem when any program that uses multiple character
keycodes runs as a task under Piety.  In this demo, the problem appears
when using the display editor, or when editing the command line.

Only keystrokes that make single-character keycodes display correctly
each time.  That includes all the regular alphanumeric and symbol keys,
and also control characters formed by holding down the control key,
and then typing another key. For example, control-f to move the cursor
forward one character (also written ^F or C-f) work as intended.

Keystrokes that make multiple character keycodes have a delayed
effect.  They are only appear on the display when you press the next
key.  These include keycodes formed by holding down the alt key, then
typing another key, for example alt-f to move the cursor forward one
word (also written M-f).  You must type M-f twice to get the cursor to
advance by one word, then the next keystroke, whatever it is, causes
the cursor to advance by a word again.  The arrow keys also exhibit
the same problem, because they also send multiple-character keycodes.

To run this demo wihout encountering this problem, use only control
key commands, not alt key commands or arrow keys.  For example, use
C-f and C-b to move the cursor forward and back one character at a
time, but not M-f and M-b to move the cursor forward and back a word
at a time.  Use C-p and C-n to move the cursor to the previous line or
the next line, but not the up- and down-arrow keys.   Use C-z to switch
from display editing to the command line, but not M-x.

This problem does not appear when *edsel* (etc.) are run without
Piety tasking, for example by just running *python3 edsel.py*.
The problem only appears when the programs are run as Piety tasks,
as in *demo.py* or *scripts/edsel_piety.py*.

We instrumented the code 
(in [*console_debug.py*](../console/console_debug.md) etc.) and found that
the behavior *and timing* of the code that reads and interprets
keystrokes, and constructs the output terminal display command
strings, is the same whether or not the code runs under Piety tasking.
It must be that the output (that is, the writing) of the display
command strings are delayed, when running under Piety tasking -- but
only when the input commands have multiple characters.  This is not
accessible to our instrumentation, but must occur somewhere in the
depths of the Python runtime or perhaps even in the Mac OS.

Revised Jan 2023
