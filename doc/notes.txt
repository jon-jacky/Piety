# New notes.txt - begun 30 Jan 2023 for the new rewrite branch

# Old notes.txt 24 Oct 2012 -- 30 Jan 2023 now in notes.version1.txt

30 Jan 2023

Now get started on the big rewrite!

Code organization:

We want to be able to use the old Piety and the new Piety
simultaneously.  We want to keep the new Piety simple, with fewer not
more files, and we want to keep the same names for some directories
and files in the new Piety, even thought they might be very different.

That means we can't just put the new Piety in additional files and
directories.  So we need the old and new Piety to be in different git
branches.  We will check out different working directory trees for the
old Piety and new Piety branches, and use different PYTHONPATH to run
code out of each branch in different windows (processes).

We expect the new Piety will not become usable for quite a while.

For now, keep the old Piety in the master branch so visitors will see
and check out a working version by default.  Make a new long-lived
'rewrite' branch for the new Piety.  Then do each programming project in
a branch off the rewrite branch, and merged them back into rewrite,
not master.  Try some experiments early on to make sure that works.

Rewrite editors

We will begin a complete rewrite of the editors.  For now we will work
on just one editor, an all-new version of the display editor edsel --
we are keeping the name.

This time we will have just one editor, edsel.  Defer rewrite of ed.py for
now.   Discard nesting-doll organization where edsel imports ed, edo, edda
etc.  Keep the modular structure simple, and as flat as reasonable.

Also, keep the data organization simple and flat.  Use functions 
instead of objects and methods, wherever that is reasonable.

To begin with, defer the ed-like editor command language.  Python
itself will be the only command language, so the editor command line
will just be Python, our embeddable pysh shell.  We will just call
the editor functions from the Python command line.  Our earlier noed.py
experiment might be pertinent - maybe it can be the beginning of our
new edsel.

We will define function names, argument lists, and location in modules
so that using the functions from the Python command line is as convenient
as possible.

To keep the functions simple, they will do no error checking on arguments.
If the editor crashes, just resume by invoking main again.

There will be a Python function we can call to switch from command
line editing to display editing (with control keys instead of
commands).  There will be a control key to switch back to the command
line.  So command line vs.  control key modes will be implicit - there
needn't be any mode variable.

For now, the command line will be read by the standard blocking
readline function.  Later we will replace readline by a new
non-blocking editline, so edsel can be run as a task.  We will take
care so that editline can be substituted for readline with minimal
changes to behavior as seen by the user and minimal code changes to
the rest of the editor.  This will be a model for other applications.

Abandon the complicated Console object, replace it by the simpler
editline function.

Abandon complicated job control.  There is no need for any explicit
jobs or job control.  Any application with a main method is a job.
Once an application is imported, the entire application state always
remains in the Python session, so any application (job) can be
suspended (put in the background) by its own exit command or a ctrl-C
interruption -- or even a program crash -- and then resumed (restored
to the foreground) from where it left off by simply calling its main
function from the shell.  You can find what applications (jobs)
are imported (loaded) with the Python dir() function.

This handling of jobs shows how Piety uses built-in Python
functionality to mimic traditional OS functions, instead of building
more machinery.  Using the Python interpreter as the editor command
line is another example.

In this same spirit, we might not need a specialized shell like wyshka
that switches among command languages based on a prefix character.
Instead we can just have Python functions that run each different
shell, then exit any shell to return to the Python shell.

Next step: create the rewrite branch, experiment with making branches 
of the rewrite branch.  Be careful with commit and merge - we *don't* want
to commit the new branch-of-a-branch material back to the master branch.

Exactly this workflow is discussed here:

3.4 Git Branching - Branching Workflows
https://git-scm.com/book/en/v2/Git-Branching-Branching-Workflows

We need a name for our long-running rewrite branch - rewrite isn't so
good, how about 'simplified' - maybe too aspirational?  Maybe just
'revised' - no claims or connotations - but it doesn't convey how
radical the revisions are.  'new' is not good, it may have to be 'new'
for years.  'freshstart' or 'startover' is more accurate than
'revised' - they are closer in meaning to 'rewrite' - but again sound
too aspirational.  I am coming to appreciate 'rewrite' - that's exactly what
it is.

31 Jan 2023

Experiment with git branches, make a small test repo.

Jonathans-MacBook-Pro:branch-test jon$ git init
Initialized empty Git repository in /Users/jon/branch-test/.git/
...

Nah, abandon this.  To do a realistic test we need to start with a
test repo at github.  The configuration we need to test is two working
directories with different branches from the same repo in them, both
pushing to the same remote repo.

Nothing suitable at github now.  Make a fresh one, startng from github 
page.

Jonathans-MacBook-Pro:~ jon$ mkdir gtest
Jonathans-MacBook-Pro:~ jon$ cd gtest
Jonathans-MacBook-Pro:gtest jon$ git init
Initialized empty Git repository in /Users/jon/gtest/.git/
Jonathans-MacBook-Pro:gtest jon$ cat > README.txt
Test two working directories with different branches of the same repo
pushing to the same remote repo at github.
Jonathans-MacBook-Pro:gtest jon$ git add README.txt
Jonathans-MacBook-Pro:gtest jon$ git commit -m 'First commit in master branch, Rtop level EADME.txt'
[master (root-commit) c8b21b4] First commit in master branch, Rtop level EADME.txt
 1 file changed, 2 insertions(+)
 create mode 100644 README.txt
Jonathans-MacBook-Pro:gtest jon$ git remote add origin https://github.com/jon-jacky/gtest.git

Jonathans-MacBook-Pro:gtest jon$ git status
On branch master
nothing to commit, working directory clean
Jonathans-MacBook-Pro:gtest jon$ git branch
* master
Jonathans-MacBook-Pro:gtest jon$ git remote -v
origin			    https://github.com/jon-jacky/gtest.git (fetch)
origin			    https://github.com/jon-jacky/gtest.git (push)

Jonathans-MacBook-Pro:gtest jon$ git push
Username for 'https://github.com': jon-jacky
Password for 'https://jon-jacky@github.com': 
remote: Support for password authentication was removed on August 13, 2021.
remote: Please see https://docs.github.com/en/get-started/getting-started-with-git/about-remote-repositories#cloning-with-https-urls for information on currently recommended modes of authentication.
fatal: Authentication failed for 'https://github.com/jon-jacky/gtest.git/'

Grrr... use the recommended command.

Jonathans-MacBook-Pro:gtest jon$ git push -u origin master
... same as above ...

I recall we saw this in October also.  See notes/tech/uw_migrate L466.
I generated a PAT on 2 Oct 2022 to expire in 90 days - should have
expired at the start of the month, let's try it anyway.

Jonathans-MacBook-Pro:gtest jon$ git push
Username for 'https://github.com': jon-jacky
Password for 'https://jon-jacky@github.com': <paste in PAT>
remote: Invalid username or password.
fatal: Authentication failed for 'https://github.com/jon-jacky/gtest.git/'

Generate new PAT, follow

https://docs.github.com/en/authentication/keeping-your-account-and-data-secure//creating-a-personal-access-token

Creating a personal access token (classic)

There is no option to resend verification email!  Try to keep going.

Pick 3 days expiration - will expire Mar 2 2023

I saw something that said my old PAT expired Dec 31 2022

Select scopes - check only repo

I check Generate Token - it shows

 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

Not the same as the old one at L462 - but it still says

Error msg said PAT required for initial push new z-book from local repo to repo at github â€” repo
Expired on Sat, Dec 31 2022. 

Just try git push again with this PAT

Jonathans-MacBook-Pro:gtest jon$ git push
Username for 'https://github.com': jon-jacky
Password for 'https://jon-jacky@github.com':  <paste in new PAT>
No refs in common and none specified; doing nothing.
Perhaps you should specify a branch such as 'master'.
Everything up-to-date

Jonathans-MacBook-Pro:gtest jon$ git push -u origin master
Counting objects: 3, done.
Delta compression using up to 4 threads.
Compressing objects: 100% (2/2), done.
Writing objects: 100% (3/3), 331 bytes | 0 bytes/s, done.
Total 3 (delta 0), reused 0 (delta 0)
To https://github.com/jon-jacky/gtest.git
 * [new branch]      master -> master
Branch master set up to track remote branch master from origin.

It didn't ask for PAT again.

Look at github - yes, now the repo with just the README.txt is there
at https://github.com/jon-jacky/gtest in master branch, the only branch.

Now I we can start our experiment.  First, make some dummy content in master
branch.

Jonathans-MacBook-Pro:gtest jon$ git commit -am 'add BRANCH.txt, dirs console doc editors'
[master 0ca2a82] add BRANCH.txt, dirs console doc editors
 4 files changed, 4 insertions(+)
 create mode 100644 BRANCH.txt
 create mode 100644 console/console.txt
 create mode 100644 doc/design.txt
 create mode 100644 editors/edsel.txt

Jonathans-MacBook-Pro:gtest jon$ git push
Counting objects: 9, done.
Delta compression using up to 4 threads.
Compressing objects: 100% (2/2), done.
Writing objects: 100% (9/9), 642 bytes | 0 bytes/s, done.
Total 9 (delta 0), reused 0 (delta 0)
To https://github.com/jon-jacky/gtest.git
   c8b21b4..0ca2a82  master -> master

It's all there at github.  Now clone it:

Jonathans-MacBook-Pro:~ jon$ git clone https://github.com/jon-jacky/gtest gtest-rewrite
Cloning into 'gtest-rewrite'...
remote: Enumerating objects: 12, done.
remote: Counting objects: 100% (12/12), done.
remote: Compressing objects: 100% (4/4), done.
remote: Total 12 (delta 0), reused 12 (delta 0), pack-reused 0
Unpacking objects: 100% (12/12), done.
Checking connectivity... done.

Jonathans-MacBook-Pro:~ jon$ cd gtest-rewrite/
Jonathans-MacBook-Pro:gtest-rewrite jon$ ls -a
./				    	 .git/		README.txt	doc/
../					 		BRANCH.txt	console/	editors/
Jonathans-MacBook-Pro:gtest-rewrite jon$ git remote -v 
origin				    https://github.com/jon-jacky/gtest (fetch)
origin				    https://github.com/jon-jacky/gtest (push)
Jonathans-MacBook-Pro:gtest-rewrite jon$ git branch
* master

Now make a new branch:

Jonathans-MacBook-Pro:gtest-rewrite jon$ git branch
* master
Jonathans-MacBook-Pro:gtest-rewrite jon$ git branch rewrite
Jonathans-MacBook-Pro:gtest-rewrite jon$ git branch
* master
  rewrite
Jonathans-MacBook-Pro:gtest-rewrite jon$ git checkout rewrite
Switched to branch 'rewrite'
Jonathans-MacBook-Pro:gtest-rewrite jon$ git branch
  master
* rewrite
Jonathans-MacBook-Pro:gtest-rewrite jon$ ls -a
./				    	 .git/		README.txt	doc/
../					 		BRANCH.txt	console/	editors/
Jonathans-MacBook-Pro:gtest-rewrite jon$ cat BRANCH.txt 
This is the master branch
Jonathans-MacBook-Pro:gtest-rewrite jon$ cat > BRANCH.txt
This is the rewrite branch
Jonathans-MacBook-Pro:gtest-rewrite jon$ ls console
console.txt
Jonathans-MacBook-Pro:gtest-rewrite jon$ git rm console
fatal: not removing 'console' recursively without -r
Jonathans-MacBook-Pro:gtest-rewrite jon$ git rm -r console
rm 'console/console.txt'
Jonathans-MacBook-Pro:gtest-rewrite jon$ ls -a
./				    	 .git/		README.txt	editors/
../					 		BRANCH.txt	doc/
Jonathans-MacBook-Pro:gtest-rewrite jon$ ls editors
edsel.txt
Jonathans-MacBook-Pro:gtest-rewrite jon$ cat editors/edsel.txt
file edsel.txt
Jonathans-MacBook-Pro:gtest-rewrite jon$ git rm editors/edsel.txt
rm 'editors/edsel.txt'
Jonathans-MacBook-Pro:gtest-rewrite jon$ ls
BRANCH.txt			    README.txt	doc/

So we didn't get an empty edsel directory.

Jonathans-MacBook-Pro:gtest-rewrite jon$ git commit -am 'clean up new rewrite branch
> revise BRANCH.txt, remove console and editors directories'
[rewrite 22b6f64] clean up new rewrite branch revise BRANCH.txt, remove console and editors directories
 3 files changed, 1 insertion(+), 3 deletions(-)
 delete mode 100644 console/console.txt
 delete mode 100644 editors/edsel.txt

Now, what does git push do?

Jonathans-MacBook-Pro:gtest-rewrite jon$ git push
Everything up-to-date

At github, it's still on the master branch, that is the only branch,
and all the contents are still there.

Jonathans-MacBook-Pro:gtest-rewrite jon$ git push -u origin rewrite
Counting objects: 3, done.
Delta compression using up to 4 threads.
Compressing objects: 100% (2/2), done.
Writing objects: 100% (3/3), 389 bytes | 0 bytes/s, done.
Total 3 (delta 0), reused 0 (delta 0)
remote: 
remote: Create a pull request for 'rewrite' on GitHub by visiting:
remote:      https://github.com/jon-jacky/gtest/pull/new/rewrite
remote: 
To https://github.com/jon-jacky/gtest
 * [new branch]      rewrite -> rewrite
Branch rewrite set up to track remote branch rewrite from origin.

Now at github gtest page at top a yellow box:

[ rewrite had recent pushes one minute ago [compare & pull request] ]

another box:

[ Your master branch isn't protected.  Protect this branch from force
pushing or deletion, or require status checks before merging. Learn
more [ Protect this branch ] ]

Pull down branches button, has both master and rewrite.  Select rewrite.
Shows just the doc directory - console and editors are gone.
BRANCH.txt says 'This is the rewrite branch'.

Now at github select master branch again.  It still has console and editors
dirs and BRANCH.txt says 'This is the master branch'.

NOW try a feature branch from the rewrite branch.

Jonathans-MacBook-Pro:gtest-rewrite jon$ git branch
  master
* rewrite
Jonathans-MacBook-Pro:gtest-rewrite jon$ git branch edsel
Jonathans-MacBook-Pro:gtest-rewrite jon$ git checkout edsel
Switched to branch 'edsel'
Jonathans-MacBook-Pro:gtest-rewrite jon$ git branch
* edsel
  master
  rewrite
Jonathans-MacBook-Pro:gtest-rewrite jon$ ls
BRANCH.txt			    README.txt	doc/

Jonathans-MacBook-Pro:gtest-rewrite jon$ mkdir editors
Jonathans-MacBook-Pro:gtest-rewrite jon$ cat > editors/edsel.txt
This is the new version of edsel!
Jonathans-MacBook-Pro:gtest-rewrite jon$ ls
BRANCH.txt			    README.txt	doc/		editors/
Jonathans-MacBook-Pro:gtest-rewrite jon$ git add editors
Jonathans-MacBook-Pro:gtest-rewrite jon$ git commit -am 'add new editors dir with new edsel.txt
> '
[edsel 5392a96] add new editors dir with new edsel.txt
 1 file changed, 1 insertion(+)
 create mode 100644 editors/edsel.txt
Jonathans-MacBook-Pro:gtest-rewrite jon$ ls
BRANCH.txt			    README.txt	doc/		editors/

Jonathans-MacBook-Pro:gtest-rewrite jon$ cd editors

Jonathans-MacBook-Pro:editors jon$ git log edsel.txt
commit 5392a96c3e302dd48aba8e76fc117e71f3103f5d
Author: Jon Jacky <jon@u.washington.edu>
Date:   Tue Jan 31 17:05:41 2023 -0800

    add new editors dir with new edsel.txt

commit 22b6f64645d7f8a1d70dcdfb64214ab1579e3cb7
Author: Jon Jacky <jon@u.washington.edu>
Date:   Tue Jan 31 16:43:14 2023 -0800

    clean up new rewrite branch
    revise BRANCH.txt, remove console and editors directories

commit 0ca2a8296bb3e956309dea291cd358fe893fb920
Author: Jon Jacky <jon@u.washington.edu>
Date:   Tue Jan 31 16:26:19 2023 -0800

    add BRANCH.txt, dirs console doc editors

So it logs the previous version of edsel also.

Jonathans-MacBook-Pro:editors jon$ git push -u origin edsel
Counting objects: 4, done.
Delta compression using up to 4 threads.
Compressing objects: 100% (2/2), done.
Writing objects: 100% (4/4), 363 bytes | 0 bytes/s, done.
Total 4 (delta 1), reused 0 (delta 0)
remote: Resolving deltas: 100% (1/1), completed with 1 local object.
remote: 
remote: Create a pull request for 'edsel' on GitHub by visiting:
remote:      https://github.com/jon-jacky/gtest/pull/new/edsel
remote: 
To https://github.com/jon-jacky/gtest
 * [new branch]      edsel -> edsel
Branch edsel set up to track remote branch edsel from origin.

Back to gtest page at github

[ rewrite had recent pushes 28 minutes ago ...]

[ edsel had recent pushes 1 minute ago ...]

Yes, now github has all three branches - edsel branch shows
new editors dir with new edsel.txt: 'This is the new version of edsel!'

Now merge edsel branch into rewrite

Jonathans-MacBook-Pro:editors jon$ git branch
* edsel
  master
  rewrite
Jonathans-MacBook-Pro:editors jon$ git branch rewrite
fatal: A branch named 'rewrite' already exists.
Jonathans-MacBook-Pro:editors jon$ git checkout rewrite
Switched to branch 'rewrite'
Your branch is up-to-date with 'origin/rewrite'.

Jonathans-MacBook-Pro:editors jon$ git merge edsel -m 'merge edsel branch into rewrite branch'
fatal: Unable to read current working directory: No such file or directory

Oh, right, working dir is still editors from edsel branch but that
branch doesn't exist in rewrite.  cd up to top.

Jonathans-MacBook-Pro:editors jon$ cd ..
Jonathans-MacBook-Pro:gtest-rewrite jon$ ls
BRANCH.txt			    README.txt	doc/

Jonathans-MacBook-Pro:gtest-rewrite jon$ git branch
  edsel
  master
* rewrite
Jonathans-MacBook-Pro:gtest-rewrite jon$ git merge edsel -m 'merge edsel branch into rewrite branch'
Updating 22b6f64..5392a96
Fast-forward (no commit created; -m option ignored)
 editors/edsel.txt | 1 +
 1 file changed, 1 insertion(+)
 create mode 100644 editors/edsel.txt
Jonathans-MacBook-Pro:gtest-rewrite jon$ ls
BRANCH.txt			    README.txt	doc/		editors/
Jonathans-MacBook-Pro:gtest-rewrite jon$ ls editors
edsel.txt
Jonathans-MacBook-Pro:gtest-rewrite jon$ cat editors/edsel.txt 
This is the new version of edsel!

So that looks right!  Now push

Jonathans-MacBook-Pro:gtest-rewrite jon$ git push -u origin rewrite
Total 0 (delta 0), reused 0 (delta 0)
To https://github.com/jon-jacky/gtest
   22b6f64..5392a96  rewrite -> rewrite
Branch rewrite set up to track remote branch rewrite from origin.

Now at github, rewrite branch has new editors dir with new edsel.txt,
master branch is still unchanged.  

So that worked the way we want!  

Next, make another change in edsel, commit and push, then merge with
rewrite, commit and push.   Just use git push (without -u origin <branch>)
to see if that works now.

... edits ...

Jonathans-MacBook-Pro:gtest-rewrite jon$ git status
On branch edsel
...
  new file:   editors/getkey.txt
...
  modified:   editors/edsel.txt

Jonathans-MacBook-Pro:gtest-rewrite jon$ git commit -am 'edsel branch: revise edsel.txt, add getkey.txt'
[edsel ceab46b] edsel branch: revise edsel.txt, add getkey.txt
 2 files changed, 2 insertions(+), 1 deletion(-)
 create mode 100644 editors/getkey.txt
Jonathans-MacBook-Pro:gtest-rewrite jon$ git status
On branch edsel
Your branch is ahead of 'origin/edsel' by 1 commit.
  (use "git push" to publish your local commits)
nothing to commit, working directory clean

Jonathans-MacBook-Pro:gtest-rewrite jon$ git push
Counting objects: 5, done.
Delta compression using up to 4 threads.
Compressing objects: 100% (4/4), done.
Writing objects: 100% (5/5), 429 bytes | 0 bytes/s, done.
Total 5 (delta 1), reused 0 (delta 0)
remote: Resolving deltas: 100% (1/1), completed with 1 local object.
To https://github.com/jon-jacky/gtest
   5392a96..ceab46b  edsel -> edsel

The added and revised file are in the edsel branch at github, but
not yet in rewrite or master.

Now merge edsel into rewrite

Jonathans-MacBook-Pro:gtest-rewrite jon$ git checkout rewrite
Switched to branch 'rewrite'
Your branch is up-to-date with 'origin/rewrite'.
Jonathans-MacBook-Pro:gtest-rewrite jon$ git merge edsel
Updating 5392a96..ceab46b
Fast-forward
 editors/edsel.txt  | 2 +-
 editors/getkey.txt | 1 +
 2 files changed, 2 insertions(+), 1 deletion(-)
 create mode 100644 editors/getkey.txt

Jonathans-MacBook-Pro:gtest-rewrite jon$ cat editors/*
This is the *revision* of the new version of edsel!
file getkey.txt
Jonathans-MacBook-Pro:gtest-rewrite jon$ ls editors
edsel.txt			    getkey.txt

Jonathans-MacBook-Pro:gtest-rewrite jon$ git push
Total 0 (delta 0), reused 0 (delta 0)
To https://github.com/jon-jacky/gtest
   5392a96..ceab46b  rewrite -> rewrite

It is there in the rewrite branch at github.

So this works just like we hope and expect!  

Finish the master branch.  Add this note at the top of BRANCH.md:

"""
This is the *master* branch.

Work in this *master* branch ended on 31 Jan 2023.  This version is
labelled with the tag *version1*.  No further commits here are
planned.  Perhaps there will be a few more small commits for bug fixes
or minor revisions.

This *master* branch contains the Piety system described here in
*Piety/README.md*.  A total rewrite of Piety is now underway in the
*rewrite* branch.  It might be quite a while before the code in
*rewrite* provides equivalent functionality to the code here in
*master*.  See *BRANCH.md* in the *rewrite* branch for the current
status of that branch.
"""

Jonathans-MacBook-Pro:Piety jon$ git branch
* master
Jonathans-MacBook-Pro:Piety jon$ git commit -am 'BRANCH.md: describe final versiion before moving development to rewrite branch'
[master 95e57e7] BRANCH.md: describe final versiion before moving development to rewrite branch
 1 file changed, 15 insertions(+), 1 deletion(-)
Jonathans-MacBook-Pro:Piety jon$ git push
Counting objects: 3, done.
Delta compression using up to 4 threads.
Compressing objects: 100% (3/3), done.
Writing objects: 100% (3/3), 710 bytes | 0 bytes/s, done.
Total 3 (delta 2), reused 0 (delta 0)
remote: Resolving deltas: 100% (2/2), completed with 2 local objects.
To git@github.com:jon-jacky/Piety
   56258bf..95e57e7  master -> master

Jonathans-MacBook-Pro:Piety jon$ git tag -a version1 -m 'final version before moving development to rewrite branch'

Jonathans-MacBook-Pro:Piety jon$ git tag
python2
version1
Jonathans-MacBook-Pro:Piety jon$ git push origin version1
Counting objects: 1, done.
Writing objects: 100% (1/1), 192 bytes | 0 bytes/s, done.
Total 1 (delta 0), reused 0 (delta 0)
To git@github.com:jon-jacky/Piety
 * [new tag]         version1 -> version1

Yes, there is now a version1 tag at github.

Jonathans-MacBook-Pro:~ jon$ mv Piety Piety.version1

We're done with the master branch and version1.


 1 Feb 2023

One more commit in master to add NOTES in README.md about the rewrite,
at the ends of the Current Status and Roadmap sections.  In Roadmap:

"""
NOTE: At this writing (Feb 2023) a total rewrite is underway in the
*rewrite* branch, to simplify the code and improve its organization
and clarity.
"""

Also add that sentence in BRANCH.md

Now, make the new rewrite branch!  Follow the method we tested yesterday

Jonathans-MacBook-Pro:~ jon$ ls -ld Piety*
drwxr-xr-x  30 jon  staff  1020 Feb  1 08:49 Piety.version1/

Jonathans-MacBook-Pro:~ jon$ git clone https://github.com/jon-jacky/Piety Piety
Cloning into 'Piety'...
remote: Enumerating objects: 7859, done.
remote: Counting objects: 100% (895/895), done.
remote: Compressing objects: 100% (316/316), done.
remote: Total 7859 (delta 629), reused 843 (delta 579), pack-reused 6964
Receiving objects: 100% (7859/7859), 1.81 MiB | 1.91 MiB/s, done.
Resolving deltas: 100% (5392/5392), done.
Checking connectivity... done.
Jonathans-MacBook-Pro:~ jon$ cd Piety
Jonathans-MacBook-Pro:Piety jon$ ls -l
total 56
-rw-r--r--   1 jon  staff  14351 Feb  1 08:54 BRANCH.md
-rw-r--r--   1 jon  staff   2246 Feb  1 08:54 DIRECTORIES.md
-rw-r--r--   1 jon  staff   6557 Feb  1 08:54 README.md
drwxr-xr-x   4 jon  staff    136 Feb  1 08:54 asyncio/
drwxr-xr-x   5 jon  staff    170 Feb  1 08:54 bin/
...

Now revise BRANCH.md: "This is the *rewrite* branch. ..."

Jonathans-MacBook-Pro:~ jon$ cd Piety

Oops, I didn't make the new branch yet.   Do it now:

Jonathans-MacBook-Pro:Piety jon$ git branch rewrite
Jonathans-MacBook-Pro:Piety jon$ git checkout rewrite
M			    BRANCH.md
Switched to branch 'rewrite'
Jonathans-MacBook-Pro:Piety jon$ git branch
  master
* rewrite

Jonathans-MacBook-Pro:Piety jon$ git diff
...
-This is the *master* branch.  
+This is the *rewrite* branch.  
...

Good.  Now get going on the deletes.  Take a quick look in each
directory before deleting it.   Be ruthless, we want a fresh start.
We can always copy files from the master branch back to here.

Jonathans-MacBook-Pro:Piety jon$ git rm -r asyncio
rm 'asyncio/README.md'
rm 'asyncio/eventloop.py'

In bin, edit README and delete asyncio script:

Jonathans-MacBook-Pro:bin jon$ git rm asyncio_paths 
rm 'bin/asyncio_paths'

We will still have to edit bin/paths after we finish deleting dirs.

vt_terminal modules are keepers except display_debug.py which refers
to console.

Jonathans-MacBook-Pro:vt_terminal jon$ git rm display_debug.py 
rm 'vt_terminal/display_debug.py'
Jonathans-MacBook-Pro:vt_terminal jon$ ls
README.md			  display.py	key.py

wrappers/ only contained the tao wrapper, so; 

Jonathans-MacBook-Pro:Piety jon$ cp -a wrappers ~/tao_wrapper
Jonathans-MacBook-Pro:Piety jon$ ls -ld ~/*tao*
drwxr-xr-x  8 jon  staff  272 Sep 23  2019 /Users/jon/tao/
drwxr-xr-x  4 jon  staff  136 Feb  1 08:54 /Users/jon/tao_wrapper/
Jonathans-MacBook-Pro:Piety jon$ git rm -r wrappers
rm 'wrappers/README.md'
rm 'wrappers/tao_.py'

Jonathans-MacBook-Pro:Piety jon$ ls -1
BRANCH.md
BRANCH.md~
DIRECTORIES.md
README.md
bin/
doc/
unix/
util/
vt_terminal/

Now edit bin/path and maybe DIRECTORIES.md

Jonathans-MacBook-Pro:Piety jon$ git commit -am 'Delete most files and directories for a fresh start.
> Revise BRANCH.md, DIRECTORIES.md, and bin/paths.'
[rewrite 44e73a3] Delete most files and directories for a fresh start. Revise BRANCH.md, DIRECTORIES.md, and bin/paths.
 312 files changed, 52 insertions(+), 17669 deletions(-)
 rewrite BRANCH.md (99%)
 rewrite DIRECTORIES.md (68%)
 delete mode 100644 asyncio/README.md
 ... many many more ...

Now push.  Just to be safe use the long form.

Jonathans-MacBook-Pro:Piety jon$ git push -u origin rewrite
Counting objects: 8, done.
Delta compression using up to 4 threads.
Compressing objects: 100% (8/8), done.
Writing objects: 100% (8/8), 1.23 KiB | 0 bytes/s, done.
Total 8 (delta 4), reused 0 (delta 0)
remote: Resolving deltas: 100% (4/4), completed with 4 local objects.
remote: 
remote: Create a pull request for 'rewrite' on GitHub by visiting:
remote:      https://github.com/jon-jacky/Piety/pull/new/rewrite
remote: 
To https://github.com/jon-jacky/Piety
 * [new branch]      rewrite -> rewrite
Branch rewrite set up to track remote branch rewrite from origin.

Look at github page for master branch.  At the top yellow box with:

[ Jonathans-MacBook-Pro:Piety jon$ git push -u origin rewrite
Counting objects: 8, done.
Delta compression using up to 4 threads.
Compressing objects: 100% (8/8), done.
Writing objects: 100% (8/8), 1.23 KiB | 0 bytes/s, done.
Total 8 (delta 4), reused 0 (delta 0)
remote: Resolving deltas: 100% (4/4), completed with 4 local objects.
remote: 
remote: Create a pull request for 'rewrite' on GitHub by visiting:
remote:      https://github.com/jon-jacky/Piety/pull/new/rewrite
remote: 
To https://github.com/jon-jacky/Piety
 * [new branch]      rewrite -> rewrite
Branch rewrite set up to track remote branch rewrite from origin.

Jonathans-MacBook-Pro:Piety jon$ git push -u origin rewrite
Counting objects: 8, done.
Delta compression using up to 4 threads.
Compressing objects: 100% (8/8), done.
Writing objects: 100% (8/8), 1.23 KiB | 0 bytes/s, done.
Total 8 (delta 4), reused 0 (delta 0)
remote: Resolving deltas: 100% (4/4), completed with 4 local objects.
remote: 
remote: Create a pull request for 'rewrite' on GitHub by visiting:
remote:      https://github.com/jon-jacky/Piety/pull/new/rewrite
remote: 
To https://github.com/jon-jacky/Piety
 * [new branch]      rewrite -> rewrite
Branch rewrite set up to track remote branch rewrite from origin.

Look at github page for master branch:

[ rewrite had recent pushes less than a minute ago ]

The master branch still has all the directories and files,
and its README.md has the new notes about the rewrite branch.

The rewrite branch at github has only the directories and files
that remained after the big deletion, and the revised BRANCH.md etc.

Now restore the shells directory and write a new, simpler callable python
interpreter.  Call it pycall, save pysh for our notional parentheses-less,
comma-less interpreter.

Jonathans-MBP:shells jon$ git commit -am 'Add shells directory with pycall callable Python interpreter'
[rewrite a91e29d] Add shells directory with pycall callable Python interpreter
 3 files changed, 47 insertions(+), 2 deletions(-)
 create mode 100644 shells/README.md
 create mode 100644 shells/pycall.py

Jonathans-MBP:shells jon$ git push
Counting objects: 6, done.
Delta compression using up to 4 threads.
Compressing objects: 100% (6/6), done.
Writing objects: 100% (6/6), 1.06 KiB | 0 bytes/s, done.
Total 6 (delta 2), reused 0 (delta 0)
remote: Resolving deltas: 100% (2/2), completed with 2 local objects.
To https://github.com/jon-jacky/Piety
   44e73a3..a91e29d  rewrite -> rewrite

Short form push seems to have worked.

Next: make ed branch from rewrite branch for work on new ed.py


 2 Feb 2023

Made minor cosmetic changes to pycall, now it crashes on the first 
call:

Jonathans-MacBook-Pro:shells jon$ python -im pycall
>> 1
Traceback (most recent call last):
  File "/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/runpy.py", line 162, in _run_module_as_main
    "__main__", fname, loader, pkg_name)
  File "/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/runpy.py", line 72, in _run_code
    exec code in run_globals
  File "/Users/jon/Piety/shells/pycall.py", line 33, in <module>
    main()
  File "/Users/jon/Piety/shells/pycall.py", line 30, in main
    continuation = pycall(cmd)
  File "/Users/jon/Piety/shells/pycall.py", line 15, in pycall
    return interpreter.push(cmd)
  File "/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/code.py", line 264, in push
    source = "\n".join(self.buffer)
TypeError: sequence item 0: expected string, int found

-- !?  Try the version we had yesterday.

Jonathans-MacBook-Pro:shells jon$ mv pycall.py pycall.py.crash
Jonathans-MacBook-Pro:shells jon$ git checkout pycall.py
Jonathans-MacBook-Pro:shells jon$ diff pycall.py pycall.py.crash
... as expected ...

Jonathans-MacBook-Pro:shells jon$ python -im pycall
Home-made Python REPL. Type exit() to exit
>> 1
Traceback (most recent call last):
...
TypeError: sequence item 0: expected string, int found

Same error!  I thought this worked!  Maybe we are still using 
the wrong .pyc ?

Jonathans-MacBook-Pro:shells jon$ rm pycall.pyc
Jonathans-MacBook-Pro:shells jon$ python -im pycall
Home-made Python REPL. Type exit() to exit
>> 1
Traceback (most recent call last):
...

Now there still is no pycall.pyc.

DOH!!  It has to be python3!

Jonathans-MacBook-Pro:shells jon$ python3 -im pycall
Home-made Python REPL. Type exit() to exit
>> 1
1
>> (1, 2,
.. 3, 4)
(1, 2, 3, 4)
...

Jonathans-MacBook-Pro:shells jon$ mv -i pycall.py.crash pycall.py
overwrite pycall.py? (y/n [n]) y
Jonathans-MacBook-Pro:shells jon$ python3 -im pycall
>> 1
1
>> (1,2,
.. 3,4)
(1, 2, 3, 4)

Bah, I can't believe I made that mistake!  Press on.

Jonathans-MacBook-Pro:Piety jon$ git branch
  master
* rewrite
Jonathans-MacBook-Pro:Piety jon$ git branch ed
Jonathans-MacBook-Pro:Piety jon$ git checkout ed
M			    BRANCH.md
M			    shells/README.md
M			    shells/pycall.py
Switched to branch 'ed'

.. etc ...

Jonathans-MacBook-Pro:Piety jon$ git status
On branch ed
...
  new file:   editors/README.md
  new file:   editors/ed.py
...
  modified:   BRANCH.md
  modified:   shells/README.md
  modified:   shells/pycall.py

Jonathans-MacBook-Pro:Piety jon$ git commit -am 'add editors directory with new ed.py and README.md
> update BRANCH.md for new ed branch, tweaks in shells/README.md and pycall.py'
[ed ff1058b] add editors directory with new ed.py and README.md update BRANCH.md for new ed branch, tweaks in shells/README.md and pycall.py
 5 files changed, 34 insertions(+), 18 deletions(-)
 create mode 100644 editors/README.md
 create mode 100644 editors/ed.py

Jonathans-MacBook-Pro:Piety jon$ git push -u origin ed
fatal: unable to access 'https://github.com/jon-jacky/Piety/': Failed to connect to github.com port 443: Connection refused

Right, I'm at Sandra's, not connected to internet.  Later, at home:

Jonathans-MBP:editors jon$ git push -u origin ed
Counting objects: 9, done.
Delta compression using up to 4 threads.
Compressing objects: 100% (9/9), done.
Writing objects: 100% (9/9), 1.30 KiB | 0 bytes/s, done.
Total 9 (delta 3), reused 0 (delta 0)
remote: Resolving deltas: 100% (3/3), completed with 3 local objects.
remote: 
remote: Create a pull request for 'ed' on GitHub by visiting:
remote:      https://github.com/jon-jacky/Piety/pull/new/ed
remote: 
To https://github.com/jon-jacky/Piety
 * [new branch]      ed -> ed
Branch ed set up to track remote branch ed from origin.

Yes, everything we want in ed branch is there: new editors dir and
contents, also revised BRANCH.md.

I discovered a problem with reload -- it re-initializes data structures
to empty because it reloads the whole module, *unlike* main().

Can we omit variables from module level that are marked global in functions?
Can we just depend on those functions to initialize them?  Try it.

Jonathans-MBP:editors jon$ python3 -i
Python 3.9.0 (v3.9.0:9cf6752276, Oct  5 2020, 11:29:23) 
[Clang 6.0 (clang-600.0.57)] on darwin
Type "help", "copyright", "credits" or "license" for more information.
>>> import ed
>>> ed.main()
>> filename
Traceback (most recent call last):
  File "<console>", line 1, in <module>
NameError: name 'filename' is not defined

... ditto for buffer and o ...


>> ed.e('README.md')
README.md, 10 lines
>> filename
Traceback (most recent call last):
  File "<console>", line 1, in <module>
NameError: name 'filename' is not defined

... ditto for buffer and o ...

>> dir()
['__annotations__', '__builtins__', '__doc__', '__loader__', '__name__', '__package__', '__spec__', 'ed']

But we got the progress message from e() itself.  So it must have created
local variables and ignored the global ... statement.

Oh dear.  That means reload is not very useful for incremental development
after all.   Instead we will need code that executes selected lines in the
buffer.

 3 Feb 2023

Jonathans-MBP:editors jon$ git commit -am 'ed: first draft file viewer functions: e p z s r etc.'
[ed 1d9b5db] ed: first draft file viewer functions: e p z s r etc.
 2 files changed, 147 insertions(+), 2 deletions(-)
Jonathans-MBP:editors jon$ git push
...
   ff1058b..1d9b5db  ed -> ed

Try experiment with reload.  Separate out all the functions to e
module, then ed has 'from e import *' to get them into main module.
Then periodically reload(e), then if necessary from e
import * again.   Oh, I bet the import won't have any effect, because
we already imported it.  Well, then we can just invoke e.p() etc.

DOH, that won't work because functions in e refer to buffer, etc.!

The only way to do this hot reloading is to execute the new def ..
right from the buffer.  So we should move that code in from version1
as soon as we can.   Maybe even before adding file editing code.

BUT for now we can just reload the whole ed.py then rerun e('ed.py')
each time.  We're not changing the file anyway.

Later - hey, can we just load the functinos at top level with python3
-im e.py then define the global data at the >>> prompt, *only after
that* call the functions?   Both the fcns and data should be in the main
module then, right?

Once again write out a module with just the functions but not the
global data, sked.py - Stone Knife Editor (after Kragen Sitaker's
Stone Knife Forth).

Jonathans-MBP:editors jon$ python3 -im sked
>>> S()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "/Users/jon/Piety/editors/sked.py", line 7, in S
    return len(buffer)-1  # -1 because of zero based index
NameError: name 'buffer' is not defined
>>> buffer = ['\n'] 
>>> S()
0

It worked!  Now initialize the other global variables, copying from
ed.py:

>>> o = 0
>>> filename = 'main'
>>> searchstring = 'main'
>>> pagesize = 12

Now edit away

sked.py, 109 lines
>>> buffer[:10]
['\n', '"""\n', 'sked.py - Stone Knife Editor, inspired by classic Unix ed but even simpler\n', '"""\n', '\n', 'def S():\n', "    'Return index of last line in buffer.  S looks a bit like classic ed $'\n", '    return len(buffer)-1  # -1 because of zero based index\n', '\n', 'def e(fname): \n']
>>> o
109
>>> filename
'sked.py'
>>> searchstring
'main'
>>> pagesize
12

>>> o=1
>>> z
<function z at 0x10b3ef820>
>>> z()
sked.py - Stone Knife Editor, inspired by classic Unix ed but even simpler
"""
... types first 12 lines ...
>>> z(24)
... types next 12 lines ...

Is there a way we can define the globals in a script and run that
script in the REPL *without importing it* to create the variables *in
the main module* - ?

https://stackoverflow.com/questions/1027714/how-to-execute-a-file-within-the-python-interpreter

>>> exec(open("filename.py").read())

Let's try that.  Make sked_globals.py.  This much worked:

Jonathans-MBP:editors jon$ python3 -im sked
>>> o
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
NameError: name 'o' is not defined
>>> exec(open("sked_globals.py").read())
>>> o
0
>>> buffer
['\n']
Jonathans-MBP:editors jon$ python3 -im sked
>>> o
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
NameError: name 'o' is not defined
>>> exec(open("sked_globals.py").read())
>>> o
0
>>> buffer
['\n']
>>> e('sked.py')
sked.py, 118 lines
>>> p(1,10)
>>> v()
Piety
=====

But then --- 

>>> from importlib import reload
>>> reload(sked)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
NameError: name 'sked' is not defined

But didn't something like this work yesterday?  No, we tried just
this and it didn't work then either:

Jonathans-MBP:editors jon$ python3 -im ed
>> e('README.md')
README.md, 10 lines
>> o
10
>> p(1,4)

editors
=======

>> o
10
>> from importlib import reload
>> reload(ed)
Traceback (most recent call last):
  File "<console>", line 1, in <module>
NameError: name 'ed' is not defined
...

But didn't we do some reload experiment?  Yes, even further back:

Jonathans-MBP:editors jon$ python3 -i
Python 3.9.0 (v3.9.0:9cf6752276, Oct  5 2020, 11:29:23) 
[Clang 6.0 (clang-600.0.57)] on darwin
Type "help", "copyright", "credits" or "license" for more information.
>>> import ed
>>> ed.main()
...
>> ed.e('README.md')
README.md, 10 lines
...
>> from importlib import reload
>> reload
<function reload at 0x1053bb820>
>> reload(ed)
<module 'ed' from '/Users/jon/Piety/editors/ed.py'>
>> ed.filename
'main'
>> ed.buffer
['\n']
>> ed.o
0
>> ed.S()
0
>> ed.e('README.md')
README.md, 10 lines
>> ed.buffer
['\n', '\n', 'editors\n', ...

But then we still had globals in the same module.

Hey, can't we *define* function in sked module that execs sked_globals.py - 
but not *call* the function in sked?  Then we import sked and call
the function by hand - after that we can reload sked -- ?

No, function doesn't work.  Apparently it just creates buffer etc.
local to the function.  This does work in sked:

# Comment this out and type it 'by hand' in the REPL just once
# if you intend to reload the sked module during the editing session.
exec(open("skedinit.py").read())

We comment it out, and this works:

onathans-MBP:editors jon$ python3 -im sked
>>> o
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
NameError: name 'o' is not defined
>>> exec(open("skedinit.py").read()) 
>>> o
0
>>> buffer
['\n']

But, we found, we can't reload sked when we start it this way.
Hmn, isn't there a way?  But for now try this:

Jonathans-MBP:editors jon$ python3 -i
Python 3.9.0 (v3.9.0:9cf6752276, Oct  5 2020, 11:29:23) 
[Clang 6.0 (clang-600.0.57)] on darwin
Type "help", "copyright", "credits" or "license" for more information.
>>> import sked as e
>>> e.o
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
AttributeError: module 'sked' has no attribute 'o'

Oh, but now we have no way to run exec(...) *in the imported e module*

Try this: *conditionally* run exec:

Jonathans-MBP:editors jon$ python3 -i
Python 3.9.0 (v3.9.0:9cf6752276, Oct  5 2020, 11:29:23) 
[Clang 6.0 (clang-600.0.57)] on darwin
Type "help", "copyright", "credits" or "license" for more information.
>>> o
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
NameError: name 'o' is not defined
>>> try:
...     _ = o
... except:
...     exec(open("skedinit.py").read())
... 
>>> o
0
>>> buffer
['\n']
>>> o = 42
>>> buffer += ["Hello world"]
>>> buffer
['\n', 'Hello world']
>>> try:
...     _ = o
... except:
...     exec(open("skedinit.py").read())
... 
>>> o
42
>>> buffer
['\n', 'Hello world']

That worked!  Initially o etc. not defined, then conditional exec
defined and initialized them, then update them in REPL, then *same*
conditional execution does *not* reinitialize them.   So 
let's put that in sked now.

Jonathans-MBP:editors jon$ python3 -i
Python 3.9.0 (v3.9.0:9cf6752276, Oct  5 2020, 11:29:23) 
[Clang 6.0 (clang-600.0.57)] on darwin
Type "help", "copyright", "credits" or "license" for more information.
>>> import sked as e
>>> e.o
0
>>> e.buffer
['\n']
>>> e.e('../README.md')
../README.md, 148 lines
>>> e.o = 1
>>> v(24)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
NameError: name 'v' is not defined
>>> e.v(24)
Piety
=====
...

... now test mv page up function ...

>>> e.p(e.S())

>>> e.mv(5)
Pro (13 inch, early 2011), running Mac OS (through 10.11.6 El Capitan,
the most recent version that runs on that hardware).    It has only run in
the Mac OS Terminal, through version 2.6.2 (361.2). It has only
run on CPython downloaded from python.org, through version 3.9.0.

Revised Feb 2023
>>> e.mv(5)
The Piety software has only run on one computer: a MacBook
Pro (13 inch, early 2011), running Mac OS (through 10.11.6 El Capit... test e.mv()
...

So dot is not assigned correctly after mv - fix the code 

def mv...
    ...
    p(start, end)
    o = start # p puts dot at end   

Add that line at the end.

>>> reload(e)
<module 'sked' from '/Users/jon/Piety/editors/sked.py'>

>>> e.mv(5)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "/Users/jon/Piety/editors/sked.py", line 141, in mv
    start, end = o-(pagesize+1), o-1
UnboundLocalError: local variable 'o' referenced before assignment

Right, I forgot to put global o at top of mv.  Fix now, done.

>>> reload(e)
<module 'sked' from '/Users/jon/Piety/editors/sked.py'>
>>> e.S()
148
>>> e.o
148
>>> e.mv(5)
Pro (13 inch, early 2011), running Mac OS (through 10.11.6 El Capitan,
the most recent version that runs on that hardware).    It has only run in
the Mac OS Terminal, through version 2.6.2 (361.2). It has only
run on CPython downloaded from python.org, through version 3.9.0.

Revised Feb 2023
>>> e.mv(5)
this repository in the *python2* tag.  The conversion is described
[here](doc/python3.md).   Piety now requires Python 3.5.

## Tested Platform ##

The Piety software has only run on one computer: a MacBook
>>> 

YAY! It worked!  We are testing, fixing, reloading, and testing editor
code, while we preserve the buffer contents and dot address in a
single long-running Python session!

Jonathans-MBP:editors jon$ git commit -am 'replace ed with sked and skedinit'
[ed 2363cb8] replace ed with sked and skedinit
 2 files changed, 54 insertions(+), 38 deletions(-)
 rename editors/{ed.py => sked.py} (67%)
 create mode 100644 editors/skedinit.py
Jonathans-MBP:editors jon$ git push
...

Next: make Piety self-hosting.  Get sked to where it can be used
to edit the Piety files, including sked itself!

I think all we need to get started are w(rite) file, i(nsert) after
dot (recall empty line 0 precedes line 1), d(elete) and save lines in
paste buffer, then y(ank), insert lines from paste buffer (before or
after?) dot.  Next, less urgent: c(hange), that is substitute.  Then,
some formatting commands: indent and outdent would be convenient for code
etc, and wrap/fill would be convenient for text,


 4 Feb 2023

Write sked st(atus) and w(rite) functions.

>> reload(e)
<module 'sked' from '/Users/jon/Piety/editors/sked.py'>
>>> e.st
<function st at 0x10d3e5280>
>>> help(e.st)
... prints function docstring etc. with cursor control ...
>>> help(e.w)
... prints function docstring etc. with cursor control ...
>>> e.S()
148
>>> e.p(1,5)

Piety
=====

**Piety** is a notional operating system to be written in Python.
>>> e.w('test/README.md')
test/README.md, 148 lines
>>> e.st()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "/Users/jon/Piety/editors/sked.py", line 63, in st
    'no changes need to be saved' if saved 
NameError: name 'saved' is not defined
>>> e.saved = True
>>> e.st()
../README.md, 148 lines, no changes need to be saved

How do we edit a new file?

>>> e.w('nowhere/README.md')
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "/Users/jon/Piety/editors/sked.py", line 50, in w
    with open(fname, 'w') as fd:
FileNotFoundError: [Errno 2] No such file or directory: 'nowhere/RE

st and w working as designed.

Next write i(nsert) and d(elete)


 5 Feb 2023

How do we edit a new file?

>>> e.st()
../README.md, 148 lines, no changes need to be saved
>>> e.e('new.txt')
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "/Users/jon/Piety/editors/sked.py", line 34, in e
    with open(fname, mode='r') as fd:
FileNotFoundError: [Errno 2] No such file or directory: 'new.txt'
>>> e.st()
../README.md, 148 lines, no changes need to be saved

We need to start empty buffer if file not found.  Tried 

    with open(fname, mode='r') as fd:
        buffer = ['\n'] + fd.readlines() # each string in buffer ends with \n
    except FileNotFoundError:
       buffer = ['\n'] # start new file

but syntax is wrong

>>> reload(e)
  ...
  File "/Users/jon/Piety/editors/sked.py", line 38
    except FileNotFoundError:
    ^
SyntaxError: invalid syntax

No error msg if except ... buffer = ... are commented out.

Example here:

https://realpython.com/python-with-statement/#working-with-files

import pathlib
import logging

file_path = pathlib.Path("hello.txt")

try:
    with file_path.open(mode="w") as file:
        file.write("Hello, World!")
except OSError as error:
    logging.error("Writing to file %s failed due to: %s", file_path, error)

So, you have to wrap with open... in a try/except.  Done.

>>> reload(e)
<module 'sked' from '/Users/jon/Piety/editors/sked.py'>
>>> e.st()
../README.md, 148 lines, no changes need to be saved
>>> e.e('README.md')
README.md, 10 lines
>>> e.e('new.txt')
new.txt, 0 lines

It seems to have worked.  Now try append command

>>> e.o
0
>>> e.a()
? 0 out of range, last line is 0

Wrong range check.  We do want to append after line 0.  Fix, done.

>>> reload(e)
<module 'sked' from '/Users/jon/Piety/editors/sked.py'>
>>> e.st()
new.txt, 0 lines, at line 0, no changes need to be saved
>>> e.a()
line 1
line 2
line 3
.
>>> e.st()
new.txt, 21 lines, at line 3, unsaved changes

21 lines - !?  It looks like it's counting every char.

>>> e.S()
21

>>> e.buffer
['l', 'l', 'l', 'i', 'n', 'e', ' ', '3', '\n', 'i', 'n', 'e', ' ', '2', '\n', 'i', 'n', 'e', ' ', '1', '\n', '\n']

Right!  We had

            buffer[o:o] = line + '\n' # sic, insert line at this position
Change to
            buffer[o:o] = [line + '\n'] # sic, insert line at this position

>>> reload(e)
<module 'sked' from '/Users/jon/Piety/editors/sked.py'>
>>> e.e('new.txt')
new.txt, 0 lines
>>> e.st()
new.txt, 0 lines, at line 0, unsaved changes
>>> e.a()
line 1
.
>>> e.st()
new.txt, 1 lines, at line 1, unsaved changes
>>> e.buffer
['line 1\n', '\n']

That looks right.  Now we can test w

>>> reload(e)
<module 'sked' from '/Users/jon/Piety/editors/sked.py'>
>>> e.e('test/new.txt')
test/new.txt, 0 lines
>>> e.st()
test/new.txt, 0 lines, at line 0, no changes need to be saved
>>> a()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
NameError: name 'a' is not defined
>>> e.a()
line 1
line 2
line 3
.
>>> e.st()
test/new.txt, 3 lines, at line 3, unsaved changes
>>> e.buffer
['line 1\n', 'line 2\n', 'line 3\n', '\n']

Almost there, but we have been inserting lines before initial '\n' line,
not after.  Change line[o,o] = .... to [o+1,o+1]

>>> reload(e)
<module 'sked' from '/Users/jon/Piety/editors/sked.py'>
>>> e.e('test/new.txt')
test/new.txt, 0 lines
>>> e.st()
test/new.txt, 0 lines, at line 0, no changes need to be saved
>>> e.a()
line 1
.
>>> e.st()
test/new.txt, 1 lines, at line 1, unsaved changes
>>> e.buffer
['\n', 'line 1\n']

Now we can just keep going

>>> e.a()
line 2
line 3
.
>>> e.st()
test/new.txt, 3 lines, at line 3, unsaved changes
>>> e.buffer
['\n', 'line 1\n', 'line 2\n', 'line 3\n']

Now write:

>>> e.w()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "/Users/jon/Piety/editors/sked.py", line 48, in w
    fname = fname if fname else filename
UnboundLocalError: local variable 'filename' referenced before assignment

Bah, add global.  Done.

>>> reload(e)
<module 'sked' from '/Users/jon/Piety/editors/sked.py'>
>>> e.st()
test/new.txt, 3 lines, at line 3, unsaved changes
>>> e.w()
test/new.txt, 3 lines

Jonathans-MBP:editors jon$ ls test
README.md	      new.txt
Jonathans-MBP:editors jon$ cat test/new.txt 
line 1
line 2
line 3

It worked!  Just need d(elete) to make sked self-hosting. Done, added
y(ank) also.

>>> reload(e)
<module 'sked' from '/Users/jon/Piety/editors/sked.py'>

Do we really have to prefix everything with e. ?   Try this:

>>> from sked import *
>>> st()
test/new.txt, 3 lines, at line 3, unsaved changes

It worked!  We will still need e. for the global variables, though.

>>> e.o
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
AttributeError: 'function' object has no attribute 'o'

Right, we imported sked.e function over e module.

>>> sked.o
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
NameError: name 'sked' is not defined
>>> dir()
['S', '__annotations__', '__builtins__', '__doc__', '__loader__', '__name__', '__package__', '__spec__', 'a', 'advance', 'buffer', 'd', 'e', 'filename', 'mv', 'o', 'p', 'pagesize', 'printline', 'r', 'reload', 's', 'saved', 'searchstring', 'st', 'v', 'w', 'y', 'yank']
>>> dir(sked)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
NameError: name 'sked' is not defined

Right - we did from sked import e.  But sked is still in sys.modules:

>>> import sys
>>> sked in sys.modules
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
NameError: name 'sked' is not defined
>>> 'sked' in sys.modules
True

So this session is sort of borked.  BUT let's try this experiment - we'll
change the def of st, reload, and see if st in main has changed:

>>> reload(sked)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
NameError: name 'sked' is not defined

>>> reload(e)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/importlib/__init__.py", line 140, in reload
    raise TypeError("reload() argument must be a module")

Bah, reload(e) borked the session so we can't reload again.  Exit and restart

Jonathans-MBP:editors jon$ python3 -i
...
>>> import sked as sk
>>> sk.st
<function st at 0x10ce27f70>
>>> sk.o
0
>>> sk.buffer
['\n']

>>> from sk import *
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
ModuleNotFoundError: No module named 'sk'

- !?  Try this:

>>> from sked import *

That worked -- !?  It must find module in sys.modules not main module

>>> st
<function st at 0x10ce27f70>
>>> o
0
>>> e('test/new.txt')
test/new.txt, 3 lines
>>> st
<function st at 0x10ce27f70>
>>> st()
test/new.txt, 3 lines, no changes need to be saved

Try the experiment again - redefine st, restore 'at line %d'

>>> from importlib import reload
>>> reload
<function reload at 0x10cd2a820>
>>> reload(sk)
<module 'sked' from '/Users/jon/Piety/editors/sked.py'>
>>> st()
test/new.txt, 3 lines, no changes need to be saved

This is still the old version

>>> from sked import *
>>> st()
test/new.txt, 3 lines, at line 3, no changes need to be saved

We have to repeat this step after each reload.  Alright.

>>> o
3
>>> sk.o
3
>>> p(1,S())
line 1
line 2
line 3

Now append a line.  I expect o will not change but sk.o will become 4.

>>> a('line 4')
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "/Users/jon/Piety/editors/sked.py", line 167, in a
    if iline < 0 or iline > S():
TypeError: '<' not supported between instances of 'str' and 'int'

Oops.  BUT this crash does not detain us at all.  All the data is
still there.

>>> a()
line 4
.
>>> st()
test/new.txt, 4 lines, at line 4, unsaved changes
>>> o
3
>>> sk.o
4

Right, as expected.

Jonathans-MBP:editors jon$ git commit -am 'sked, skedinit: add editing functions a d y and file w(rite)'
[ed 92cf8f3] sked, skedinit: add editing functions a d y and file w(rite)
 2 files changed, 106 insertions(+), 43 deletions(-)
 rewrite editors/skedinit.py (65%)
Jonathans-MBP:editors jon$ git push
...

We still haven't tested d(elete) and y(ank).

github says 213 lines (192 sloc) and we haven't yet cleaned up those
over-long doc strings in functions.  It's about 4 printed pages.

Keep testing 

>>> p(1,sk.o)
line 1
line 2
line 3
line 4
>>> p(3)
line 3
>>> d()
>>> p(1,sk.o)
line 1
line 2
>>> sk.o
2
>>> sk.buffer
['\n', 'line 1\n', 'line 2\n', 'line 4\n']
>>> sk.yank
['line 3\n']

So both buffers are correct.   Only o is wrong.

Wait, no it isn't!  We typed p(1,sk.o) not p(1,sk.S()) to print
the whole buffer.  More tests:

Excerpts from demo for JC:

>>> sked.e('test/new.txt')
test/new.txt, 0 lines
>>> sked.st()
test/new.txt, 0 lines, at line 0, no changes need to be saved

>>> a()
line 1
line 2
line 3
line 4
line 5
.
>>> st()
test/new.txt, 5 lines, at line 5, unsaved changes

>>> a()
line 6 is here 
.
>>> st()
test/new.txt, 6 lines, at line 6, unsaved changes

>>> p(1,S())
line 1
line 2
line 3
line 4
line 5
line 6 is here 

>>> p(0,S())
line 6 is here 

We didn't see what we expected because p doesn't allow start 0.
BUT then the ouput is not right.  Should print error msg.

>>> p(1,S())
line 1
line 2
line 3
line 4
line 5
line 6 is here 

>>> d(3)

>>> pa = p(1,S())
line 1
line 2
line 4
line 5
line 6 is here 
>>> sked.buffer
['\n', 'line 1\n', 'line 2\n', 'line 4\n', 'line 5\n', 'line 6 is here \n']
>>> sked.yank
['line 3\n']
>>> st()
test/new.txt, 5 lines, at line 5, unsaved changes

buffer, yank, st() are right.  

>>> y()
>>> pa = p(1,S())
line 1
line 2
line 4
line 5
line 6 is here 
line 3

yanked line appears at the end.  So dot didn't get updated by d(3) ?
BUT - p(1,S()) moved dot to the end, it's working right.

>>> st()
test/new.txt, 6 lines, at line 6, unsaved changes
>>> d()
>>> p(1,S())
line 1
line 2
line 4
line 5
line 6 is here 
>>> sked.yank
['line 3\n']
>>> p(2)
line 2
>>> y()
>>> p(1,S())
line 1
line 2
line 3
line 4
line 5
line 6 is here 

Yes, this yanked to the correct location.

So it seems to be working.  What problems have we found?  At L1743:

>>> p(0,S())
line 6 is here 

BUG, doesn't handle p with start == 0.  Fix bug now:

-    start = start if start else o  # BUG: if start == 0 assigns start = o
+    if isinstance(start, int) and start < 1: start = 1 # guard next statement
+    start = start if start else o # None, 0 are both False, guard above need

Commit.  Then remove Piety/shells, but first save the file:

Jonathans-MBP:shells jon$ cp -a pycall.py ~/notes/piety
Jonathans-MBP:shells jon$ cp -a README.md ~/notes/piety/pycall-README.md

Jonathans-MBP:piety jon$ pwd
/Users/jon/notes/piety
Jonathans-MBP:piety jon$ git add pycall.py pycall-README.md 

Jonathans-MBP:Piety jon$ git rm -r shells
rm 'shells/README.md'
rm 'shells/pycall.py'

But we still have to do this to remove not-git files.

Jonathans-MBP:Piety jon$ ls -a shells
#pycall.py#	    .#pycall.py@	README.md~	pycall.pyc
./		    			../			__pycache__/	pycall.py~
Jonathans-MBP:Piety jon$ rm -rf shells

Jonathans-MBP:Piety jon$ git commit -m 'remove shells directory with pycall.py, not needed
> also update BRANCH.md'
[ed 7d4ec9c] remove shells directory with pycall.py, not needed also update BRANCH.md
 2 files changed, 43 deletions(-)
 delete mode 100644 shells/README.md
 delete mode 100644 shells/pycall.py
Jonathans-MBP:Piety jon$ git push

Next: add saved buffers to sked.  For self-hosted development using
sked (not emacs) to edit sked, we need both sked.py and test files
loaded at the same time to test sked conveniently.


10 Feb 2023
Jonathans-MBP:Piety jon$ git commit -am 'sked, skedinit: add saved buffers, new b, n commands and helpers'
[ed c127d8f] sked, skedinit: add saved buffers, new b, n commands and helpers
 2 files changed, 92 insertions(+), 10 deletions(-)
Jonathans-MBP:Piety jon$ git push
...

Now we should be ready to leave emacs behind and go competely self-hosted.

11 Feb 2023

We are self-hosted, writing sked in sked.  Today added l(ine), advance one
line and print, and ml(meta-line), back up one line and print.  Also started
c(), replace string in line.

12 Feb 2023

Completed c().

Small items, maybe need attention or cleanup:

Can we a(ppend) after line 0 to insert text at the start of the buffer?
Does range checking allow this?

Does b() alway work?  What if there is no previous buffer, when we start a 
session, or if we deleted it?   I think we need to initialize buffers and
the current buffer with a scratch.txt buffer that can't be renamed and can't
be killed - scratch is the fallback whenever there isn't another previous
buffer.

Revised v() paging command so it starts at previous dot and mv() so it ends with 
Revised paging commands v() so it starts by printing dot again and mv() so
it ends by printing old dot again.  Makes continuity clear.
previous dot.  That way continuity is clear.

k() might also need the scratch buffer.

Maybe v() should start by printing dot, so consecutive v() overlap 1 line.
Ditto mv()

In sked.py rename variable o to dot then def o(): return dot.   Then after
from sked import * we can use o() in arg lists at the >>> prompt.

What about defining ed ranges , for 1,S(), the whole buffer and ; for dot,S(),
the rest of the buffer.  Can we somehow define something with two elements
and put it in an arg list with *args ?

Here is a test line, after a() does st() say unsaved?
Yes, buf n() says saved.  Both st() and n() are correct - but different!

13 Jan 2023

Used sked to edit home/computing.txt, then generated computing.md and git push.
It worked!  However, we didn't indent the text under the URL line - no easy way
to do that yet in sked - so the formatting for this entry is not the same as
all the others.  So we need an indent function in sked.

Revised a() to allow append after line 0 so we can insert at start of buffer.

We don't have to create default scratch buffer.  If we do b() command when
prev_bufname is not present in saved buffers, it doesn't crash, it just
prints  '? no buffer <name>'

Revised paging command v() so it starts by printing dot not dot+1, revised
backward paging mv() so it ends by printing dot not dot-1.  This makes
continuity clearer.

14 Feb 2023

Demo sked to JC.  Add the k(ill buffer) command.  It works.

Tell JC about my experience with the TI Silent 700 printing terminal in 1980.
Found this YouTube video:

https://www.youtube.com/watch?v=d4pKH2MEzwI

Session using edbrowse starts at 22:40, nearly the end.
Shows speed of printing and carriage motion.

15 Feb 2023

JC recommended f-strings for formatting printed output.  Via Ask Mefi
I find:

https://realpython.com/python-f-strings/

MeFi also recommends https://realpython.com/python310-new-features/ etc.

16 Feb 2023

Define tail() to print the last pagesize lines in buffer, maybe define 
in(dent) then fix k(ill buffer).

17 Feb 2016

Puzzling bug - now b() command causes sked.py<2> to be generated even
though sked.py and sked.py<2> have the same filename, 'sked.py' itself.
This bug appeared after changing items and order of items in saved 
buffers, but we exited and restarted python to generate buffer vars and
stored buffers with new definitions.  Took care to change index in bname,
it looks right, but it's clearly not working.

Now it seems to be working - don't know what cleared problem - but prev_bufname
appears not to be reassigned correctly after e(...).  Fix now.

Jonathans-MBP:editors jon$ git commit -am 'sked: add k(ill buffer), c(hange line) that is substitute
> also l, ml, tail - go to next/previous line and print, print end of buffer
> skedinit: change items and ordering in saved buffers, make sked consistent
> skedinit: initialize saved buffers with scratch.txt, sked cant delete it
> more testing and style changes still needed before we go on to add display'
[ed e453d5e] sked: add k(ill buffer), c(hange line) that is substitute also l, ml, tail - go to next/previous line and print, print end of buffer skedinit: change items and ordering in saved buffers, make sked consistent skedinit: initialize saved buffers with scratch.txt, sked cant delete it more testing and style changes still needed before we go on to add display
 3 files changed, 95 insertions(+), 29 deletions(-)
Jonathans-MBP:editors jon$ git push
...

Later -- try using f-strings for print formatting.  Start with sked.status fcn.

Jonathans-MBP:editors jon$ git commit -am 'sked: replace % formatting with f-strings'
[ed b280f72] sked: replace % formatting with f-strings
 1 file changed, 10 insertions(+), 10 deletions(-)
Jonathans-MBP:editors jon$ git push
...

Next - replace o with dot - this will be tough because o is everywhere so
we can't just c('o','dot'), instead must search for patterns:
 = o  o,  o =  global o  o+ o-   , o   o +=
Make up a query/replace fcn?  No, just s(...), cp(...) then s(), cp()

Here we fix all the ... = o

>>> s('= o')
    basename = os.path.basename(filename)
>>> s()
    start, end = o-pagesize, o
>>> s()
    if iline is None: iline = o
>>> cp('','= dot')
    if iline is None: iline = dot
>>> s()
    if not start: start = o
>>> cp('','= dot')
    if not start: start = dot
>>> s()
    searchstring = old
>>> s()
? '= o' not found

Then:

>>> s('o,')
    bstate = bufname, filename, buffer, o, yank, saved 
>>> cp('','dot,')
    bstate = bufname, filename, buffer, dot, yank, saved 
... etc. many more until ...
>>> s()
? 'o,' not found

This is a quite effective query replace

w() then reload(sked) - it no longer works!  dot doesn't update correctly.
We still have old o in the session - reload revised sked didn't remove it -
and we still have ... else o in sked - including in p() fcn - so the 
cure was to exit python session.  Now import sked finds problems with 
remaining o in skedinit and sked - fix them in emacs, not sked (since sked
is now broken so it doesn't work).   Then restart python session, iomprt
import sked, seems to work correctly now.

In sked, we  still have to def o(): return dot.  Also we missed some old
% format statments with only %d not %s.   Fix both now.

Jonathans-MBP:editors jon$ git commit -am 'sked, skedinit: replace variable o with variable dot
> add function o that returns dot
> replace % format strings with f-strings
> replace  x = x if x else y  with  if not x: x = y 
> '
[ed 4ac324a] sked, skedinit: replace variable o with variable dot add function o that returns dot replace % format strings with f-strings replace  x = x if x else y  with  if not x: x = y
 2 files changed, 51 insertions(+), 47 deletions(-)
Jonathans-MBP:editors jon$ git push
...

Now we are ready to begin working on the display

18 Feb 2023

Looked at the code again.  What is the point of these range checks on 
line numbers?  Can we omit them, what happens if we go out of range?
What does ed do?

Jonathans-MBP:editors jon$ ed test.txt
28
,p
line 1
line 2
line 3
line 4
5p
?
h
invalid address
...
H
2,3d
,p
line 1
line 4
2,5d
?
invalid address
,p
line 1
line 4

So, ed does check the range, for out of range it just just types
? invalid address and doesn't attempt the command.
I used a to type in 10 lines then:

1
line 1
z
line 2
line 3
line 4
line 5
line 6
line 7
line 8
line 9
line 10
z
?
invalid address
1
line 1
z5
line 2
line 3
line 4
line 5
line 6
line 7
z5
line 8
line 9
line 10
z5
?

So z will type as many lines as it can, if it runs out it doesn't print
an errror message, but if you try to run z at eob it just says ? invalid address

I also tried appending at line past end of buffer - it didn't complain, but
just added thelines at the end.  That's how Python range insertion works.
I didn't even try deleting past the end.  Also, negative indices in Python
count backwards from the end.  So there are all these unexpected behaviors
when you use out-of-range indices.   Better to do what ed does - if index out
of range, print error message and exit.


Jonathans-MBP:editors jon$ git commit -am 'sked: add line_valid, range_valid, remove printline'
[ed 6db0a64] sked: add line_valid, range_valid, remove printline
 1 file changed, 45 insertions(+), 49 deletions(-)
Jonathans-MBP:editors jon$ git push
...

Jonathans-MBP:editors jon$ git commit -am 'sked: in a(ppend), use new line_valid'
[ed 852507e] sked: in a(ppend), use new line_valid
 1 file changed, 1 insertion(+), 2 deletions(-)
Jonathans-MBP:editors jon$ git push
...

That's quite a bit better than last night.  Now I think we are really ready
to start on the display.

19 Feb 2023

Start a new 'fred' module that displays one window on the current buffer.
fr(ame) puts a window at the top of the terminal: fr(height=None) with
height lines of text including one status line at the bottom, that show
the information in our sked.status() call.  cl(ear) clears window so you
get full screen REPL again, and restores full-screen scrolling, fr() 
restores window again, limits scrolling to bottom of screen.   

To begin with, just update status line.  Update with buffer name when we
load a buffer with e() or b(), update with line number when we move dot,
update total lines when we a() or d() or y().

20 Feb 2023

Oops, our line_valid prevents us from starting to edit an empty buffer:

>>> e('fred.py')
fred.py, 0 lines
>>> st()
fred.py, at line 0 of 0, file fred.py, saved
>>> a()
? line 0 out of range 1 .. 0
>>> p(1)
? line 1 out of range 1 .. 0

a(0) is a special case - we can't use line_valid in a().

I wanted to start fred.py with this:

"""
fred.py - fred, Frame Editor - display buffer contents as they are updated
          by commands in sked line editor.
"""

Shall we not call line_valid in a(), just check range 0 .. S() inline, 
or revise line_valid to take optional start arg?  That might be easier.

I coded it and no, I don't like that because then you have to remember to 
a(0) not a() to begin editing it empty buffer.  Ugly.  Better to just 
use inline special case valid line check in a() - so we can just a() to
start editing the empty buffer.

Done:

>>> e('fred.py')
fred.py, 0 lines
>>> a()
"""
fred.py - fred, Frame Editor - display buffer contents as they are updated
          by commands in sked line editor.
"""

but then --

>>> tail()
? line -16 out of range 1 .. 4

Because pagesize was 20.  We need to make correction in tail similar 
to what we make in mv().  Done.

This is nice - we can fix errors right in the python session as soon as we
stumble across them.  

Start fred.py, fredinit.py, add them to editors/README.md and git add both.

Jonathans-MBP:editors jon$ git commit -am 'sked: fix a(ppend) so it can add text at start of buffer
> fix tail() so it works when buffer shorter than pagesize
> start display editor, add fred.py and fredinit.py, mention in README.md'
[ed adfab39] sked: fix a(ppend) so it can add text at start of buffer fix tail() so it works when buffer shorter than pagesize start display editor, add fred.py and fredinit.py, mention in README.md
 4 files changed, 20 insertions(+), 3 deletions(-)
 create mode 100644 editors/fred.py
 create mode 100644 editors/fredinit.py
Jonathans-MBP:editors jon$ git push
...

I want to cut from one buffer and paste to another.   This means yank 
buffer can't be part of the stored/restored buffer.  Fix skedinit and sked now.

21 Feb 2023

Ready to test fred.fr(ame) and cl(ear).

>>> import fred
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "/Users/jon/Piety/editors/fred.py", line 6, in <module>
    import terminal_util, display
ModuleNotFoundError: No module named 'terminal_util'

Oh dear, did we not set PYTHONPATH?  I suppose we have to exit
python and run a script.  I suppose there is a python stdlib fcn to do it too.

>>> import sys
>>> sys.path
['', '/Library/Frameworks/Python.framework/Versions/3.9/lib/python39.zip', '/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9', '/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/lib-dynload', '/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/site-packages']
>>> sys.path.append('/Users/jon/Piety/vt_terminal')
>>> sys.path
['', '/Library/Frameworks/Python.framework/Versions/3.9/lib/python39.zip', '/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9', '/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/lib-dynload', '/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/site-packages', '/Users/jon/Piety/vt_terminal']
>>> sys.path.append('/Users/jon/Piety/unix')
...

Jonathans-MBP:editors jon$ git commit -am 'fred.py: add fr(), cl() fcns to create, clear frame
> display.py: add erase_above(), used by fr()
> fredinit: add variables needed by fred
> sked.py: revise comments to look better in help'
[ed 1fab09c] fred.py: add fr(), cl() fcns to create, clear frame display.py: add erase_above(), used by fr() fredinit: add variables needed by fred sked.py: revise comments to look better in help
 5 files changed, 77 insertions(+), 20 deletions(-)
Jonathans-MBP:editors jon$ git push
...

Next: connect fred to sked so fred updates when buffer contents change.
To begin with, just update the status line - we don't have any text displayed
in the fred window yet.

Python help with full screen takeover then restore on exit - *almost* works
with fred.  BUT the top part of the screen still doesn't scroll when help
is active.

Jonathans-MBP:editors jon$ git commit sked.py -m 'sked: update some comments for better help'
[ed a3db850] sked: update some comments for better help
 1 file changed, 6 insertions(+), 6 deletions(-)
Jonathans-MBP:editors jon$ git push
...

>>> w()
sked.py, 352 lines
>>> reload(sked)
<module 'sked' from '/Users/jon/Piety/editors/sked.py'>
>>> from sked import *
>>> print
<built-in function print>
>>> printline
<built-in function print>

>>> import frame
>>> from frame import *
>>> skip
<function skip at 0x10b559f70>
>>> print
<built-in function print>
>>> sked.printline
<built-in function print>

>>> tlines
24
>>> flines
20
>>> wlines
20
>>> fr
<function fr at 0x10b6000d0>
>>> fr()

status line appears on line 20
>>> frame.tlines
33
>>> frame.flines
20
>>> frame.wlines
20

frame.tlines is correct.

>>> p(1)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "/Users/jon/Piety/editors/sked.py", line 197, in p
    printline(buffer[iline], end='') # line already ends with \n
TypeError: skip() got an unexpected keyword argument 'end'

-- !?

>>> skip
<function skip at 0x10b559f70>
>>> sk.printline
<function skip at 0x10b559f70>
>>> print
<built-in function print>
>>> print(1+1)
2

Good, we assigned printline but not print

>>> s('skip')
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "/Users/jon/Piety/editors/sked.py", line 250, in s
    printline(buffer[iline], end='') # line already ends with \n
TypeError: skip() got an unexpected keyword argument 'end'

So s() was patched as intended - but now it doesn't work because skip is broken!
>>> cl
<function cl at 0x10b600160>
>>> cl()
>>> sk.printline
<built-in function print>
>>> s('skip')
def skip():
>>>

And, the cl(ear) command switches printline from skip back to print as intended.
All we have to do is fix skip().

skip() is just this:


def skip():
    'Do nothing, assign to sked.printline to suppress printing during display'
    pass

Maybe it doesn't like pass alone in a fcn body?

change to:

def skip():
    'Do nothing, assign to sked.printline to suppress printing during display'
    return


>>> w()
>>> reload(frame)
<module 'frame' from '/Users/jon/Piety/editors/frame.py'>
>>> from frame import *
>>> fr()
>>> v()
...
  File "/Users/jon/Piety/editors/sked.py", line 197, in p
    printline(buffer[iline], end='') # line already ends with \n
TypeError: skip() got an unexpected keyword argument 'end'

Right, I get it, skip has to have the same arg decl as builtin print()

Try this:

def skip(value, sep=' ', end='\n', file=sys.stdout, flush=False):
    """
    Do nothing, assign to sked.printline to suppress printing during display
    Argument declaration must be the same as builtin print
    """
    return


Now w() , reload() etc.

>>> fr()

status line appears

>>> p()
>>> v()
>>>

It's working! p() and v() are not printing!

>>> cl()
>>> p()
    sk.printline = print # re-enable printing when no display
>>> v(6)
? end of buffer
>>> rv(6)
    sk.printline = skip # suppress printing during display

def cl():
    'cl(ear) away the text editing frame, by restoring full screen scrolling'
    display.set_scroll(1, tlines)
    display.put_cursor(tlines, 1) # set_scroll leaves cursor on line 1
    sk.printline = print # re-enable printing when no display

And, cl() reverses it so it's printing again!  Yay!

>>> win()
>>> p()
>>> v()
>>> p(S())
>>> v()
? end of buffer

So error/progress messages still work, as intended. 

Jonathans-MBP:editors jon$ git commit -am 'rename fred, fredinit to frame, frameinit
> rename fame fr() to win()
> win() patches sk.printline to suppress printing, cl() restores it'
[patch 6ee3da5] rename fred, fredinit to frame, frameinit rename fame fr() to win() win() patches sk.printline to suppress printing, cl() restores it
 3 files changed, 19 insertions(+), 10 deletions(-)
 rename editors/{fred.py => frame.py} (73%)
 rename editors/{fredinit.py => frameinit.py} (100%)
Jonathans-MBP:editors jon$ git push -u origin patch
Counting objects: 5, done.
Delta compression using up to 4 threads.
Compressing objects: 100% (5/5), done.
Writing objects: 100% (5/5), 1.60 KiB | 0 bytes/s, done.
Total 5 (delta 2), reused 0 (delta 0)
remote: Resolving deltas: 100% (2/2), completed with 2 local objects.
remote: 
remote: Create a pull request for 'patch' on GitHub by visiting:
remote:      https://github.com/jon-jacky/Piety/pull/new/patch
remote: 
To https://github.com/jon-jacky/Piety
 * [new branch]      patch -> patch
Branch patch set up to track remote branch patch from origin.

23 Feb 2023

Jonathans-MBP:editors jon$ git commit -am 'frame.py: import sked as ed not sk
> editors/README.me: change file names, frame not fred'
[patch 7ba6109] frame.py: import sked as ed not sk editors/README.me: change file names, frame not fred
 2 files changed, 7 insertions(+), 7 deletions(-)
Jonathans-MBP:editors jon$ git push
...

Now in sked replace dot = ...   with move_dot(...) so it can be patched by
frame.

Jonathans-MBP:editors jon$ git commit -am 'sked: add move_dot, replace dot = ... with move_dot 
> frame: patch sked move_dot to also update window status line
> '
[patch 05dd97f] sked: add move_dot, replace dot = ... with move_dot frame: patch sked move_dot to also update window status line
 2 files changed, 39 insertions(+), 20 deletions(-)
Jonathans-MBP:editors jon$ git push

Jonathans-MBP:editors jon$ git commit -am 'frame: wrap and patch restore_buffer, style tweaks
> sked: add grep(), revise c() to print each changed line not just last one'
[patch 1fdba38] frame: wrap and patch restore_buffer, style tweaks sked: add grep(), revise c() to print each changed line not just last one
 2 files changed, 47 insertions(+), 14 deletions(-)
Jonathans-MBP:editors jon$ git push
...


I found after win() grep() did not display in command region - because
it uses p() which uses printline.  But I *do* want it to display in comman
region, it won't display in editor window.  Not so sure about c(hange) - leave
it for now.  Note that n() alread does the right thing - it is not suppressed
in win() mode.

n() just uses plain old print().  Fixed grep, done, also added line numbers to
output.

So far we have handled move_dot and restore_buffer by wrapping and patching.
But now we have to deal with e(), a(), d(), y(), c() which don't contain
any obvious functions we can easily wrap and patch.  It seems we have to
wrap the whole functions.  I suppose that is reasonable.   

One of the advantages of the wrap-and-patch method is we can *undo* it 
by replacing the original functions with another patch, as we do in cl().
We will have to take care that the wrapper functions in frame do not have
the same names as the wrapped functions in sked, to avoid confusion when
we import both into the top level, and to make it easy to get out of display
mode programmatially with cl() - rename it clr().

We did have some way in the old master branch edsel to back out of the
display editor - review that.
Ah yes, apparently we never re-patched to revert to original no-display
functins.   Instead, each wrapped function includes 'if displaying: ...'
and you turn off the display by setting displaying to false, so wrapped
functions don't call display code.  

The old textframe module that defines the wrapped functions and activates them
is 134 lines (105 sloc).  It includes defining a new BufferFrame class that
inherits Buffer and wraps many of its methods.

Our frame module, which is mostly just wrapping and patching and un-patching
machinery, is already 81 lines (69 sloc) and we have only wrapped move_dot
and restore_buffer.

We need to work on style - win() does not call update_status() - also
factor out patching and unpatching from win() and clr().

Jonathans-MBP:editors jon$ git commit -am 'frame: win() and clr() use new enable_display, disable_display, update_status
> sked: add line numbers to grep
> '
[patch 94b10d3] frame: win() and clr() use new enable_display, disable_display, update_status sked: add line numbers to grep
 2 files changed, 38 insertions(+), 24 deletions(-)
Jonathans-MBP:editors jon$ git push
...

Now deal with wrapping/patching e().  It doesn't call restore_buffer but it
does already call move_dot.  Will that be a problem?  Will we need to call
move_dot again in wrapped e?  Or replace move_dot with dot = ... in e()?
For now just leave move_dot.

Done.  Now after win(), e(...) updates the status line as it should.
Next go on to a(), d(), etc.
These are a bit more difficult because with display they have to capture
dot etc. *before* the append or delete.

Wait, dont' do a() etc. yet.  With just move_dot skip restore_buffer and eW
we have enough to code all the display functions for a file viewer. 
Do that next.

Jonathans-MBP:editors jon$ git commit -am 'frame: wrap and patch sked e(dit) function'
[patch 4d3205e] frame: wrap and patch sked e(dit) function
 1 file changed, 10 insertions(+)
Jonathans-MBP:editors jon$ git push
...

Plan the file viewer.  We need a function load_window() that renders the
initial view into a buffer after e() or b() or...  

Should be pretty simple - just calculate first and last line in buffer
to fit into window, such that dot is near the middle line.
Special cases: (do these overlap?)

1. Entire buffer is shorter than window.  Start at line 1, render to the
end of buffer, then write blank lines to the end of the window.  Mark
dot whereever it is.

25 Feb 2023

Defer load_window for now.  The important idea is that we separate
caculating the location of the window segment in the buffer, and
rendering lines to the window.   The basic rendering fcn is:

 put_segments(...):
    """
    Display consecutive lines from the current buffer in the current window.
    ...

arg list is something like put_segment(bufstart, winstart, nlines)
where bufstart is first line of segment in buffer, winstart is first
line of segment in window, and nlines is n of lines to display.  So
to fill the whole window we have

  def put_window(bufstart):
     put_segment(bufstart, 1, wlines-1)

It's wlines-1 to leave the last window line for status line.
WE have to code put_segment so it draws empty lines to fill out
the segment if we reach the end of the buffer before writing all
nlines.

call it update_lines not put_segment.

Jonathans-MBP:editors jon$ git commit -am 'frame: add open_frame, update_lines, zen, tweak comments'
[patch da9cf16] frame: add open_frame, update_lines, zen, tweak comments
 1 file changed, 36 insertions(+), 8 deletions(-)
Jonathans-MBP:editors jon$ git push
...

27 Feb 2023

Last night we started in frame.py:

def locate_segment()
    'Select segment to put in window, that best positions dot in the window'
    # Several cases:
    # Empty buffer
    # Buffer shorter than window
    # Dot at/near top of buffer, start of buffer in window
    # Dot at/near bottom of buffer, end of buffer in window
    # All others

Never mind all that for now.  Back to update_lines - assign defaults for
e(...) case - Fill window with top of buffer.  Fix e() so it sets dot
at 1 not S().   Then fill in e() so it displays.
Oh, e() defaults won't work because we would want nlines=wlines-1 (-1
to allow for status line) but that is evaluated when fcn is defined,
not each time it is called, right?

>>> nlines=20
>>> def test(n=nlines): print(n)
... 
>>> test()
20
>>> nlines=24
>>> test()
20

28 Feb 2023

There might be a bug in b().  b() switching back and forth between notes.txt
and other.txt keeps selecting design.txt.  Does b() include global prev_buffer?

 1 Mar 2023

>>> win()

Window appears

>>> e('../doc/modules.md')
../doc/modules.md, 103 lines

File is loaded but window remains empty

>>> update_lines(wlines-1, 1, 1)

Now top of file appears in window.  BUT this *same* line appears in 
frame fcn eW, which is supposed to be patched to sked e.  

What if I try eW() instead of e()?

>>> win()
>>> eW('../doc/precursors.md')
../doc/precursors.md, 223 lines

The file contents appear in the window!  Did I forget a global in enable_display?
Right, I forgot to add _e to globals list.  Fix now, reload etc.

Bah, e(...) still doesn't update window, but eW(...) does.

>>> k()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "/Users/jon/Piety/editors/sked.py", line 189, in k
    restore_buffer(prev_bufname if prev_bufname in buffers else 'scratch.txt')
  File "/Users/jon/Piety/editors/frame.py", line 74, in restore_buffer
    _restore_buffer(bname)
  File "/Users/jon/Piety/editors/sked.py", line 88, in restore_buffer
    bufname, filename, buffer, dot, saved = buffers[bname]
ValueError: too many values to unpack (expected 5)

But doesn't that mean eW used an old version of save_buffer ?

Try exiting and restarting python.

That didn't help:

>>> e('frame.py')
frame.py, 137 lines
>>> eW('frame.py')
frame.py, 137 lines

e didn't update window, eW did.  So sked.e isn't getting patched with
frame.eW?  Or do we have to 'from sked import *' again?

>>> frame._e
<function e at 0x10af66430>
>>> sked.e
<function eW at 0x10b038af0>
>>> frame.eW
<function eW at 0x10b038af0>

I presume frame._e here is the original sked.e and we see here sked.e did
get patched with eW.

>>> k()
scratch.txt, at line 0 of 0, file scratch.txt, saved

Now k() works again. Oh, but sked.py wasn't in saved buffers.

>>> from sked import *
>>> clr()
>>> win()
>>> e('sked.py')
sked.py, 372 lines

Yes!  Now the window fills with sked.py!

>>> e('frame.py')
frame.py, 137 lines

And now the window fills with frame.py!

>>> n()
 scratch.txt           0   scratch.txt                     saved
 sked.py             372   sked.py                         saved
>>> sked.prev_bufname
'sked.py'

>>> b()
sked.py, at line 372 of 372, file sked.py, saved

Now status line updates with sked.py again but window does not, 
because we haven't patched b().

>>> k()
sked.py, at line 372 of 372, file sked.py, saved

(This after b() again to make frame.py current again) - Again,
status line updates but window doesn't because we haven't patched k().

Revise frame.py to patch b() and k() now.
Wait, that shouldn't be necessary, frame already patches ed restore_buffer.

>>> frame._restore_buffer
<function restore_buffer at 0x10af66310>
>>> sked.restore_buffer
<function restore_buffer at 0x10af66310>

>>> win()
>>> frame._restore_buffer
<function restore_buffer at 0x10af66310>
>>> frame.restore_buffer
<function restore_buffer at 0x10b038a60>
>>> sked.restore_buffer
<function restore_buffer at 0x10b038a60>

>>> b()
sked.py, at line 372 of 372, file sked.py, saved

BUT window does not update.

>>> b
<function b at 0x10af66550>
>>> sked.b
<function b at 0x10af66550>

>>> restore_buffer
<function restore_buffer at 0x10b038a60>
>>> frame.restore_buffer
<function restore_buffer at 0x10b038a60>
>>> sked.restore_buffer
<function restore_buffer at 0x10b038a60>

>>> sked.b()
frame.py, at line 99 of 137, file frame.py, saved
>>> sked.b()
sked.py, at line 372 of 372, file sked.py, saved

But window does not update.

>>> e('frame.py')
frame.py, 137 lines
>>> e('sked.py')
sked.py, 372 lines

BUt this does update window. - !?

>>> clr()
>>> frame.restore_buffer
<function restore_buffer at 0x10b038a60>
>>> sked.restore_buffer
<function restore_buffer at 0x10af66310>
>>> frame._restore_buffer

>>> frame._restore_buffer
<function restore_buffer at 0x10af66310>

So it looks like the functions are getting patched and restored as intended.

YAUUGGHHHH!  I forgot to call update_lines in restore_buffer!  Fix now.

That worked!  Now b() and k() put the new buffer contents in the window.

BUT what to do about update_status() calls in sked.restore_buffer and eW?
In sked, b() and k() already call st() - should we just wrap/patch st
to update status line?  BUT sked e() does not call st() - it prints a 
different message - so we should leave update_status call in frame eW.

Also, frame win() does not fill the window with the current buffer.
Just add update_lines(...) to win right before update_status()
Change sked st() to call printline not print, then wrap st() in frame.
Delete call to update_status in frame restore_buffer because sked b and k
already call st, which is now wrapped and patched.

Test - it all works, BUT we have to 'from sked import *' after win() so e()
works properly, updates window.   Right, we have to pull patched e into top
level so we get that version when we type e().  Likewise, after clr(), e()
displays at top of screen until we do from sked import *.   But then, after
that, we can switch back and forth and it works.   Maybe we just have to
go through a cycle to assign frame _e and frame _st with the current sked 
versions?  I'm not sure I understand this ...

Get rid of eW and stW naming - frame.e and sked.e are distinct,  ...W is 
just superstitious.  Done.

Next: make win() display segment around dot.  Write locate_segment.
Special case is empty buffer, when you e() a new file, or b('scratch.txt').
Maybe we don't have to make this a special case.

Aside: grep not working

>>> p(1)
"""
>>> grep('bstart')
? 'bstart' not found
>>> s('bstart')
def update_lines(nlines, bstart, wstart):

How is that possible?

Jonathans-MBP:editors jon$ git commit -am 'frame: add locate_segment, use in restore_buffer and win
> ed: st uses printline not print, e() puts dot at line 1 not the end'
[patch d49eeaf] frame: add locate_segment, use in restore_buffer and win ed: st uses printline not print, e() puts dot at line 1 not the end
 2 files changed, 30 insertions(+), 8 deletions(-)
Jonathans-MBP:editors jon$ git push
...

And it works too - b(), k(), win() show window centered on dot.
Next: add marker to show dot in window.

 2 Mar 2023

We do need frame.buftop - we need it to calculate the location of dot.
I'm not crazy about that name - or the names of other frame/window vars.
What did we call them in v1?

Oops, now e(...) is not updating window.  Neither is b().

Also: 

>>> grep('buftop')
? 'buftop' not found

but

>>> s('buftop')
    global buftop

Grrr...   I broke several things.

Back to naming.  In current frameinit: tlines, flines, wlines, wintop, buftop
In v1 frame: frame_top (not in current, implicit 1), 
cmd_1 (not in present, implicit flines+1)
cmd_h (not in present, implicit flines - wlines)
windows_h (our present flines)
In v1 window: top (our current wintop) nlines (our wlines) btop (our buftop)
I prefer our current names, including especially use of implicits.

Now get b(),k(),e() filling window again - is it btop/buftop confusion?
s/btop/buftop/ throughout frame, now b() and k() update window, e() does not-
does not even update status line.
Don
t see anything obviously wrong with the code.  Try running fcns from command line 
and looking at function object id's.

Could it be something to do with 'from sked import *' - am I importing
the original unwrapped, unpatched version of sked.e which is shadowing
the frame.e that I want?

Exit, restart Python, import sked and frame:

Jonathans-MBP:editors jon$ python3 -i
...
>>> import sked
>>> import frame
>>> sked.e
<function e at 0x105321430>
>>> frame.e
<function e at 0x1053f2d30>
>>> sked.e('sked.py')
sked.py, 372 lines
>>> frame.e('frame.py')
>>> frame.e('frame.py')
frame.py, 155 lines
... window, status line appear with frame.py contents and status...
... BUT it scrolls away - we didn't call win() so didn't set scroling region...
>>> frame.clr()
... has no effect because we still have full-screen scroll anyway. ...
>>> from sked import *
>>> e('README.md')
README.md, 15 lines
>>> from frame import *
>>> e('frameinit.py')
>>> e('frameinit.py')
frameinit.py, 18 lines
... again, window with status line appears ...

So, we need to distinguish wrapped fcns in frame.py with different names
so we don't shadow sked fcns with frame fcns after 'from frame input *'
In general, all module-level names need to be unique across *all* the modules
where we might 'from <module> import *'.  We need to do this for frame because
we need win() and clr() ... and zen()!

Try this naming convention: frame.e_ wraps sked.e, etc.   Done.

Now after reload frame.py and win(), e() works again - it fills window with
text.  b() and k() also work.   Now lets' clr(), they still work, then win()
again - again b(), k(), e() work.   Consider that fixed.

Now - what about printing all the lines found by grep() and changed by c(...) ?

>>> st()
analogies.md, at line 1 of 178, file ../doc/analogies.md, saved
>>> p(1)
>>> grep('Piety')
? 'Piety' not found
>>> s('Piety')
Operating System Analogies in Piety

This was the problem we saw earlier.  Why can't grep find the target?
Did we forget start,end args?

>>> grep('Piety',1,S())
  2 Operating System Analogies in Piety
  5 Piety aspires to be an operating system, but not like a conventional
  ...
172 The operating system that Piety resembles the most is

Yes, that's it.  Change defaults from dot to whole buffer.

Jonathans-MBP:editors jon$ git commit -am 'frame: <name>_ for saved ref to ed.<name>, to prevent name clash and shadowing
> sked: grep default range is entire buffer, grep does not change dot
>  c() sets saved = False (bug fix)'
[patch 6e476fc] frame: <name>_ for saved ref to ed.<name>, to prevent name clash and shadowing sked: grep default range is entire buffer, grep does not change dot  c() sets saved = False (bug fix)
 3 files changed, 28 insertions(+), 21 deletions(-)
Jonathans-MBP:editors jon$ git push
remote: Invalid username or password.
fatal: Authentication failed for 'https://github.com/jon-jacky/Piety/'

Bah.  I suppose that is related to email from github yesterday:

'Your personal access token as expired'

 5 Mar 2023

Try to get git push working again.  Look up git email and click on this link:

"this token is still needed, visit https://github.com/settings/tokens/1088925367/regenerate to generate an equivalent."

I click on link, it asks for password, I use 100153nbj, that works, I select
'No expiration', it warns me against that.  Okay, say 90 days.
Click [Regenerate token]  It gives me:

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

"... copy it now. You will not be able to see it again

Expires Sat Jun 3 2023.  For scope, check [x] repo and everything under it.
Leave unchecked all the many many other options, including user, admin, and
delete_repo.   Select [Update Token]  

"Tokens you have generated that (sic) can be used to access the GitHub API

Personal access tokens (classic) function like ordinary OAuth access tokens. They can be used instead of a password for Git over HTTPS, or can be used to authenticate to the API over Basic Authentication."

Now try git push again:

Jonathans-MBP:editors jon$ git push
Username for 'https://github.com': jon-jacky
Password for 'https://jon-jacky@github.com': 
Counting objects: 6, done.
Delta compression using up to 4 threads.
Compressing objects: 100% (6/6), done.
Writing objects: 100% (6/6), 1.12 KiB | 0 bytes/s, done.
Total 6 (delta 4), reused 0 (delta 0)
remote: Resolving deltas: 100% (4/4), completed with 4 local objects.
To https://github.com/jon-jacky/Piety
   d49eeaf..6e476fc  patch -> patch

I pasted in the token at Password...: above, it did not echo.
Changes appear at github.  It worked.

 7 Mar 2023

Next: add marker to display.  Copy code from window.py in master branch.
Master branch put_marker iline arg is line in buffer not window, but now
let's use iline in window, not buffer.   In general we want a coding style
that's less nested function calls and more in-line.
BUT dot is line in buffer, not window.  

Jonathans-MBP:editors jon$ git commit -am 'frame: define and call put_marker'
[patch 6785d41] frame: define and call put_marker
 1 file changed, 12 insertions(+)
Jonathans-MBP:editors jon$ git push
....

Bug:

>>> e('new.txt')
new.txt, 0 lines

status line says

new.txt, at line 1 of 0, file new.txt, saved  

In window, there is no mark at line 1, and last line in window persists
from previous buffer, was not overwritten by empty line.

 9 Mar 2023

Aside - it occured to me that calling win() (or anything that calls
enable_display) a second time before calling clr() (or disable_display)
the the saved _e etc. in frame will become corrupted with the patched 
versions, right?

Back to the problem with empty buffers.
Once again e('new.txt') a new file.  Once again no marker in line one and
leftover line in last line of window.

>>> frame.wlines
20

>>> e('lines40.txt')
lines40.txt, 40 lines

That works - line 1 appears in window top line, line 19 appears in window
bottom line right above status line, which is also right.  So problem is 
limited to the empty buffer.
Not clearing last line is independent of marker.  When buffer lines fill window
it is not a problem, so problem must be in last lines of update_lines that 
clear the bottom of the window.
Doh, code says for iline in range(nelines) not nelines+1 - range is
up-to (exclusive) but we want up-through (inclusive).
Now look again at marker.  How does bufline arg get assigned by e() when
new file?   It just passes ed.dot, which is 0.

>>> e('new.txt')
new.txt, 0 lines
>>> st()
new.txt, at line 1 of 0, file new.txt, saved
>>> sked.dot
1

No, dot is okay here.

>>> e('new.txt')
new.txt, 0 lines
>>> st()
new.txt, at line 1 of 0, file new.txt, saved
>>> ed.buffer
['\n']
>>> S()
0

In def put_marker, everything looks okay.  What about winline = bufline - buftop + 1 - ?
Is that (1 - 1) + 1 = 1 or 1 - (1+1) = -1 ?  Oh, but next line should handle that.
*Not* in window mode, try this:

>>> put_marker(1, display.white_bg)

It works! Marker appears in line 1, col 1.  Oh, but it says ["] - where is 
that from?

>>> ed.buffer[:2]
[
['\n','"""\n']

Right, it did the right thing but now we're in a different buffer.

>>> e('new.txt')

It draws window and status line.

>>> ed.buffer
['\n']

>>> ed.dot
1
>>> put_marker(ed.dot, display.white_bg)

It did the right thing.  Put an empty marker in line 1, col 1.

>>> update_status()

That also did the right thing, and marker stays put - did not scroll away
off top.  Are we *sure* we are running version of code with put_marker call?
Just to be sure, w() reload(frame), from frame import *, win() then

>>> e('new.txt')
new.txt, 0 lines

Now entire window is empty, no more leftover last line - we fixed that - 
but still no marker.  Next thing to try is debug prints in body of
put_marker - then when we run it in clr() mode they should print nicely.

>>> w()
frame.py, 172 lines
>>> reload(frame)
<module 'frame' from '/Users/jon/Piety/editors/frame.py'>
>>> from frame import *
>>> put_marker(1, display.white_bg)
bufline 1, buffer ['\n', '"""\n', "frame.py - Frame Editor - display buffer contents in a 'frame' of windows\n"], S() 172
ch0 ", winline 1

And it puts the marker in line 1, col 1 with ["], frame.py is current.
Try simulating e('new.txt')

>>> ed.buffer=['\n']
>>> ed.dot=1
>>> put_marker(ed.dot, display.white_bg)

>>> put_marker(ed.dot, display.white_bg)
bufline 1, buffer ['\n'], S() 0
ch0  , winline 1

It did the right thing, put blank marker at line 1, col 1.

Let's try using win() then e('new.txt')

>>> win()

It puts empty window with empty marker at line1, col1 
status line:  frame.py, at line 1 of 0, file frame.py, saved

>>> e('frame.py')
frame.py, 172 lines

Top of frame.py contents appear in window, but no marker anywhere.
status line says: frame.py, at line 1 of 172, file frame.py, saved

>>> e('new.txt')
new.txt, 0 lines

Empty window, no marker, status line: new.txt, at line 1 of 0, file new.txt, ...
Can't see the debug prints anywhere.

>>> clr()
>>> b()
frame.py, at line 1 of 172, file frame.py, saved
>>> l()
frame.py - Frame Editor - display buffer contents in a 'frame' of windows
>>> st()
frame.py, at line 2 of 172, file frame.py, saved
>>> win()

Now top of frame appears in window, with marker [f] at line 2, col 1
status line: frame.py at line 2 of 172, ...

So it's not just empty files where marker doesn't appear in line 1.

>>> clr()
>>> rl()
"""

>>> win()

Now the marker with ["] appears on line 1, col 1

>>> b('lines40.txt')

Now marker with [l] appears on line 1, col 1

>>> ed.buffers['scratch.txt']
('scratch.txt', 'scratch.txt', ['\n'], 0, True)
>>> b('scratch.txt')

Now empty marker appears in line 1, col 1 of empty window.

status line says scratch.txt, at line 0 of 0 ...

>>> e('new.txt')
new.txt, 0 lines

blank window appears with no marker, status: new.txt at line 1 of 0

>>> b()

blank window appears with empty marker at 1,1, scratch.txt at line 0 of 0

>>> b('frame.py')
>>> k()
>>> e('frame.py')
frame.py, 172 lines

Now frame.py appears in window but no marker.   

>>> e('README.md')
README.md, 15 lines

README.md appears but no marker, at line 1 of 15

>>> b()

Now frame.py appears with ["] marker at 1,1 'at line 1 of 172'

>>> b()

Now README.md at line 1 of 15, ...    No marker

BUT in README.md line 1 is empty:

>>> ed.buffer
['\n', '\n', 'editors\n', ... ]

We really need to see what put_marker is doing when win is active.  
Can't we print(..., out=log.txt) where out.txt is a stringin or whatever
it
s called?

Look up documentation when *not* connected to internet.  It's all there:

file:///Library/Frameworks/Python.framework/Versions/3.9/Resources/English.lproj/Documentation/contents.html

file:///Library/Frameworks/Python.framework/Versions/3.9/Resources/English.lproj/Documentation/tutorial/index.html

file:///Library/Frameworks/Python.framework/Versions/3.9/Resources/English.lproj/Documentation/reference/index.html


file:///Library/Frameworks/Python.framework/Versions/3.9/Resources/English.lproj/Documentation/library/index.html

We find what we were looking for, StringIO in 

file:///Library/Frameworks/Python.framework/Versions/3.9/Resources/English.lproj/Documentation/library/io.html#in-memory-streams

Example usage:

import io

output = io.StringIO()
output.write('First line.\n')
print('Second line.', file=output)

# Retrieve file contents -- this will be
# 'First line.\nSecond line.\n'
contents = output.getvalue()

# Close object and discard memory buffer --
# .getvalue() will now raise an exception.
output.close()

Try to set it up ad-lib:

>>> import io
>>> frame.log = io.StringIO()

>>> c("')","', out=log)")
    print(f'bufline {bufline}, buffer {ed.buffer[:3]}, S() {ed.S()}', out=log)

>>> c("')","', out=log)")
    print(f'ch0 {ch0}, winline {winline}', out=log)

>>> put_marker(1, display.white_bg)
bufline 1, buffer ['\n', '"""\n', "frame.py - Frame Editor - display buffer contents in a 'frame' of windows\n"], S() 172
ch0 ", winline 1

marker ["] appaers in 1,1.  We didn't reload so print is still going to stdout.

>>> w()
frame.py, 172 lines
>>> reload(frame)
<module 'frame' from '/Users/jon/Piety/editors/frame.py'>
>>> from frame import *
>>> put_marker(1, display.white_bg)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "/Users/jon/Piety/editors/frame.py", line 57, in put_marker
    print(f'bufline {bufline}, buffer {ed.buffer[:3]}, S() {ed.S()}', out=log)
TypeError: 'out' is an invalid keyword argument for print()

Right - it should be file=log

>>> s('out=')
    print(f'bufline {bufline}, buffer {ed.buffer[:3]}, S() {ed.S()}', out=log)
>>> c('out=','file=')
    print(f'bufline {bufline}, buffer {ed.buffer[:3]}, S() {ed.S()}', file=log)
>>> s()
    print(f'ch0 {ch0}, winline {winline}', out=log)
>>> c('out=','file=')
    print(f'ch0 {ch0}, winline {winline}', file=log)
>>> w()
frame.py, 172 lines
>>> reload(frame)
<module 'frame' from '/Users/jon/Piety/editors/frame.py'>
>>> from frame input *

>>> put_marker(1, display.white_bg)

Marker ["] appears at 1,1

>>> frame.log
<_io.StringIO object at 0x1053f5430>
>>> frame.log.getvalue()
'bufline 1, buffer [\'\\n\', \'"""\\n\', "frame.py - Frame Editor - display buffer contents in a \'frame\' of windows\\n"], S() 172\nch0 ", winline 1\n'
>>> print(frame.log.getvalue())
bufline 1, buffer ['\n', '"""\n', "frame.py - Frame Editor - display buffer contents in a 'frame' of windows\n"], S() 172
ch0 ", winline 1

>>> win()

Now window appears, status at line 62 ...  blank marker at start of:

[ ]    print(f'ch0 {ch0}, winline {winline}', file=log)

This is dot, the last line where we did c(...)

>>> print(frame.log.getvalue())
..
bufline 62, buffer ['\n', '"""\n', "frame.py - Frame Editor - display buffer contents in a 'frame' of windows\n"], S() 172
ch0  , winline 11

Good, we're recording debug print output while in win mode.

>>> e('new.txt')
new.txt, 0 lines
>>> print(frame.log.getvalue())
bufline 1, buffer ['\n', '"""\n', "frame.py - Frame Editor - display buffer contents in a 'frame' of windows\n"], S() 172
ch0 ", winline 1
bufline 62, buffer ['\n', '"""\n', "frame.py - Frame Editor - display buffer contents in a 'frame' of windows\n"], S() 172
ch0  , winline 11

We got no marker - but also no debug print output from put_marker!

>>> b()

status: frame.py, at line 62   Fills window.  Empty mark at line:
[ ]     print(f'ch0 {ch0}, winline {winline}', file=log)

>>> print(frame.log.getvalue())
bufline 1, buffer ['\n', '"""\n', "frame.py - Frame Editor - display buffer contents in a 'frame' of windows\n"], S() 172
ch0 ", winline 1
bufline 62, buffer ['\n', '"""\n', "frame.py - Frame Editor - display buffer contents in a 'frame' of windows\n"], S() 172
ch0  , winline 11
bufline 62, buffer ['\n', '"""\n', "frame.py - Frame Editor - display buffer contents in a 'frame' of windows\n"], S() 172
ch0  , winline 11

We go tthe marker and the third pair of lines here is for the marker.

>>> b('README.md')

README.md appears in window but no marker on empty line 1:
README.md, at line 1 of 15

bufline 1, buffer ['\n', '\n', 'editors\n'], S() 15
ch0 
, winline 1

Oh, ch0 is just a newline \n.  I think I see the problem - our test for
empty line is wrong.  We have:

    ch0 = line[0] if line else ' '  # line might be empty

but

>>> True if '' else False
False
>>> True if '\n' else False
True

*All* lines have \n at the end so no line will ever be considered empty.
In .version1 window.py we have:

self.buf.lines[iline] in ('','\n')

The other option is to trim the line:

line.rstrip(chars='\n')


>>> True if '\n'.rstrip('\n') else False
False

fix code:

>>> p()
    ch0 = line[0] if line.rstrip('\n') else ' ' # line might be empty or just 

\n prints here as an actual newline.

Now b('README.md') does put the mark at the beginning of blank line 1.
BUT e('new.txt') still shows no mark at line 1.  new.txt, at line 1 of 0
At end of log we just see:

bufline 1, buffer ['\n', '\n', 'editors\n'], S() 15
ch0  , winline 1

from README.md.   Is e() just not calling put_marker?

>>> put_marker(ed.dot, display.white_bg)

[ ] marker appears at 1,1

I checked the code - frame e_() does call put_marker.  Are we not calling
the latest e_ ?

>>> win()
>>> frame._e
<function e at 0x1053214c0>
>>> frame.e_
<function e_ at 0x105479040>
>>> ed.e
<function e_ at 0x105479040>

That looks right.  But let's exit and restart python just to be sure.

Jonathans-MBP:editors jon$ python3 -i
Python 3.9.0 (v3.9.0:9cf6752276, Oct  5 2020, 11:29:23) 
[Clang 6.0 (clang-600.0.57)] on darwin
Type "help", "copyright", "credits" or "license" for more information.
>>> import sked
>>> from sked import *
>>> import frame
>>> from frame import *

>>> win()
...
NameError: name 'log' is not definedor "license" for more information.

>>> import io
>>> frame.log = io.StringIO()

We did clr() before that.

>>> win()

Now empty window with mark [ ] at 1,1.  scratch.txt at line 0 of 0 ...

>>> print(frame.log.getvalue())
bufline 0, buffer ['\n'], S() 0
ch0  , winline 1

>>> e('new.txt')
new.txt, 0 lines

Now we see empty window but with [ ] mark at 1,1 - as it should be.
new.txt, at line 1 of 0 ...

>>> e('frame.py')
frame.py, 173 lines

empty window!  But with [ ] mark at 1,1  frame.py, at line 1 of 173
>>> e('README.md')
README.md, 15 lines

Another empty window!  README.md, at line 1 of 15   -- !!??

>>> b()

Now frame.py appears in window.  frame.py, at line 1 of 173

>>> b()

Now README.md appears in window.

>>> e('sked.py')
sked.py, 375 lines

README.py still visible but: sked.py, at line 1 of 375

>>> b()

README.py remains visible

>>> b()

sked.py appears

So b() works

>> k()

README.md reappears

So b() k() work, e() put_marker and update_status work but not update_lines

>>> frame._e
<function e at 0x1043a2430>
>>> frame.e_
<function e_ at 0x104476ca0>
>>> sked.e
<function e at 0x1043a2430>

>>> win()
>>> frame.e_
<function e_ at 0x104476ca0>
>>> frame._e
<function e at 0x1043a2430>
>>> sked.e
<function e_ at 0x104476ca0>

After win(), window fills with frame.py, frame.py, at line 120 of 173

>>> b('README.md')

shows README.md

>>> b()

Back to frame.py

>>> k()

Back to README.md

>>> e('frame.py')
frame.py, 173 lines

status line updates frame.py, at line 1 of 173 cursor at 1,1
but window does not update with frame.py lines.

>>> e
<function e at 0x1043a2430>

Oh, that's the *unpatched* e from sked, not e_ from frame.

>>> from frame import *
>>> e
<function e at 0x1043a2430>

>>> clr()
>>> win() 

frame.py appears

>>> e
<function e at 0x1043a2430>
>>> from frame import *
>>> e
<function e at 0x1043a2430>
>>> frame._e
<function e at 0x1043a2430>
>>> frame.e_
<function e_ at 0x104476ca0>

I think I must have scrambled up e _e and e_.   Exit and restart python.

Jonathans-MBP:editors jon$ python3 -i
...
>>> import sked
>>> from sked import *
>>> import frame
>>> from frame import *
>>> sked.e
<function e at 0x10a23d430>
>>> frame._e
<function e at 0x10a23d430>
>>> frame.e_
<function e_ at 0x10a311ca0>
>>> e
<function e at 0x10a23d430>

>>> win()

...
NameError: name 'log' is not defined

>>> import io
>>> frame.log = io.StringIO()
>>> win()

scratch.txt, at line 0 of 0
empty window with [ ] mark at 1,1

>>> sked.e
<function e_ at 0x10a311ca0>
>>> e
<function e at 0x10a23d430>

>>> from sked import *
>>> e
<function e_ at 0x10a311ca0>

>>> e('frame.py')
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "/Users/jon/Piety/editors/frame.py", line 110, in e_
    _e(fname)
  File "/Users/jon/Piety/editors/frame.py", line 110, in e_
    _e(fname)
  File "/Users/jon/Piety/editors/frame.py", line 110, in e_
    _e(fname)
  [Previous line repeated 996 more times]
RecursionError: maximum recursion depth exceeded

How did I break this?  It was working until quite recently.

git diff doesn't show anything related to e _e e_

Let's remove debug prints from put_marker, just to uncomplicate things.

>>> clr()
>>> e('frame.py')
RecursionError: maximum recursion depth exceeded
>>> e
<function e_ at 0x10a311ca0>
>>> frame._e
<function e_ at 0x10a311ca0>
>>> frame.e_
<function e_ at 0x10a311ca0>
>>> sked.e
<function e_ at 0x10a311ca0>

How did this happen - !?

>>> st()
  File "/Users/jon/Piety/editors/frame.py", line 104, in st_
    _st()
  [Previous line repeated 996 more times]
RecursionError: maximum recursion depth exceeded

Gah!

>>> ^D
Jonathans-MBP:editors jon$ python3 -i
>>> import sked
>>> import frame
>>> from sked import *
>>> from frame import *
>>> sked.e
<function e at 0x10287c430>
>>> frame._e
<function e at 0x10287c430>
>>> frame.e_
<function e_ at 0x102950ca0>
>>> e
<function e at 0x10287c430>
>>> e('sked.py')
sked.py, 375 lines
>>> st()
sked.py, at line 1 of 375, file sked.py, saved
>> e('sked.py')
NameError: name 'log' is not defined

Argh! Forgot to fix!  But check state now:

...

Jonathans-MBP:editors jon$ python3 -i
...

Now we commented out debug prints in put_marker

>>> import sked
>>> import frame
>>> from sked import *
>>> from frame import *
>>> sked.e
<function e at 0x103093430>
>>> frame._e
<function e at 0x103093430>
>>> frame.e_
<function e_ at 0x103183dc0>
>>> e
<function e at 0x103093430>
>>> e('sked.py')
sked.py, 375 lines
>>> st()
sked.py, at line 1 of 375, file sked.py, saved

>>> win()

sked.py appears in window: sked.py, at line 1 of 375

>>> win()
>>> sked.e
<function e_ at 0x103183dc0>
>>> frame._e
<function e at 0x103093430>
>>> frame.e_
<function e_ at 0x103183dc0>
>>> e
<function e at 0x103093430>

>>> sked.e('frame.py')
frame.py, 173 lines

appears in window, frame.py, at line 1 of 173

>>> e('README.md')
README.md, 15 lines

Window does not update, but README.md, at line 1 of 15

>>> from sked import *
>>> e
<function e_ at 0x103183dc0>

>>> e('skedinit.py')
skedinit.py, 28 lines

It does appear in window, skedinit.py, at line 1 of 28

>>> clr()
>>> sked.e
<function e at 0x103093430>
>>> e
<function e_ at 0x103183dc0>

>>> e('../doc/analogies.md')
../doc/analogies.md, 178 lines

Window still updates, even after clr()

I don't see how this can work if top level fcn e is
patched.  It can only work if we patch fcns which are not 
commands, like restore_buffer.  Isn't that the only one?
st also is a commamnd.

>>> b()
skedinit.py, at line 1 of 28, file skedinit.py, saved
>>> b()
analogies.md, at line 1 of 178, file ../doc/analogies.md, saved
>>> k()
skedinit.py, at line 1 of 28, file skedinit.py, saved

These do not update the display status line.  These are working
as they should.

>>> st()
skedinit.py, at line 1 of 28, file skedinit.py, saved

This does update a status display line.

>>> from sked import *

>>> st()
skedinit.py, at line 1 of 28, file skedinit.py, saved

Now it doesn't update the status display line.

Maybe this is how it always worked - did we always 'from sked import *'
after win() and clr() - ?

win() then b() k(), then clr() then b() and k() do work.    Now after clr()
st() works as it should - it doesn't write to display line - !?

>>> clr()
>>> st()
frame.py, at line 1 of 173, file frame.py, saved
>>> st
<function st at 0x1030931f0>
>>> frame._st
<function st at 0x1030931f0>
>>> frame.st_
<function st_ at 0x103183d30>
>>> sked.st
<function st at 0x1030931f0>

>>> st()
frame.py, at line 1 of 173, file frame.py, saved

prints, but doesn't update display line.

>>> win()

frame.py appears in window

>>> win()
>>> st
<function st at 0x1030931f0>
>>> frame._st
<function st at 0x1030931f0>
>>> frame.st_
<function st_ at 0x103183d30>
>>> sked.st
<function st_ at 0x103183d30>
>>> st()

Nothing prints in command area

>>> st
<function st at 0x1030931f0>
>>> frame._st
<function st at 0x1030931f0>
>>> frame.st_
<function st_ at 0x103183d30>
>>> sked.st
<function st at 0x1030931f0>

that was after clr()

>>> st()
frame.py, at line 1 of 173, file frame.py, saved

dsiplay line does not update.  So everything is working.

>>> e('../doc/analogies.md')
../doc/analogies.md, 178 lines

display does not update

>>> win()

analogies.md appears in window.

>>> st()
analogies.md, at line 1 of 178, file ../doc/analogies.md, saved
>>> e('../doc/modules.md')
../doc/modules.md, 103 lines
>>> st()
modules.md, at line 1 of 103, file ../doc/modules.md, saved

Now it doesn't update in window - it's working as intended.
What changed?

>>> e
<function e at 0x103093430>
>>> sked.e
<function e at 0x103093430>
>>> frame._e
<function e at 0x103093430>
>>> frame.e_
<function e_ at 0x103183dc0>
>>> st
<function st at 0x1030931f0>
>>> sked.st
<function st at 0x1030931f0>
>>> frame.st_
<function st_ at 0x103183d30>
>>> frame._e
<function e at 0x103093430>
>>> frame._st
<function st at 0x1030931f0>

>>> win()

updates with modules.md

>>> e('../directories.md')
../directories.md, 28 lines

Now status line updates but window does not.

Let's just leave this issue for now and just do from sked import *
as needed to make it work.

Next factor out refresh() so we can update window after edits.
refresh() does not change buftop, we need another function to 
call like b() that can assign buftop.

10 Mar 2023

Jonathans-MBP:editors jon$ git commit -am 'frame: fix update_lines, put_marker'
[patch a879f76] frame: fix update_lines, put_marker
 1 file changed, 2 insertions(+), 2 deletions(-)
Jonathans-MBP:editors jon$ git push
...

Did e('...') ever update the display without 'from ed import *' after win() ?

we added update_lines on Feb 26, commit da9cf.  Look at above notes starting
Feb 26.

In 1 Mar at L2648 "e didn't update window, eW did. ...
do we have to 'from sked import *' again?"  Yes, we did do that and then
window updates.  At L2770:

"Test - it all works, BUT we have to 'from sked import *' after win() so e()
works properly, updates window.   Right, we have to pull patched e into top
level so we get that version when we type e().  Likewise, after clr(), e()
displays at top of screen until we do from sked import *.   But then, after
that, we can switch back and forth and it works.   Maybe we just have to
go through a cycle to assign frame _e and frame _st with the current sked 
versions?  I'm not sure I understand this ...
"

Isn't that what we found last night also?

Yes, at 3658 last night we found we had to 'from sked import *' to get 
e(...) to update screen after win().

Last night we concluded:
"Let's just leave this issue for now and just do from sked import *
as needed to make it work."

Jonathans-MBP:editors jon$ git commit -am 'add editors/test/lines40.txt'
[patch ded55c8] add editors/test/lines40.txt
 1 file changed, 40 insertions(+)
 create mode 100644 editors/test/lines40.txt
Jonathans-MBP:editors jon$ git push
...

Later - add refresh() and recenter() - they work, except marker shows
character from the wrong line.  I have been doing l() then refresh() or
recenter() - marker show character from the wrong line.

What if we just use put_marker directly?
That doesn't work - because it doesn't put cursor back in command region. Ugh.
BUT then refresh() fixes it!

Oh, If I move cursor with p(nn), then refresh(), marker shows the correct 
character.  So it's a problem with l() not put_marker() or refresh().

Next code frame.move_dot_.   Now marker is correct, when we advance with l().
We can go one line too far off the bottom before it calls recenter. v() and
rv() also work - we should figure out the correct page size from wlines.
Right now we have wlines 20 and pagesize 18 - that works well, give a line
- it retains a line at the top or bottom, for continuity.

While in win mode, did some edits to fix move_dot at bottom of window.
Then w() the buffer, reload(frame), from frame input *.  Then type l()
to move marker nearer the bottom of the window.  Crash!

 Traceback (most recent call last): wlines - 2:
  File "<stdin>", line 1, in <module>ite_bg)
  File "/Users/jon/Piety/editors/sked.py", line 210, in l
    p(dot+1)
  File "/Users/jon/Piety/editors/sked.py", line 206, in p
    move_dot(end) 100 of 187, file frame.py, saved                              
  File "/Users/jon/Piety/editors/frame.py", line 99, in move_dot_
    _move_dot(iline)
  [Previous line repeated 987 more times]
  File "/Users/jon/Piety/editors/frame.py", line 98, in move_dot_
    put_marker(ed.dot, display.clear)
  File "/Users/jon/Piety/editors/frame.py", line 61, in put_marker
    display.put_cursor(winline, 1)
  File "/Users/jon/Piety/vt_terminal/display.py", line 105, in put_cursor
    putstr(cup % (line, column))
  File "/Users/jon/Piety/vt_terminal/display.py", line 20, in putstr
    print(s, end='', flush=True, file=tty)
RecursionError: maximum recursion depth exceeded while calling a Python object

What happened?   How can I recover?   Display is messed up with traceback,
can we restore it with refresh()?

Yes!  Now screen looks right and it didn't crash!  Note we could examine
traceback, we just got back to >>> prompt, then we resume.  Try l() again.
As expected, we get another crash with exactly the same traceback.
Traceback says we have infinite recursion in _move_dot(iline).  

>>> ed.move_dot
<function move_dot_ at 0x103184a60>
>>> frame._move_dot
<function move_dot_ at 0x103184a60>
>>> frame.move_dot_
<function move_dot_ at 0x103183dc0>
>>> move_dot
<function move_dot at 0x103088e50>

>>> ed.st
<function st_ at 0x103184940>
>>> frame._st
<function st_ at 0x103184940>
>>> frame.st_
<function st_ at 0x103184670>
>>> st
<function st at 0x1030931f0>

But >>> st() does not update status line.  BUT it doesn'tmake infinte recursion
either.
Let's just restart python.
That works - now l() etc work without crash, infinite recursion.

Jonathans-MBP:editors jon$ git commit -am 'frame: add refresh, recenter; move_dot_ updates display'
[patch bd8e679] frame: add refresh, recenter; move_dot_ updates display
 1 file changed, 18 insertions(+), 1 deletion(-)
Jonathans-MBP:editors jon$ git push
...

What next?  We have all the file viewer functions working.   Start editing
functinos with the easiest - c(hange) which just changes one line without 
adding/deleting any.  Oh, but c() *might* change many in the whole buffer.

First we could add some conveniences - win() should derive wlines from the 
term window size, pagesize should be wlines-1 or -2.  Then we need a cmd
to change window size, wlines and pagesize.

When win() runs, with possible wlines arg or default, pagesize should be 
wlines-2.   Ditto when we change wlines.

Done.  Also see how to organize better.  New open() and close() call 
enable_display, disable_display.   Then win can resize and recenter window,
open calls win.  clr dismisses window, close can call clr.   win and clr
move up to the display section, much smaller open and close stay down 
at the bottom with enable/disable_display.

BUT I getting disenchaned with the whole patch scheme.  It is unobvious - it
uses Python patching magic, which requires the ugly _<name> and <name>_ 
naming, and is fragile - you have to make sure you alternate 
enable/disable display, if you enable twice in a row I think it breaks
everything.   And it requires all this dynamic patch/unpatch in a session
every time you enable/disable the display.  So it complicates execution.

I now think the wrapper scheme is better - it is clearer, uses no magic, and
is more robust.  It is completely static - everything is expressed in the
definitions of the wrapped functions.  frame.e just calls sked.e - they have
distinct names so you can call either at any time without preliminaries.
The distinct names are due to module prefixes.  So there is no dynamics and
no requirement that functions get called in the right order.   The only
dynamics are, you can use the short forms of the fcn names without prefix
by 'from frame import *' to enable graphics - so e means frame.e - and
'from sked import *' to disable graphics - so e means sked.e.  BUT you 
are not assigning/reassigning/patching fcns in frame and sked at all.

The wrapper scheme might be more code because we now need a separate wrapper
for every sked function that calls move_dot or restore_buffer rather than
just patching those two functions in sked.  And so on.  BUT it's not that much
more code.  And the code is simple and obvious.   And, maybe it's not more
code -- because we can also *get rid* of enable_display, disable_display,
open, and close, and the initializations of the all _<name> -- all tricky
nonobvious code. 

Oh, we can't all it open because that's a built-in function.  Right, files.

The only wrinkle is suppressing printline when the display is active - 
that might require a patch, boo, hiss.   Oh, how about just having the
command function in sked wrap the inner function with printing, also in sked.
As well as the function that does the other work.   Then the function in 
frame wraps the function that does the work, and adds the display code.
So the display code in frame and the print code in sked are used the same way.
That requires rewriting some code in sked, where the motivation to the
reader of only sked will look non-obvioud.  So that's a bit of a wart.

So, how to manage the code?  We have working in the patch branch off the
ed branch, and we also started a wrap branch off the ed branch.  I think
we should reach some stopping point in the patch branch, merge the code back
into ed, delete the old wrap branch, then make a new wrap branch from ed.

Or, can we just merge the present patch branch into the wrap branch?
Will there be conflicts?  If so, we can just abandon that merge and proceed
as in prev paragraph.

Check out the wrap branch in a new Piety.wrap directory and look at git log -
did we add/change any code there?  Or see these notes above.

s(...) can't find any mention of the wrap branch above.  I believe we didn't
do any work on it.
s('git branch') only finds early experiments with rewrite branch - 
no mention of wrap or patch branches.

Jonathans-MBP:~ jon$ git clone jon-jacky.github.com/Piety Piety.wrap
fatal: repository 'jon-jacky.github.com/Piety' does not exist
Jonathans-MBP:~ jon$ git clone https://github.com/jon-jacky/Piety Piety.wrap
Cloning into 'Piety.wrap'...
remote: Enumerating objects: 8035, done.
remote: Counting objects: 100% (1071/1071), done.
remote: Compressing objects: 100% (360/360), done.
remote: Total 8035 (delta 741), reused 1039 (delta 710), pack-reused 6964
Receiving objects: 100% (8035/8035), 1.78 MiB | 0 bytes/s, done.
Resolving deltas: 100% (5504/5504), done.
Checking connectivity... done.
Jonathans-MBP:~ jon$ cd Piety.wrap
Jonathans-MBP:Piety.wrap jon$ git branch
* master
Jonathans-MBP:Piety.wrap jon$ git checkout wrap
Branch wrap set up to track remote branch wrap from origin.
Switched to a new branch 'wrap'
Jonathans-MBP:Piety.wrap jon$ git branch
  master
* wrap
Jonathans-MBP:Piety.wrap jon$ cd editors
Jonathans-MBP:editors jon$ ls
README.mdfred.pyfredinit.pysked.pyskedinit.py
Jonathans-MBP:editors jon$ git log fred.py
commit bc48feb87b255d92fc9ef70f07038607ba79205d
Author: Jon Jacky <jon@u.washington.edu>
Date:   Wed Feb 22 10:37:26 2023 -0800

    fred: add display wrappers for sked v and rv

commit 1fab09ccf08d1c7c4e52c27b62efafa7a1072d92
Author: Jon Jacky <jon@u.washington.edu>
Date:   Tue Feb 21 19:34:25 2023 -0800

    fred.py: add fr(), cl() fcns to create, clear frame
    display.py: add erase_above(), used by fr()
    fredinit: add variables needed by fred
    sked.py: revise comments to look better in help

commit adfab3938f3966bc0bd77cdefcff78997a76f604
Author: Jon Jacky <jon@u.washington.edu>
Date:   Mon Feb 20 09:51:36 2023 -0800

    sked: fix a(ppend) so it can add text at start of buffer
    fix tail() so it works when buffer shorter than pagesize
    start display editor, add fred.py and fredinit.py, mention in README.md

So I did do some work in the wrap branch.  I started frame and calle it
fred, ugh.   I wrote wrappers for v() and rv() that just updated status line.
They were verbose and ugly - that's why I switched to patch scheme.  But
I think I could do better now.  But let's *not* merge present patch into wrap.
Merge patch into ed, then start new wrappers branch - with a new name.

In the wrappers version, we *can't* patch sked.printline.   That would 
require enable/disable_display calls just for that one patch.
So that's out.   I think the solution is, in sked, just replace printline
with print.  It doesn't matter if st(atus) or s(earch) prints when the
display is enabled.  The only problem is p().   We can just write a 
whole different version in frame - it's clearer and easier than messing
with wrappers.  Oh, but there are several sked functions that call p(),
wrapping them is not so easy - patching p is much nicer.  So it isn't clear
that wrapping is better than patching after all.

Another problem with wrapping is the several functions that just return
if error checks fail.  Wrapper would have to know whether fcn succeeded 
or not.  So we can't just return, we have to return something - return False.
BUT then we have to return True in the success case.  Another complication.

So press on with patching for now.

We can enforce order by adding a 'displaying' variable - both wopen
and wclose check displaying and can exit with error message before doing
anything.

Yes, wrappers option does uglify sked some.  Let's keep patches for now,
just contain them and make them more robust.

Another option for handling printline is to put displaying var in sked, then
printline is  if not displaying: print(...).   Then win() and clr() could
assign ed.displaying True and False.   That doesn't uglify sked much.

The error status returns are worse.  Also noisy - then REPL will print return
value.  Hey, maybe instead of printing message, sked fcns could return the
message - which would appear in REPL, and then frame wrappers could test 
the return string.

12 Mar 2023

Other options for dealing with short-circuit error returns in sked commands,
without returning any status:

1. wrapper in frame tests some sked state variable to see if command succeeded

2. wrapper in frame runs but doesn't change display if sked command failed:
  it could 'advance' dot to the same position, update a range of zero lines etc.

I like option 2, combined with 'if displaying: print(...)" in sked printline.

But for now, back to patching.

Jonathans-MBP:editors jon$ git commit -am 'frame: new wopen and wclose call win,clear, enable/disable_display'
[patch 2d461ba] frame: new wopen and wclose call win,clear, enable/disable_display
 2 files changed, 51 insertions(+), 31 deletions(-)
Jonathans-MBP:editors jon$ git push
...

Now try wrapping sked a().   Factor out the line buffer[...] = ...
into a function append_line(iline, line) so we can wrap it in frame.
Note that this is called for *every line* while in append mode - just 
wrapping a() won't work.  I think this is why we decided to patch not wrap.

14 Mar 2023

In sked a(), we realized we can't factor out buffer[...] = ...  because
the display code needs to run *after* the move_dot() call after updating 
the buffer.  So we defined a placeholder append_line function that has
no body in sked, and called it after that move_dot.  We fill in frame
move_dot_() with the display code.

It's clear that just wrapping the sked functions in frame won't work - we
need to replace small fragments of code *within the bodies* of the sked
command functions.   The way to do this that results in the least uglification
of the sked code is to patch those functions as we have already done with
move_dot, restore_buffer etc.   An alternative, which should work in more
static languages than Python, would be to pass fuctions as arguments to the
sked command functions, and then call those functions in the bodies of the
command functions.   Then frame could define functions that wrap the sked 
command functions, but pass different function arguments that update the
display.   This would avoid the dynamic patching and un-patching of the 
sked functions, but would uglify the sked functions by adding those function
arguments.  Also, this still doesn't solve the short-circuit error returns 
in the sked command functions - that would require a different solution, to
rewrite the sked functions so they only have a single return statement at the
end.  But that complicates the sked command functions -- more uglification.

No - the short circuit error returns are *not* a problem with this scheme!
The placeholder functions occur *within* the sked command function control
structures - the display code does *not* wrap around the entire command
function.   So the error returns are not a problem at all.

This function parameter scheme is not bad at all!  It's not very ugly.
We must call the placeholder functions in the command function bodies - but
we need to do that with the patch scheme as well.   The only additional 
think we have to put in the sked command functions are the additional 
parameters in the command function parameter lists.   But that's not too
ugly.   And frame will be appreciably simpler than with patching.
No weird _<name> or <name>_ function names, no enable/disable_display
function calls with required calling order.  

What's really important is, the function parameter scheme is entirely static.
Everything is expressed in the function definitions.  We don't need to be
patching then re-patching.

We should get the present patch branch to some state of completion,
merge it back into ed, then make a new fparams branch to try the 
function parameters scheme.

What went wrong on the master branch?  What made it such a complicated mess?
I think I made these bad decisions/wrong turns early on:

1. I wrote a command interpreter first, then wrote functions to fit.  
This time I started with the functions and haven't written a CLI yet.
Haven't missed it.  It puts the emphasis where it belongs - wriring 
clear, simple functions.

2. I tried to support taskging right away, so I needed a non-blocking 
reader for input.  I focused on that and made the Console mess.  I 
should have deferred tasking and non-blocking input, fit it in after the
core is already running as we want.   

3. I used classes and objects for ... almost everything: buffers, windows,
input reader.   This guarantees that you can't keep developing within the 
same Python session - it forces you to restart after each change to a class.
So you can't have live programming, you can't have a responsive system.

This time we're doing it right:

1.  Write the functions first, and run the program from the Python REPL as
the only CLI.  Later we can write different CLIs for the same functions if
we want.

2.  Defer tasking and non-blocking input.  Later we can write a non-blocking
editline() to replace built in input() with readline(), without all the 
other baggage we included in Console.  

3.  Don't use objects and classes.  Use functions and built in collection
data types - tuples, lists, dicts - for everything.  They are all we need.
We can revise and reload them again and again in the same Python session.

More we did wrong:

4. We took a traditional view of applications and jobs.  So we had to 
suspend and resume applications, put jobs in the background and bring them
back, etc.  This all resulted in even more complications in the Console class.

But now - 

4. There are no applications or jobs.  There are just functions. Any function
can be used ad lib.  All functions and data are all always available in the
long-running session.

Summary: I introduced too much complicated and unnecessary stuff too early.
This time I focus on starting with a simple core and keeping the programming
environment as responsive as it can be.

15 Mar 2023

BUT the earlier work accomplished a lot.  Notably, a programming 
environment written with non-blocking CLIs, including the Python REPL
itself, so you could edit and run Python code while other Python code
was running.  That might be unique in an all-Python system - it didn't use
OS level concurrency at all.

It would be a lot of work and probably quite a bit of code to restore that
to our present system.   This time, let's see what Micro Python can do before
we re-introduce tasking and non-blocking input.

18 Mar 2023

Back to sked and frame.  In sked, we added placeholder append_line() which
is a do-nothing in sked a() function.   Let's back that out and instead
in sked a() *replace* second move_dot after buffer[...]... with 
append_move_dot, which in sked is just append_move_dot = move_dot
but in frame includes the rest of the display code as well.  So we
don't need a do-nothing placeholder.

Done in sked.  Now in frame replace all the append_line with 
append_move_dot

>>> b('frame.py')
>>> rv()
>>> grep('append_line')
158 _append_line = ed.append_line
160 def append_line_(iline):
166     _append_line(iline) # This is a placeholder function that does nothing
187     ed.append_line = append_line_
196     ed.append_line = _append_line

then

>>> b()
>>> s('def c(')
>>> c('append_line','append_move_dot',158,196)
>>> grep('append_move_dot')
297 append_move_dot = move_dot
320             append_move_dot(dot+1)

argh, see b(), I'm in sked not frame.  BUT it doesn't matter because there
is no more append_line, and grep shows the changes we just made by hand.

>>> c('append_line','append_move_dot',158,196)
>>> grep('append_line')
? 'append_line' not found
>>> grep('append_move_dot')
158 _append_move_dot = ed.append_move_dot
160 def append_move_dot_(iline):
166     _append_move_dot(iline) # This is a placeholder function that does nothing
187     ed.append_move_dot = append_move_dot_
196     ed.append_move_dot = _append_move_dot

c(...) didn't print out the changed lines as it went, maybe because
display is active?  That's not right.  Yes, c() calls p(...), it should
just call print(), then move_dot()

Now test it - reload sked, frame etc.

>>> e('new.txt')
new.txt, 0 lines
>>> a()
? line 1 out of range 1 .. 0
>>> a(0)

That works but

>>> a(0)
line 1
line 2
line 3
line 4
line 5
line 6
line 7
line 8
line 9
line 10
line 11
line 12
line 13

Only line 2 appears in window, not line 1

We did win(1) before this so window has 10 lines including status line.
line 2 - line 10 appear in window as they should, but typing line 11 does
not scroll the window up, nore does 12, 13.  Instead cursor is put *below*
the status line, in the command region, though nothing prints there.
That is, we see the marker but not the text lines below the status line.

So we have two problems:
1. Starting to append lines in an empty file
2. Reaching the bottom of the window

Also, it's annoying that win(10) after 24 line window draws the shrunk
window correctly but the remains of the old window including the status
line remain on the screen - you have to manually type RET in command region
to scroll them away.  win() should clear away the lines in the old window if
there are any that remain.

Then win(24) again displays line 1 .. 13 correctly and a(), line 14, ... 16
work correctly.  

>>> r('line 9')
>>> a()
line 9a
line 9b
line 9c

Here line 9a *replaces* line 9 in window, but then 9b 9c are appended 
under 9a, and the lines below are pushed down as they should be. Then
refresh() redraws the screen with both 9 and 9a in the correct places.
This might be related to the line 2 problem above, where line 1 does not
appear when we a() into an empty file, but line 2 does.

First fix the empty buffer problem.

>>> e('new.txt')
new.txt, 0 lines
>>> sked.dot
1
>>> sked.S()
0
>>> sked.buffer
['\n']

I think the fix is to make dot 0 when we load empty file.
in sked e():

-    move_dot(1) # start of buffer, *not* end
+    move_dot(min(S(),1)) # start of buffer, empty buffer S() is 0

Before testing this, try fixing the other problems.  Next: first line problem.

It looks like when we open window on empty buffer, locate_segment sets buftop 1
-    move_dot(1) # start of buffer, *not* end
+    move_dot(min(S(),1)) # start of buffer, empty buffer S() is 0
so put + 1 in this statement:

    wstart = ed.dot - buftop + 1 # dot line in window

I think ed.dot = iline should be followed by locate_segment.
Done.  Now test.  Loading new file and starting with empty buffer works.
Appening the first several lines works.  But then when we reach next to last
line in window, lines just overwrite that position, page does not scroll
up, new lines getting added.
Yes, I think we need to refresh() after locate_segment becuase update_segment
only updates the buttom of the screen.  Yes, we want to call recenter not
just locate_segment.   Done, test.  It works!

Jonathans-MBP:editors jon$ git commit -am 'sked, frame: a() display with new append_move_dot'
[patch 91385de] sked, frame: a() display with new append_move_dot
 2 files changed, 31 insertions(+), 6 deletions(-)
Jonathans-MBP:editors jon$ git push
...

Jonathans-MBP:editors jon$ git commit -am 'frame, append_move_dot: tweak comments and formatting'
[patch ec17dd2] frame, append_move_dot: tweak comments and formatting
 1 file changed, 3 insertions(+), 2 deletions(-)
Jonathans-MBP:editors jon$ git push
...

Later we will revise a() so we type the new lines right in the window.
But first, display d() y() c().   Also, w() should update status line.

19 Mar 2023

Now display d().  

Aside - we notice e(...) doesn't update display, we get blank display,
have to refres() to fill display.  I recall figuring this out above, some
thing to do with wrapping e unlike how we patch all the other fcns.
Didn't we have to 'from frame import *' after each wopen to work around this?

That's all the more reason to switch from patch scheme to function params.
Also, while testing a() display, twice we got the infinite recursion traceback
and had to restart Python.  So this patch scheme is very fragile, do better.

Back to d() display.   The core of d() is just:

    yank = buffer[start:end+1] # range includes end, unlike Python slices
    buffer[start:end+1] = [] 
    move_dot(start-1)

Can we use our *same* append_move_dot for this?  All we are really doing
is updating all the lines in the window below dot, right?
I think so.  Let's try it.  We'll have to change the name but for now:

     buffer[start:end+1] = [] 
-    move_dot(start-1)
+    append_move_dot(start-1)

Try it.  It works perfectly!  Including on multiple lines remote from dot!
So we need to rename append_move_dot - for now move_dot_etc - and we need
to revise its comment header to explain what it actually does.

>>> c('append_move_dot','move_dot_etc',1,S())
move_dot_etc = move_dot
            move_dot_etc(dot+1)
    move_dot_etc(start-1)
>>> grep('move_dot_etc')
298 move_dot_etc = move_dot
321             move_dot_etc(dot+1)
338     move_dot_etc(start-1)
>>> grep('append_move_dot')
? 'append_move_dot' not found

Tjat
That's in sked.  Now in frame:

>>> b('frame.py')
>>> p(1)
>>> c('append_move_dot','move_dot_etc',1,S())
_move_dot_etc = ed.move_dot_etc
def move_dot_etc_(iline):
    ed.dot = iline # this is all ed.move_dot_etc does
    ed.move_dot_etc = move_dot_etc_
    ed.move_dot_etc = _move_dot_etc

onathans-MBP:editors jon$ git commit -am 'sked: move_dot_etc replaces append_move_dot in a()
> tweak comment block at the top about initializing global variables'
[patch aa4794b] sked: move_dot_etc replaces append_move_dot in a() tweak comment block at the top about initializing global variables
 2 files changed, 15 insertions(+), 14 deletions(-)
Jonathans-MBP:editors jon$ git push
...

But then, return to sked.py, rename move_dot_etc to move_dot_ad (append/delete)
and add move_dot_y (yank) and move_dot_c (change).

Isn't the only difference between move_dot_ad and _y that in _ad iline


In move_dot_ad we assume there is only one appended line and that line
becomes dot.  Then we update display with that one appended line and
all the (old) lines which follow (which get pushed down).

When we use move_dot_ad to delete, dot gets moved to the last line preceding
the deletes - but then we update that line (redundantly) and the lines
following.  We really do not have to update that new dot because it was
already on the screen.

Now move_dot_y we want to update from the line after iline all to the
bottom of the window.   We want to put dot at the last yanked line, the
last line from the yank buffer.

In all three cases the lines are already in the buffer and we know the new dot.
We should separate out updating the lines and locating and marking dot.

In the _ad append one line case dot is the first of the updated lines.

In the _ad delete case dot is the the last line preceding the updated lines.

In the _y case dot is the last appended line, which is somewhere in the 
middle of the updated lines.  Note that the _ad append case is a special
case of this, where this is just one appended line, which is also the 
first updated line and the last appended line.

How about revising move_dot_etc(iline) - iline is really the dot argument,
just call it that, then there is a separate iline arg, which can be different.

Then move_dot_a, _d, _y  will all call _etc with different args.  

Rename move_dot_etc to update_window - it does update segment, marker, status.
Then move_dot_a, _d, _y will all call update_window with different args.

We have update_window(new_dot, bstart): ...
            ... 
            ed.dot = new_dot
            ...
                 wstart = bstart - buftop + 1
                 ...

That's it! We no longer need bstart = ed.dot because that isn't always true.

23 Mar 2023

Somehow y() is already updating on the display -- !?
But then a bit later it isn't -- !?  Just continue with planned revs.

Later - got y() running without crash, moves marker and dot, but lines
from yank do not appear on display and dot is advanced too far, advanced
*from* end of yanked lines, not to the last yanked line.

...
line 10
line 10
line 12
...

s('10')
d(o(),o()+5)

Now it shows 

...
line 9
line 16
...

y()

Now it shows 

..
line 9
...
line 16
...
line 20
line 21
line 16
...
line 20
line 21
line 22
...

marker is at *second* line 21

Bah, this is confusing.  Let's try another test.

>>> e('test/lines40.txt')
test/lines40.txt, 40 lines
>>> refresh()
>>> s('5')
>>> a()
line a
...
line e
line  6
line  7
...

>>> r(' a')
>>> d(o(),o()+4)

Now it shows

...
line 5
line 6
...

mark at line 5

>>> ed.yank
['line a\n', 'line b\n', 'line c\n', 'line d\n', 'line e\n']

>>> y()

but now it shows

...
line 5
line 6
...
line 10
line 6
...
line 9
line 10
line 11
...

marker at second line 10

>>> refresh()

Now we see

...
line 5
line a
...
line e
line 6
...
line 10
line 11 
...

It looks like move_dot_y_ printed line 6 ... line 10 where it should have 
printed line a ... line e.   It looks like the mark is the right place.

I think the problem is, we already pass iline + len(yank) to move_dot 
and so also to move_dot_y_.   That is already the correct new_dot.
Then we need to pass to that, - len(yank).  Try it.
Try the same test - after line 5 append line a ... line e then d(...) then y()
Yay, now it works.

Jonathans-MBP:editors jon$ git commit -am 'sked, frame: add display to y(ank)'
[patch e49c91a] sked, frame: add display to y(ank)
 2 files changed, 65 insertions(+), 22 deletions(-)
Jonathans-MBP:editors jon$ git push
...

Next: clean up comments and formatting, then redo naming:
In frame, move_dot_a_ --> display_a etc. In general, display_<name>.
We can leave al the names in sked the same.

Also, see if we can fix up e() so we don't wrap it, we patch 
a function it calls.
Ah, sked e() calls move_dot(...) after it loads the file, just use that.
we also have to make st() update_status.
We still haven't made frame display_c.

24 Mar 2023

We sometimes get infinite recursion traceback at b() command - that is
because frame restore_buffer_ calls ed.restore_buffer.  Also frame st_
calls ed.st and frame e_ calls ed.ed   But frame move_dot_ and all the
move_dot_x_ do *not* call ed.move_dot, so there is no possibility of 
recursion.

We see enable_display does not (re)assign _move_dot_a = ed.move_dot_a etc.

which doesn't matter if we don't redefine them after importing or reloading
frame, before we call enable_display.

Let's define move_dot_c now.

First try, doesn't quite work, inserts mark at front of line, instead of
replacing first character, so first character *duplicated* at start of
line - but that doesn't happen elsewhere - !?

Also, when subst in range of lines, it goes off-by-one and shows in wrong
order:

>>> c('line','Line',10,15)
Line 10
Line 11
Line 12
Line 13
Line 14
Line 15

But on screen it updates as

...
line  9
LLine 11
LLine 12
LLine 13
LLine 14
LLine 15
LLine 10
line 16
...


Then after refresh(), we see the intended results:

...
line  9
Line 10
Line 11
Line 12
Line 13
Line 14
Line 15
line 16
...

Let's comment out display.next_line and put_marker.
That didn't affect either problem.   I did w() - git diff sees commented out
lines - then I reload(frame) and test again.  Neither problem is affected.
I'm not sure I believe reload() was effective.  Lets exit, restart python.
Done.  c() still duplicates first char on display, even though no marker
appears.  When we use c() to change first char, changed char is duplicated,
so it's not just printing the changed line displaced by one char.
But every other line on screen prints correctly, including status line.
What could be different?
Oh, and when we refresh(), it shows that correct contents are in buffer.
What if we also comment first put_marker which clears mark?
Oh man, now it prints the changed line in the command region!
I must be confused about where the cursor placement commands are - which
display functions place the cursor.
Right, we have to put_cursor before we putstr.
Now it's doing the right thing - uncomment the put_marker calls.
I think put_marker advanced cursor, so putstr started at col 2 not 1
The fix is to have put_cursor(ed.dot, 1) after put_marker, right before putstr.

Jonathans-MBP:editors jon$ git commit -am 'frame: display sked c(hange) command'
[patch d3ab305] frame: display sked c(hange) command with new move_dot_c
 1 file changed, 9 insertions(+), 5 deletions(-)
Jonathans-MBP:editors jon$ git push
...


Now what?  Revise frame reload_buffer etc. so no more recursive calls?
Rename move_dot_c_ etc. to display_c etc?  That is, what do we need to do
before merging patch into ed then starting fparam branch?
Also consider: revise a() so we type new lines right into window.  
Oh, but won't that be easier in fparam branch?  How complete should patch be?

Getting rid of recursive patches: e() is easy, it calls move_dot() near
the end.  Be sure to move saved = True *before* move_dot.

BUT restore_buffer doesn't have any hook.  It is called by b() and k() 
which don't have any obvious hooks either.   We could put move_dot(dot)
in restore_buffer - which does nothing, it has just assigned dot.
Or we could just have empty placeholder() or hook().  It's a naming issue.

Also, restore_buffer is not called at top level, it can't be top level 
in frame.   So we could add a hook in b() and k() *after* restore_buffer
and then in pfunctions branch we could pass the display_... fcns to 
b() and k().  

In fparams  (not pfunctions) branch, *every* command fcn in sked must 
also appear.   It's not like in patch branch where we can path move_dot
once and it is effective in every command where dot moves.   We have to
code a stub for every command function in frame, so we can pass the 
display_... functions in as parameters.

Maybe it doesn't make sense to keep working in patch branch.  Do we 
really want to duplicate/parallel the structure of the fparams branch,
or just leave it as-is and go on?

Oh, but it might not be too bad.  Let's rewrite a complete *replacement*
restore_buffer in frame that includes the graphics code, without a call
to restore_buffer in sked - it's only one line of code!
Fix frame restore_buffer right now to elimiate call to ed.restore_buffer.

Also fixed frame e and st to eliminate recursive calls.

26 Mar 2023

Tested recent changes.  Now e() loads the file and it appears, no refresh()
needed.  b() and k() switch buffers with no recursion depth crash.  c()
changes one line in place on screen, also changes several lines, updates
as it should

BUT c() does not update status line from saved to unsaved!   That reminds
me, we never put in code so w(rite) updates status line from unsaved to saved.
BUT in latest frame.py, move_dot_c_() does call update_status - !?
Ah, in sked c() saved=False *follows* move_dot_c - move it to before.

But -- now c() is *not* updating in window - !?  It was just before, and
I haven't reloaded anything.  c() is *still* updating window when displaying
buffer lines40.txt.  Try k() in sked.py then e('sked.py').  c() still doesn
t work in sked.  Next, wclose, wopen.  That doesn't help either.  
Now wclose, reload sked, reload frame etc. wopen. etc.  Still doesn't help - 
c still works in lines40.txt, doesn't work in sked.py.  BUT status line
does show 'unsaved changes' after c.   Also, refresh() shows expected change.
So sked c() works but frame move_dot_c() does not always work.
This is just bizarre - why would it work in one buffer but not another?
I edit in already-loaded scratch.txt - c() works.  then e('README.md')
c() works.  Then e('../vt_terminal/display.py') c() *doesn't* work - 
has it got something against .py files -- !?  Am I doing something else
differently?   I copied and appended the *same line* from frame.py to 
README.md and did the *same* c() command to the same line in both buffers - 
it worked it README.md and did not work in frame.py.  This is baffling!

Let's move on from c() problem.   To update status after w(), we 
could just replce the print() at the end of w() with s() - but the 
I mean st() not s() - but the wording is not as good.   We could turn
saved = True into set_saved(True) analogous to move_dot.  Does saved = ...
appear anywhere else?  In e(), w(), a(), y(), c().  All already have 
display code with update_status except w().  Also, in y(), saved = False
*follows* move_dot_y - move it before right now.
ditto in d()
ditto in a().  Fix a, d, y now.  Still haven't fixed w.

Another matter: this evening:

Jonathans-MBP:home jon$ python3 diary2md.py < design.txt > design.md
Jonathans-MBP:home jon$ git commit -am 'design: add KIOSK'
[gh-pages 30b7f9b] design: add KIOSK
 2 files changed, 14 insertions(+)
Jonathans-MBP:home jon$ git push
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!
Someone could be eavesdropping on you right now (man-in-the-middle attack)!
It is also possible that a host key has just been changed.
The fingerprint for the RSA key sent by the remote host is
SHA256:uNiVztksCsDhcc0u9e8BujQXVUpKZIDTMczCvj3tD2s.
Please contact your system administrator.
Add correct host key in /Users/jon/.ssh/known_hosts to get rid of this message.
Offending RSA key in /Users/jon/.ssh/known_hosts:1
RSA host key for github.com has changed and you have requested strict checking.
Host key verification failed.
fatal: Could not read from remote repository.

Google: github host key change.  First hit:

https://github.blog/2023-03-23-we-updated-our-rsa-ssh-host-key/

It describes the above message and gives directions for fix:

Jonathans-MBP:~ jon$ cd .ssh
Jonathans-MBP:.ssh jon$ grep -i github known_hosts 
github.com,207.97.227.239 ssh-rsa AAAAB3NzaC1yc...

Jonathans-MBP:.ssh jon$ ssh-keygen -R github.com
# Host github.com found: line 1
/Users/jon/.ssh/known_hosts updated.
Original contents retained as /Users/jon/.ssh/known_hosts.old

Jonathans-MBP:.ssh jon$ grep -i github known_hosts 
(nothing)

Jonathans-MBP:.ssh jon$ ssh-keygen -R github.com
Host github.com not found in /Users/jon/.ssh/known_hosts

Oh, I think I misinterpreted the directions.  Do this:


Jonathans-MBP:.ssh jon$ wc known_hosts
      44     132   15740 known_hosts

Jonathans-MBP:.ssh jon$ cat >> known_hosts
github.com ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQCj7ndNxQowgcQnjshcLrqPEiiph
Jonathans-MBP:.ssh jon$ 
Jonathans-MBP:.ssh jon$ wc known_hosts
      45     135   15817 known_hosts

Jonathans-MBP:home jon$ git push
The authenticity of host 'github.com (192.30.255.112)' can't be established.
ECDSA key fingerprint is SHA256:p2QAMXNIC1TJYWeIOttrVc98/R1BUFWu3/LiyKgUfQM.
Are you sure you want to continue connecting (yes/no)? yes
Warning: Permanently added 'github.com' (ECDSA) to the list of known hosts.
Warning: the ECDSA host key for 'github.com' differs from the key for the IP address '192.30.255.112'
Offending key for IP in /Users/jon/.ssh/known_hosts:29
Are you sure you want to continue connecting (yes/no)? yes
Saving password to keychain failed
Identity added: /Users/jon/.ssh/id_rsa ((null))
Counting objects: 4, done.
Delta compression using up to 4 threads.
Compressing objects: 100% (4/4), done.
Writing objects: 100% (4/4), 754 bytes | 0 bytes/s, done.
Total 4 (delta 3), reused 0 (delta 0)
remote: Resolving deltas: 100% (3/3), completed with 3 local objects.
To git@github.com:jon-jacky/home.git
   038431d..30b7f9b  gh-pages -> gh-pages


That was not the fingerprint in the github directions, but I proceed anyway.
The newly revised design.md is at github.

30 Mar 2023

Consider how to get w() to update status line when displaying.

Review ed printline/frame skip.   We already revised frame st() to just
call update_status, simply replaces ed.st so ed.st() doesn't need printline.

But ed.p() does use printline and it really should use print or skip.
ed.s() also uses printline - yeah, that's okay.  ed.grep() just uses print.
p() is also called by l(), rl(), v(), rv(), tail().   In all those cases
it should use printline/skip.  So we need to keep printline/skip.

Use the set_saved() solution described at L4768.  Done.

IN frame we added this comment line to enable_display:

    # Reassign all _<name> = ed.<name> because ed may have been reloaded

But is that necessary?  Let's try an experiment.

31 Mar 2023

Our experiment:

"""
reload_test.py - when we edit and reload a function, does its address change?
"""
 
def f1():
    print('This is the first version of function f1')

That's the file.  Now run it:

>>> import reload_test
>>> reload_test.f1()
This is the first version of function f1
>>> reload_test.f1
<function f1 at 0x1083891f0>

Now edit

>>> c('first','*second*')
    print('This is the *second* version of function f1')

(this updated on screen like it should)

>>> reload(reload_test)
<module 'reload_test' from '/Users/jon/Piety/editors/test/reload_test.py'>

(after w())

>>> reload_test.f1()
This is the *second* version of function f1
>>> reload_test.f1
<function f1 at 0x1083891f0>

So we reloaded it but it is still at the *same* address.
The *same* name at the *same* address is pointing to different code.

>>> from reload_test import *
>>> f1()
This is the *second* version of function f1

>>> c('*second*','*third*')
    print('This is the *third* version of function f1')

Window updated but this appeared on line after '*second*' - fix w/ refresh()

>>> w()
test/reload_test.py, 7 lines
>>> reload(reload_test)
<module 'reload_test' from '/Users/jon/Piety/editors/test/reload_test.py'>
>>> from reload_test import *
>>> reload_test.f1()
This is the *third* version of function f1
>>> reload_test.f1
<function f1 at 0x108389160>
>>> f1()
This is the *third* version of function f1
>>> f1
<function f1 at 0x108389160>

But now the address *did* change -- it didn't after first -> *second*.
So in enable_display we better reassign all the _<name> = ed.<name>
since edit and reload might change them.

>>> _f1 = reload_test.f1
>>> _f1()
This is the *third* version of function f1
>>> c('*third*','*fourth*')
    print('This is the *fourth* version of function f1')
>>> w()
test/reload_test.py, 7 lines
>>> reload(reload_test)
<module 'reload_test' from '/Users/jon/Piety/editors/test/reload_test.py'>
>>> reload_test.f1()
This is the *fourth* version of function f1
>>> reload_test.f1
<function f1 at 0x1083891f0>
>>> _f1()
This is the *third* version of function f1
>>> _f1
<function f1 at 0x108389160>

Those are different addresses (it re-used the first address - !?) and
they run different functions.  So we really do have to reassign all
the _<name> in enable_display.

Done.  Restart python etc.  Now test.  d() and y() and c() work in 
lines40.txt.  c('function','fcn') and back works in sked.py - in the
comment header.  Also works in a comment in the body of the code.
However, it does not work in a line of code itself:

>>> c('):','): # comment')
def range_valid(start, end): # comment
>>> range_valid(start, end): # comment

then

>>> refresh() 

makes window update

then

>>> c('): # comment','):')
def range_valid(start, end):
>>> range_valid(start, end):
>>> refresh()

Look, it echoes changed line below the command as if we are not in 
display mode - then it displays the changed line on the *next* line,
after the >>> prompt - as if it is executing the display code after
update_status with its final put_cursor(tlines, 1).

same thing on another code line

>>> c('dot','iline')
            move_iline_c(iline)
>>>         move_iline_c(iline)
>>> refresh()

Inside a block comment delimited with """ ... """:

>>> c('line','new line')
    c(hange), replace old string with new string on each new line in range.
>>> c(hange), replace old string with new string on each new line in range.
>>> refresh()

Now in a comment line beginnig with #

>>> c('der','der function')
# Placeholder function ...
>>> aceholder function ...
>>> refresh()

So that did not update in window.  Let's return to the comment header and
the ealier line and see if it works corretly.

>>> c('functions','fcns')
No main program!  Editor commands are just fcns defined here, to

Yes, it still works, change immediately visible in window.  That was the
comment header.

>>> c('functions','fcns')
# Define and initialize global variables used by sked editing fcns.

That was within # comment, first of several in a block.  Again it works here.

So this is subtle.  Sometimes it works, sometimes it doesn't, in the same
buffer.  Does it depend on the location in the buffer?  On the content of
the string in the buffer?  On the content of the c() command?

The clue seems to be that is is executing update_status before it 
substitues in the line.  Are we invoking *two* display functions that
both invoke update_status?  Is there another move_dot in c() ?

NOt sure how to proceed here.  Can't think of anything but test the other
frame <name>_ fcns.
Let's test in skedinit.py which is up-to-date in repo - so we can revert
with get checkout ...

>>> c('???','what?')
replacestring = 'what? ' # reassigned by c(hange) command
>>> c('what?','???')
replacestring = '??? ' # reassigned by c(hange) command

so c() works in a line of code in skedinit.py

e(), b(), k() work - so move_dot_e and restore_buffer work.
v(), rv(), l(), lr(), s() work - so move_dot works.
a(), d(), y() work.   Now let's test w() works - Confirm w() changes
unsaved to saved in status line.  Yes.   Then confirm edits change it to 
unsaved, then w() changes it back to saved.

>>> c('}','} # comment')
buffers = { bufname: bufstate } # comment
>>> refresh()

So that did update to unsaved in status line, but c() did not update
window until refersh().  Then w() changes status unsaved to saved. 

>>> c('} # comment','}')
buffers = { bufname: bufstate }

Did *not* update window but *did* update status from saved to unsaved.
>>> refresh()  updates window.  w() changes back to saved.

Everything works except move_dot_c_ ... sometimes.  Let's commit anyway.

Jonathans-MBP:editors jon$ git commit -am 'sked, frame: complete frame display ffunctions for all sked editing functions
> also complete and reorganize frame enable_display, disable_display
> move_dot_c_ still has elusive bug that appears sometimes - but commit anyway'
[patch 70e2c9a] sked, frame: complete frame display ffunctions for all sked editing functions also complete and reorganize frame enable_display, disable_display move_dot_c_ still has elusive bug that appears sometimes - but commit anyway
 3 files changed, 60 insertions(+), 35 deletions(-)
Jonathans-MBP:editors jon$ git push
...

Before merging patch back into ed to prepare for new fparams branch,
we might want to rename all the move_dot_a etc. to display_a etc.
amd add to each fcns doc to say 'Display effects of a(ppend) command' etc.

Okay, lets get started on the renaming:

>>> c('move_dot_','display_move_dot',1,S())
    ...

    _display_move_doty = ed.display_move_doty
    _display_move_dotc = ed.display_move_dotc
    ed.display_move_dote = display_move_dote_
    ed.display_move_dota = display_move_dota_
    ed.display_move_dotd = display_move_dotd_
    ed.display_move_doty = display_move_doty_
    ed.display_move_dotc = display_move_dotc_
    ed.display_move_dote = _display_move_dote
    ...

Oops! 

>>> k()
frame.py has unsaved changes, type y to kill anyway: y
>>> e('frame.py')
frame.py, 287 lines

Maybe change that one, one line at a time!  Do the rest:

Uh, not so sure about those name changes.  Defer that for now.
BUT let's change the comment block at the top of each function.

 1 Apr 2023

In ed c()  I moved print(...) from before move_dot_c() call to after,
last line in fcn.  BUT move_dot_c is supposed to position cursor 
correctly anyway so it seems that couldn't be the problem?  Let's just
try it.   w(), reload etc.

>>> wopen()
>>> c('even','also')
            print(buffer[iline], end='') # print also when display enabled
>>> refresh()

so we see print(...) output appeaer as intended ni command region, we
don't see output intended for window in command region, but window 
doesn't update either.   Had to refresh() to update window.  l, lr, rv
work.   Bah.

Is it updating the status and moving the marker?  Try c() in a range
where old string only appears several lines away.

>>> c('global','globalx',o(),o()+2)
    globalx _move_dot, _restore_buffer, _st,  _set_saved, _move_dot_e, \
>>> refresh()

Cursor did move two lines down to changed line, status line did chang
from 'saved' to 'unsaved changes', changed line was printed in command
area, but line in window did not change until refresh().  So buffer 
was changed but window was not updated.  Everyhting else that was supposed
to happen, did happen.

w() changes it back to saved.  Try again, starting on same line

>>> c('globalx','global',o(),o()+2)
    global _move_dot, _restore_buffer, _st,  _set_saved, _move_dot_e, \
>>> refresh()

same story - cursor moves, status line updates, changed line printed in 
command region, but must refresh() to update window consistent with buffer.

I'm running out of ideas.  We may have to restor to debugger.  Then
the debugger will be fighting with screen updates, but maybe we caqn
make some sense of it.
Can we import pdb into the running session and use it?  I doubt it.

https://stackoverflow.com/questions/66085546/how-do-i-start-pdb-and-step-into-a-function-from-the-repl

import pdb then pdb.run("....") with the call code between the quotes.
Call sked.c().  Then at pdb prompt > use s(tep) to step into code in
frame.move_dot_c_ 

 2 Apr 2023

>>> import pdb
>>> pdb.run("c('dot to','dot up to',o(),o()+5)")
> <string>(1)<module>()
(Pdb) s
--Call--
> /Users/jon/Piety/editors/sked.py(38)o()
-> def o():
-> def o():
(Pdb) n
> /Users/jon/Piety/editors/sked.py(40)o()
-> return dot
(Pdb) s
--Return--
> /Users/jon/Piety/editors/sked.py(40)o()->223
-> return dot
(Pdb) s
--Call--
> /Users/jon/Piety/editors/sked.py(38)o()
-> def o():
(Pdb) n
> /Users/jon/Piety/editors/sked.py(40)o()
-> return dot
(Pdb) s
--Return--
> /Users/jon/Piety/editors/sked.py(40)o()->223
-> return dot
(Pdb) s
--Call--
> /Users/jon/Piety/editors/sked.py(365)c()
-> def c(old=None, new=None, start=None, end=None, count=-1):
(Pdb) s
> /Users/jon/Piety/editors/sked.py(379)c()
-> if not start: start = dot
(Pdb) s
> /Users/jon/Piety/editors/sked.py(380)c()
-> if not end: end = start
(Pdb) s
> /Users/jon/Piety/editors/sked.py(381)c()
-> if not range_valid(start, end):
(Pdb) n
> /Users/jon/Piety/editors/sked.py(383)c()
-> if not old: old = searchstring
(Pdb) s
> /Users/jon/Piety/editors/sked.py(384)c()
-> searchstring = old
(Pdb) s
> /Users/jon/Piety/editors/sked.py(385)c()
-> if new is None: new = replacestring
(Pdb) s
> /Users/jon/Piety/editors/sked.py(386)c()
-> if new is not None: replacestring = new
(Pdb) s
> /Users/jon/Piety/editors/sked.py(387)c()
-> for iline in range(start, end+1): # range is not inclusive so +1
(Pdb) s
> /Users/jon/Piety/editors/sked.py(388)c()
-> if old in buffer[iline]:
(Pdb) s
> /Users/jon/Piety/editors/sked.py(387)c()
-> for iline in range(start, end+1): # range is not inclusive so +1
...

Haven't we reached that line yet?

> /Users/jon/Piety/editors/sked.py(389)c()
-> buffer[iline] = buffer[iline].replace(old, new, count)
(Pdb) s iline
> /Users/jon/Piety/editors/sked.py(390)c()
-> saved = False # put this *before* move_dot for display code
(Pdb) p iline
227
(Pdb) p old
'dot to'
(Pdb) p new
'dot up to'
(Pdb) p cont
*** NameError: name 'cont' is not defined
(Pdb) p count
-1
(Pdb) p buffer[iline]
'    Move dot up to iline, redisplay line, mark current line, update status.\n'

It made the replacement.

(Pdb) s
> /Users/jon/Piety/editors/sked.py(391)c()
-> move_dot_c(iline) # puts cursor on command line for print below
(Pdb) s
--Call--
> /Users/jon/Piety/editors/frame.py(213)move_dot_c_()
-> """

Now we enter the display function

-> All lines below the appended lines must be moved down.
(Pdb) s
--Call--
> /Users/jon/Piety/editors/frame.py(55)put_marker()
-> def put_marker(bufline, attribs):
(Pdb) n
> /Users/jon/Piety/editors/frame.py(57)put_marker()
-> line = ed.buffer[bufline] if ed.buffer and 1 <= bufline <= ed.S() else ''

We did not see old marker get cleared when we n put_markder.
Nor did we see cursor move - we're still in Pdb REPL at the bottom
of the screen.

(Pdb) p line
*** NameError: name 'line' is not defined
(Pdb) s
--Call--
> /Users/jon/Piety/editors/sked.py(42)S()
-> def S():
(Pdb) p line
*** NameError: name 'line' is not defined

? because it's a local variable - ?

> /Users/jon/Piety/editors/sked.py(42)S()
-> def S():
(Pdb) p line
*** NameError: name 'line' is not defined
(Pdb) p bufline
*** NameError: name 'bufline' is not defined
(Pdb) p ed.buffer[bufline]
*** NameError: name 'ed' is not defined

?

*** NameError: name 'ed' is not defined
(Pdb) n
> /Users/jon/Piety/editors/sked.py(44)S()
-> return len(buffer)-1  # -1 because of zero based index
(Pdb) s
--Return--
> /Users/jon/Piety/editors/sked.py(44)S()->301
-> return len(buffer)-1  # -1 because of zero based index
(Pdb) s
--Return--
> /Users/jon/Piety/editors/sked.py(44)S()->301
-> return len(buffer)-1  # -1 because of zero based index
(Pdb) s
> /Users/jon/Piety/editors/frame.py(58)put_marker()
-> ch0 = line[0] if line.rstrip('\n') else ' ' # line might be empty or RET
Pdb) n
> /Users/jon/Piety/editors/frame.py(59)put_marker()
-> winline = bufline - buftop + 1
(Pdb) s
> /Users/jon/Piety/editors/frame.py(60)put_marker()
-> if winline < 1: winline = 1
(Pdb) s
> /Users/jon/Piety/editors/frame.py(61)put_marker()
-> display.put_cursor(winline, 1)
(Pdb) s
--Call--
> /Users/jon/Piety/vt_terminal/display.py(104)put_cursor()
-> def put_cursor(line, column):      # not in emacs or gnu readline
(Pdb) n
> /Users/jon/Piety/vt_terminal/display.py(105)put_cursor()
-> putstr(cup % (line, column))
(Pdb) n

Now (Pdb) prompt appears in the widow, on the line where the mark should
be and where the replacement will be made.

(Pdb) sall to c() might call this several times, once for each changed line.
> /Users/jon/Piety/editors/frame.py(62)put_marker() line, update status.
-> display.render(ch0, attribs)
(Pdb) n_marker(ed.dot, display.clear)
d--Return--= iline
> /Users/jon/Piety/editors/frame.py(62)put_marker()->None
-> display.render(ch0, attribs).dot].rstrip('\n')[:tcols+1])
(Pdb) nplay.kill_line()
> /Users/jon/Piety/editors/frame.py(216)move_dot_c_()changes                    
-> iline here is the new dot, the last of the lines appended from yank.
(Pdb) s-
> /Users/jon/Piety/editors/frame.py(217)move_dot_c_()sor()
-> The first of the lines appended from yank is at iline - len(yank) + 1
(Pdb) s
--Call--/jon/Piety/vt_terminal/display.py(105)put_cursor()
> /Users/jon/Piety/vt_terminal/display.py(104)put_cursor()
-> def put_cursor(line, column):      # not in emacs or gnu readline

Here Pdb prompt and command mixed in with screen contents - hard to read

(Pdb) n
> /Users/jon/Piety/vt_terminal/display.py(105)put_cursor()
-> putstr(cup % (line, column))
(Pdb) n
> /Users/jon/Piety/editors/frame.py(218)move_dot_c_()
-> """

But cursor did not move that time.

> /Users/jon/Piety/vt_terminal/display.py(105)put_cursor()->None
-> putstr(cup % (line, column))d c(hange) function, replacing the changed line.
(Pdb) sall to c() might call this several times, once for each changed line.
> /Users/jon/Piety/editors/frame.py(62)put_marker() line, update status.
-> display.render(ch0, attribs)
(Pdb) n_marker(ed.dot, display.clear)
d--Return--= iline
> /Users/jon/Piety/editors/frame.py(62)put_marker()->None
-> display.render(ch0, attribs).dot].rstrip('\n')[:tcols+1])
(Pdb) nplay.kill_line()
> /Users/jon/Piety/editors/frame.py(216)move_dot_c_()changes                    
(Pdb) n
> /Users/jon/Piety/vt_terminal/display.py(20)putstr()
-> print(s, end='', flush=True, file=tty)
(Pdb) n
    Move dot up to iline, redisplay line, mark current line, update status.--Return--
> /Users/jon/Piety/vt_terminal/display.py(20)putstr()->None
-> print(s, end='', flush=True, file=tty)

This is all scrambled up - we're missing some lines - but I think
that prnts.   Move dot up   is the print to command region at the end
of move_dot_c

-> print(s, end='', flush=True, file=tty)
(Pdb) s
> /Users/jon/Piety/editors/frame.py(219)move_dot_c_()
-> update_window(iline, iline-len(ed.yank)+1)
(Pdb) n
> /Users/jon/Piety/editors/frame.py(220)move_dot_c_()
-> 

How did we get to update_window?

> /Users/jon/Piety/editors/frame.py(216)move_dot_c_()changes                    
-> 
(Pdb) s
--Call--
> /Users/jon/Piety/editors/frame.py(55)put_marker()
-> def put_marker(bufline, attribs):
(Pdb) n
> /Users/jon/Piety/editors/frame.py(57)put_marker()
-> line = ed.buffer[bufline] if ed.buffer and 1 <= bufline <= ed.S() else ''
...

Again, we're missing something.

> /Users/jon/Piety/vt_terminal/display.py(105)put_cursor()->None
-> putstr(cup % (line, column))d c(hange) function, replacing the changed line.
(Pdb) sall to c() might call this several times, once for each changed line.
> /Users/jon/Piety/editors/frame.py(62)put_marker() line, update status.
-> display.render(ch0, attribs)
(Pdb) n_marker(ed.dot, display.clear)
 --Return--= iline
> /Users/jon/Piety/editors/frame.py(62)put_marker()->None
-> display.render(ch0, attribs).dot].rstrip('\n')[:tcols+1])
(Pdb) nplay.kill_line()
frame.py, at line 227 of 301, file frame.py, unsaved changes                    
-> if winline < 1: winline = 1
(Pdb) n
> /Users/jon/Piety/editors/frame.py(61)put_marker()
-> display.put_cursor(winline, 1)
(Pdb) n
--Return--
> /Users/jon/Piety/editors/frame.py(221)move_dot_c_()->None
-> _move_dot_c = ed.move_dot_c

We see status line update

-> _move_dot_c = ed.move_dot_c
(Pdb) n
> /Users/jon/Piety/editors/sked.py(392)c()
-> print(buffer[iline], end='') # print even when display enabled
(Pdb) n
    Move dot up to iline, redisplay line, mark current line, update status.
> /Users/jon/Piety/editors/sked.py(387)c()
-> for iline in range(start, end+1): # range is not inclusive so +1

That's the line printed in the command region.
Now we're re-entering the loop to go to the next line.

This wasn't very helpful.  Maybe try breakpoints.

(Pdb) q
>>> 

Now we're out of the debuffer

>>> refresh()

Refrsh shows marker on the line in window we wanted to change, and the
change has been made: 'dot to' -> 'dot up to'.   So that debugger trace
shows what happens when it works correctly.

But -

>>> c('dot up to','dot to')
    Move dot to iline, redisplay line, mark current line, update status.
>>> refresh()

Now the change did not appear in the window, we had to refresh() - !

I wonder if we are seeing some weird interaction between our code and
the terminal - so this terminal does not always do what it's told.

Reviewing the debug log above, we notice two unexpected things:

> /Users/jon/Piety/editors/frame.py(219).move_dot_c()
-> update_window(line, line-len(ed.yank)+1)

How did we get to update_window from move_dot_c ?

-> _move_dot_c = ed.move_dot_c

How did we get to this from move_dot_c ?

frame.py(219) is the last line in move_dot_y_ , whose def precedes
def move_dot_c_.   But then the line _move_dot_c = ed.move_dot_c 
is frame.py(221) right after last line in move_dot_y_ - I really don't
get what's happening here.  Weirdness having to do with the patching?

I think the next thing to do is put a breakpoint in ed.move_dot_c
rather, breakpoint in ed c() at call to move_dot_c then n(ext) not
s(tep) through move_dot_c.   Lets try it now.  That's breakpoint at
L391 out of 392 in sked.py.

>>> pdb.run("c('dot to','dot up to',o(),o()+5)")
> <string>(1)<module>()
(Pdb) b /Users/jon/Piety/editors/sked.py:391
Breakpoint 1 at /Users/jon/Piety/editors/sked.py:391
(Pdb) c
> /Users/jon/Piety/editors/sked.py(391)c()
-> move_dot_c(iline) # puts cursor on command line for print below
(Pdb) s
--Call--
> /Users/jon/Piety/editors/frame.py(213)move_dot_c_()
-> """
-> All lines below the appended lines must be moved down.
(Pdb) s
--Call--
> /Users/jon/Piety/editors/frame.py(55)put_marker()
-> def put_marker(bufline, attribs):
(Pdb) s
> /Users/jon/Piety/editors/frame.py(57)put_marker()
-> line = ed.buffer[bufline] if ed.buffer and 1 <= bufline <= ed.S() else ''
-> line = ed.buffer[bufline] if ed.buffer and 1 <= bufline <= ed.S() else ''
(Pdb) p line
*** NameError: name 'line' is not defined
(Pdb) s
--Call--
> /Users/jon/Piety/editors/sked.py(42)S()
-> def S():
(Pdb) s
> /Users/jon/Piety/editors/sked.py(44)S()
-> return len(buffer)-1  # -1 because of zero based index
(Pdb) s
--Return--
> /Users/jon/Piety/editors/sked.py(44)S()->301
-> return len(buffer)-1  # -1 because of zero based index
(Pdb) s
> /Users/jon/Piety/editors/frame.py(58)put_marker()
-> ch0 = line[0] if line.rstrip('\n') else ' ' # line might be empty or RET
(Pdb) s
> /Users/jon/Piety/editors/frame.py(59)put_marker()
-> winline = bufline - buftop + 1

Bah, we're doing s(tep into) not n(ext)

Try again

>>> pdb.run("c('dot to','dot up to',o(),o()+5)")
> <string>(1)<module>()
(Pdb) b /Users/jon/Piety/editors/sked.py:391
Breakpoint 2 at /Users/jon/Piety/editors/sked.py:391
(Pdb) c
>>>

What?  It just exitd from debugger.  Also, I don't like that 
Breakpoint 2

>>> pdb.run("c('dot to','dot up to',o(),o()+5)")
> <string>(1)<module>()
(Pdb) cl
Clear all breaks? y
Deleted breakpoint 1 at /Users/jon/Piety/editors/sked.py:391
Deleted breakpoint 2 at /Users/jon/Piety/editors/sked.py:391
(Pdb) b /Users/jon/Piety/editors/sked.py:391
Breakpoint 3 at /Users/jon/Piety/editors/sked.py:391
(Pdb) c
>>>

Try again

...
(Pdb) cl
Clear all breaks? y
Deleted breakpoint 1 at /Users/jon/Piety/editors/sked.py:391
Deleted breakpoint 2 at /Users/jon/Piety/editors/sked.py:391
Deleted breakpoint 3 at /Users/jon/Piety/editors/sked.py:391
(Pdb) b move_dot_c
Breakpoint 4 at /Users/jon/Piety/editors/sked.py:31

Ah, that's def move_dot ...  So it appears all this patching confuses pdb.

(Pdb) p move_dot
<function move_dot at 0x10a0853a0>
(Pdb) p move_dot_c
<function move_dot at 0x10a0853a0>
(Pdb) p frame._move_dot_c
<function move_dot at 0x109f74e50>

why isn't that the same as move_dot_c -?

(Pdb) p frame.move_dot_c_
<function move_dot_c_ at 0x10a0785e0>

This is a rabbit hole.  Maybe we need to run wopen() from the debugger?  Gah.
Perhaps we could just use p, which evaluates an expression, presumably
including function calls, or new interact which runs the interpreter from
code module.

I have to say I'm stumped.  This is a strong argument for moving to the 
fparams branch now.   

Try again with pdb, breakpoint at ed c() call to move_dot_c, s in,
the n through the body of move_dot_c.

Restart python, before using pdb, wopen and confirm c() advances 
mark and updates status, that confirms we are running move_dot_c.

...
>>> wopen(16)
>>> sked.move_dot_c
<function move_dot_c_ at 0x103df5c10>
>>> sked.move_dot
<function move_dot_ at 0x103df5700>
>>> frame.move_dot_c_
<function move_dot_c_ at 0x103df5c10>

So sked.move_dot_c did get patched as intended.

In the window we have:

...
def c(old=None, new=None, start=None, end=None, count=-1):
    """
    c(hange), replace old string with new string on each line in range.
    Replace in lines start through end, default replaces in current line.
    If old is None or '', use stored searchstring
...

dot at def c, marker is there.  Status line says 'saved'.

>>> c('in curr','in the curr',o(),o()+4)
    Replace in lines start through end, default replaces in the current line.

marker moves to 'Replace in' line, status line updates to 'unsaved changes'
BUT that line in window does not change until ...

>>> refresh()

Now line in window updates.  So, patched move_dot_c is in effect.

>>> w()
sked.py, 392 lines

once again status line says 'saved'

>>> rl()
>>> rl()
>>> rl()

once again dot is at 'def c'.   Where to put the breakpoint?

>>> s('move_dot_c')
>>> o()
391

>>> r('def c')

move dot back to def c

>>> import pdb
>>> pdb.run("c('in the curr','in curr',o(),o()+4)")
> <string>(1)<module>()
(Pdb) b sked.py:391
Breakpoint 1 at /Users/jon/Piety/editors/sked.py:391
(Pdb) c
> /Users/jon/Piety/editors/sked.py(391)c()
-> move_dot_c(iline) # puts cursor on command line for print below
(Pdb) s
--Call--
> /Users/jon/Piety/editors/frame.py(223)move_dot_c_()
-> def move_dot_c_(iline):
(Pdb) n
> /Users/jon/Piety/editors/frame.py(229)move_dot_c_()
-> put_marker(ed.dot, display.clear)
(Pdb) n

Now cursor moves up to window where dot is dispalayed:

d> /Users/jon/Piety/editors/frame.py(230)move_dot_c_()-1):
-> ed.dot = iline
(Pdb)

Note d> above shows cursor moved to old dot at def c
also, d is now nomral not reverse video, marker was cleared.

(Pdb) n
> /Users/jon/Piety/editors/frame.py(231)move_dot_c_()ces in the current line.
-> display.put_cursor(ed.dot, 1)ored searchstring
(Pdb) n

Then cursor jumps to bottom of terminal, outside buffer window.

> /Users/jon/Piety/editors/frame.py(232)move_dot_c_()
-> display.putstr(ed.buffer[ed.dot].rstrip('\n')[:tcols+1])
(Pdb) 
(Pdb) n
    Replace in lines start through end, default replaces in current line.> /Users/jon/Piety/editors/frame.py(233)move_dot_c_()
-> display.kill_line()

So there is the changed line, but it's written at the bottom of the terminal.

(Pdb) n
> /Users/jon/Piety/editors/frame.py(234)move_dot_c_()
-> put_marker(ed.dot, display.white_bg)
(Pdb) n

Now the cursor jumps back up into the buffer window 

 > /Users/jon/Piety/editors/frame.py(235)move_dot_c_()es in the current line.
-> update_status()sor(ed.dot, 1)ored searchstring
(Pdb) nherwise assign old to searchstring.  And we see the marker at

And we see the marker at the right line in the window.

(Pdb) n

Now status line updates with 'unsaved changes'

> /Users/jon/Piety/editors/sked.py(392)c()
-> print(buffer[iline], end='') # print even when display enabled
(Pdb) n
    Replace in lines start through end, default replaces in current line.
> /Users/jon/Piety/editors/sked.py(387)c()
-> for iline in range(start, end+1): # range is not inclusive so +1
(Pdb) 

So that prints the line in the command region as intended,
and then it goes back to the top of the loop to search lines for pattern.

The anomaly is, put_cursor(ed.dot, 1) puts the cursor at the bottom 
of the terminal.  Do I have the order of args in put_cursor right?
Look at the code in put_marker.  Ah, we forgot to switch from buffer line
to window line:

    winline = bufline - buftop + 1
    if winline < 1: winline = 1
    display.put_cursor(winline, 1)

In move_dot_c_:

    ed.dot = iline
    winline = ed.dot - buftop + 1
    if winline < 1: winline = 1
    display.put_cursor(winline, 1)
    display.putstr(...)

w(), reload(), ...  Try it.

>>> c('date st','date the st')
    Move dot to iline, redisplay line, mark current line, update the status.

The line in the window updated!  Yay!  No refresh() needed.  At last!

Jonathans-MBP:editors jon$ git commit -am 'frame: fix move_dot_c_ , add comments for the display functions
> sked: c(), print changed line in command region *after* calling move_dot_c'
[patch 7f49cd0] frame: fix move_dot_c_ , add comments for the display functions sked: c(), print changed line in command region *after* calling move_dot_c
 2 files changed, 25 insertions(+), 9 deletions(-)
Jonathans-MBP:editors jon$ git push
...


Now everything that's there works.  We might stop there and move to fparams
branch.  OR we might: 

1. Change names in frame: move_dot_c_ -> display_c etc.

2. Revise code to append in place in the window: 
   a. In sked a(), add hooks for start append and finish append.
   b. In frame, add fcns for start append and finish append.

 3 Apr 2023

0. Write wline fcn from buffer line to window line, 
   call in put_marker and move_dot_c_

3. clr() fcn erases all window contents and status line

Do 0. first.

Jonathans-MBP:editors jon$ git commit -am 'frame: add wline fcn, call in put_marker and move_dot_c'
[patch 0a4d73a] frame: add wline fcn, call in put_marker and move_dot_c
 1 file changed, 8 insertions(+), 7 deletions(-)

also

Jonathans-MBP:editors jon$ git commit -am 'sked: tweak comments for move_dot_<x>'
[patch ffb8443] sked: tweak comments for move_dot_<x>
 1 file changed, 7 insertions(+), 8 deletions(-)
Jonathans-MBP:editors jon$ git push
...

It took *days* to find and fix the trivial buffer line vs. window line bug
in frame move_dot_c_.   What can we learn?

1. Bugs which are persistent and elusive might not be subtle or deep.
This one was trivial and should have been obvious.  It is easy to overlook
the obvious.

2. When a bug is persistent and elusive, it is tempting to blame some 
obscure cause.  I thought this bug might be a problem with the terminal,
or something complicated having to do with patching display functions into
the editing functinos.  In fact it was a trivial coding error.

3. I had several clues, which I didn't appreciate.
   i.  Initially we saw the changed line being written at the 
       bottom of the terminal, in the command region.  This 
       was a clue that the problem involved calculating the line index
       for the changed line.
   ii. The bug didn't always occur.  I now see that the bug did not occur
       when I changed a line in a window that was at the top of the buffer,
       so the index of the window line was the same as the index of the 
       buffer line.  If only I had tested at a line in lines40.txt that 
       was near the end of the buffer, I might have figured it out then.

4. I finally saw the error after I stepped through the code line-by-line
with the debugger.  This was so easy I should have tried it earlier, as
soon as I felt I was stuck.  It is really easy to use Pdb ad-lib when 
we develop code and run code at the Python REPL by calling functions.
Simply 'import pdb' then 'pdb.run("... function call ...")', then seat
breakpoint if needed - o() tells you the line in the code - then step
through code with Pdb n(ext) command that doesn't step into functions.
It might even be easier to set breakpoint by naming the function to break at.

...
(Pdb) b move_dot_c
2   breakpoint   keep yes   at /Users/jon/Piety/editors/sked.py:31
(Pdb) cl
Clear all breaks? y
Deleted breakpoint 1 at /Users/jon/Piety/editors/sked.py:391
Deleted breakpoint 2 at /Users/jon/Piety/editors/sked.py:31
(Pdb) b
(Pdb) b move_dot_c_
Breakpoint 3 at /Users/jon/Piety/editors/frame.py:226

Oops, b move_dot_c put breakpoint at *unpatched* move_dot_c which is
just move_dot - sked.py:31 is def move_dot.   BUT b move_dot_c_ found
the right function, I didn't even have to qualify with module name.
Maybe that's because I did from frame import *.

(Pdb) c
> /Users/jon/Piety/editors/frame.py(232)move_dot_c_()
-> put_marker(ed.dot, display.clear)
(Pdb) n

Now cursor jumps up to that line in window - as intended.

 > /Users/jon/Piety/editors/frame.py(233)move_dot_c_() line for print below
-> ed.dot = iline(buffer[iline], end='') # print even when display enabled
 > /Users/jon/Piety/editors/frame.py(233)move_dot_c_() line for print below
-> ed.dot = iline(buffer[iline], end='') # print even when display enabled

(233) inadvertantly duplicated

> /Users/jon/Piety/editors/frame.py(234)move_dot_c_()
-> display.put_cursor(wline(ed.dot), 1)
(Pdb) n

cursor jumps back again as it should

> /Users/jon/Piety/editors/frame.py(235)move_dot_c_()) line for print below
-> display.putstr(ed.buffer[ed.dot].rstrip('\n')[:tcols+1])display enabled
(Pdb) n
-> display.kill_line()
(Pdb) n
> /Users/jon/Piety/editors/frame.py(237)move_dot_c_()
-> put_marker(ed.dot, display.white_bg)
(Pdb) n

cursor jumps again

... etc. ...
(Pdb) n
--Return--
> /Users/jon/Piety/editors/frame.py(238)move_dot_c_()->None
-> update_status()
(Pdb) n
            move_dot_c(iline) # puts cursor on the command line for print below
--Return--
> <string>(1)<module>()->None
(Pdb) q
>>> refresh()

Now window is refreshed - that's quite easy.
... so it's easy to drop in and out of the debugger during a session.
pdb.run() is just another fcn we can invoke at the REPL.

 4 Apr 2023

Jonathans-MBP:editors jon$ git commit -am 'frame, win: clear window first in case new window is smaller than old'
[patch 9a8a59a] frame, win: clear window first in case new window is smaller than old
 2 files changed, 7 insertions(+), 7 deletions(-)
Jonathans-MBP:editors jon$ git push
...

In update_lines, I think we shouldn't need to pad with empty lines 
at the bottom.  Instead, win(), refresh(), recenter() should clear
the entire window before writing any lines.  The goal is to eliminate
unnecessary commands and text sent to the terminal.   In the typical 
case where we are just appending text at the end of the buffer, it shouldn't
be necessary to send anything other than the characters typed during
successive Python input() calls.

That consideration is pertinent for revising a(ppend) to update the window
in place as we type during input().   Instead of our present move_dot_a
which pushes text down, we need an open_line fcn which doesn't push any
text down if there isn't any.

Oh, move_dot_d moves text up after we delete.  For this, we may need the 
display.kill_line code after all, even after clearing window in refresh() etc.

 5 Apr 2023

frame refresh seems to be the ur-start-over function - recenter calls it,
update_window and win call recenter.  open_frame clears above the status
line, but also limits scroll to below the status line.  win calls 
open frame then refresh, zen just calls open_frame, wopen calls win.

So the idea is, is refresh clears the window, then update_lines doesn't
need to kill the lines at the end of the window, after end of buffer,
because they are already blank.  The only case where we need to kill 
lines at the end of the window is where we delete some lines further up.
So we could handle this in just the delete code.

Remember, we are trying to optimize the case where we are appending lines
at the end of the buffer.  We don't want to uselessly kill all the lines
after the line we just appended - we want window to be clear already.

Maybe update_lines could return nelines (number of empty lines) which
we could ignore in all fcns except delete.  Sort of a hack, but simple
and effective?

 7 Apr 2023

Consider adding erase to refresh(), removing clearing empty lines from
update_lines(), then adding that only to move_dot_d_ that is, display_delete.

So, what order to do this?  I think we want to make test/lines10.txt, 
lines 30.txt in addition to lines40.txt.

Then switch from buffer that fills screen like sked.py to buffer that 
fills only top half like lines10.txt, or v() to lines20.txt.  Make sure
First, try it after we remove clear blank lines from end of update_lines - 
we should see that old lines remain.   Then add clear to refresh() - should
fix problem for everything but delete.  Then add those lines to end of 
delete.

Step 1.  Remove clearing blank lines from update_lines.  Yes, now display
page 1 in lines30.txt then v(), the bottom of the screen does not clear:

...
line 29
line 30
Line 15
Line 16
...


Step 2.  In refresh(), first clear window to cleaer any remaining text 
after end of buffer.   Now display page 1 from lines 30, when v() to last
page, lines after 'line 30' are now empty.  So that worked.
BUT, as expected, on last page of lines30, deleting 4 lines from line20
leaves lines remainging after the delete:

...
Line 18
Line 19
line 24
line 25
...
line 29
line 30
line 27
line 28
line 29
line 30


line 27 and after should not appear.  Now add code to delete remaning lines
after the end of the buffer in move_dot_d_.

Oh, when setting up for this test k() on lines30.txt switches to lines10.txt,
and there were remaining lines at the end of buffer, which refresh() fixed.
But it seems we need another fix in k().
Back to testing d() in lines30.txt.  BUT we get:

>>> d(o(),o()+3)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "/Users/jon/Piety/editors/sked.py", line 346, in d
    move_dot_d(start-1)
  File "/Users/jon/Piety/editors/frame.py", line 220, in move_dot_d_
    for iline in range(nelines+1): # empty lines after end of buffer
TypeError: unsupported operand type(s) for +: 'NoneType' and 'int'

So that means nelines is Nonetype, didn't preceding call to update_lines
Oh, now I see move_dot_d calls update_window not update_lines.  So does
move_dot_a and _y.
Oh dear, this won't work.  update_window calls update_lines, but *then* it
calls put_marker and update_status
So we can't easily adapt this.  I forgot all about update_window.

Bah.  There is no easy fix.  Let's back out of this whole thing.  It's just
an optimization for the case where we are appending at the end of the buffer.
When we revise to support append in place *in the window* we
will have to revise it anyway.   So just back out for now.

We could add another parameter deleting=False to both update_lines
and update_window, just passing it through update_window to update_lines,
it has the effect when True of clearing those empty lines after the end
of the buffer.   BUT this solution is clunky - defer til after we code
append-in-window, or maybe defer forever.

Jonathans-MacBook-Pro:editors jon$  cp frame.py frame.py.no-kill-line
Jonathans-MacBook-Pro:editors jon$ git checkout frame.py

Instead, lets' do the renaming.

>>> c('move_dot_e_','display_e',1,S())
def display_e(iline):
    ed.move_dot_e = display_e
>>> c('move_dot_a_','display_a',1,S())
def display_a(iline):
    ed.move_dot_a = display_a
>>> c('move_dot_d_','display_d',1,S())
def display_d(iline):
    ed.move_dot_d = display_d
>>> c('move_dot_y_','display_y',1,S())
def display_y(iline):
    ed.move_dot_y = display_y
>>> c('move_dot_c_','display_c',1,S())
def display_c(iline):
    ed.move_dot_c = display_c
>>> c('move_dot_(','display_move_dot(')
def display_move_dot(iline):
>>> c('move_dot_','display_move_dot')
    ed.move_dot = display_move_dot    # patch sked with version defined above

Now let's see if frame still works with those changes, before we change more.

>>> c('restore_buffer_','display_restore_buffer',1,S())
def display_restore_buffer(bname):
    ed.restore_buffer = display_restore_buffer
>>> c('set_saved_','display_set_saved',1,S())
def display_set_saved(status):
    ed.set_saved = display_set_saved

That leaves only st_ and printline_ - I'm not quite sure about those 
because they replace top-level commands, not functions which are called
by top-level commands.   Does that make any difference?
No, printline_ is called by ed top-level functions.  The only difference is
we don't need to save _printline = ed.printline because ed.printline is just
builtin print.

>>> c('printline_','display_printline',1,S())
# no _printline from ed needed here, display_printline replaces builtin print
def display_printline(value, sep=' ', end='\n', file=sys.stdout, flush=False):
    ed.printline = display_printline # suppress printing during display

Also, st() is called by b() and k() in addition to being called as a command.

>>> c('st_','display_st',1,S())
def display_st():
    ed.st = display_st

Also change comment about naming convention: display_<name> not <name>_

Ready to test.

 8 Apr 2023

Seems to be working.

Jonathans-MacBook-Pro:editors jon$ git commit frame.py -m 'frame: rename all the <name>_ to display_<name>'
[patch a3890c6] frame: rename all the <name>_ to display_<name>
 1 file changed, 22 insertions(+), 22 deletions(-)
Jonathans-MacBook-Pro:editors jon$ git push
...
...

Next - merge this patch branch back into ed, make fparams branch.

First clone the repo, in particular this patch branch, to its own directory 
so we can compare it to the merged ed branch etc.

Jonathans-MacBook-Pro:~ jon$ git clone https://github.com/jon-jacky/Piety Piety.patch
Now prepare to merge fparam back into ed branch.  Clone a copy to compare:

Jonathans-MBP:~ jon$ git clone https://github.com/jon-jacky/Piety Piety.fparam
Cloning into 'Piety.fparam'...
...

Jonathans-MBP:Piety jon$ git checkout ed
Switched to branch 'ed'
Your branch is up-to-date with 'origin/ed'.
Jonathans-MBP:Piety jon$ git merge fparam
Updating e63a700..c3ed361
Fast-forward
 BRANCH.md         |  32 +++++---
 editors/README.md |  21 ++++-
 editors/frame.py  | 233 +++++++++++++++++++++++-------------------------------
 editors/sked.py   |  90 ++++++++++-----------
 4 files changed, 183 insertions(+), 193 deletions(-)

Jonathans-MBP:Piety jon$ git diff BRANCH.md ~/Piety.fparam
...

Oh no! Lots of diffs!   Oh, Piety.fparams has the master branch contents.

Jonathans-MBP:Piety.fparam jon$ git branch
* master
Jonathans-MBP:Piety.fparam jon$ git checkout fparam
Branch fparam set up to track remote branch fparam from origin.
Switched to a new branch 'fparam'
Jonathans-MBP:Piety.fparam jon$ git branch
* fparam
  master

Now diff shows ~/Piety now ed branch has same contents as ~/Piety.fparam
still fparam branch.
Cloning into 'Piety.patch'...
...

Jonathans-MacBook-Pro:~ jon$ cd Piety.patch
Jonathans-MacBook-Pro:Piety.patch jon$ git branch
* master
Jonathans-MacBook-Pro:Piety.patch jon$ git checkout patch
Branch patch set up to track remote branch patch from origin.
Switched to a new branch 'patch'
Jonathans-MacBook-Pro:Piety.patch jon$ git branch
  master
* patch

Jonathans-MacBook-Pro:~ jon$ git diff --brief ~/Piety/editors ~/Piety.patch/editors
fatal: invalid diff option/value: --brief
Jonathans-MacBook-Pro:~ jon$ diff --brief ~/Piety/editors ~/Piety.patch/editors
Only in /Users/jon/Piety/editors: README.md~
Only in /Users/jon/Piety/editors: __pycache__
Only in /Users/jon/Piety/editors: ed.py~
Only in /Users/jon/Piety/editors: frame.py.no-kill-line
Only in /Users/jon/Piety/editors: sked.md~
Only in /Users/jon/Piety/editors: sked.py~
Only in /Users/jon/Piety/editors: skedinit.py~
Common subdirectories: /Users/jon/Piety/editors/test and /Users/jon/Piety.patch/editors/test
Jonathans-MacBook-Pro:~ jon$ diff ~/Piety/editors/frame.py ~/Piety.patch/editors/frame.py

Okay, we have the reference Piety.patch directory tree.  Now merge.

Oops, first commit:

Jonathans-MacBook-Pro:test jon$ git commit -am 'add test/lines10.txt and lines30.txt'
[patch e63a700] add test/lines10.txt and lines30.txt
 2 files changed, 40 insertions(+)
 create mode 100644 editors/test/lines10.txt
 create mode 100644 editors/test/lines30.txt
Jonathans-MacBook-Pro:test jon$ git push
...

Jonathans-MacBook-Pro:test jon$ git checkout ed
Switched to branch 'ed'
Your branch is up-to-date with 'origin/ed'.
Jonathans-MacBook-Pro:test jon$ git merge patch
Updating a3db850..e63a700
Fast-forward
 editors/README.md                     |   4 +-
 editors/frame.py                      | 306 ++++++++++++++++++++++++++++++++++
 editors/{fredinit.py => frameinit.py} |   4 +-
 editors/fred.py                       |  42 -----
 editors/sked.py                       | 108 ++++++++----
 editors/test/lines10.txt              |  10 ++
 editors/test/lines30.txt              |  30 ++++
 editors/test/lines40.txt              |  40 +++++
 8 files changed, 465 insertions(+), 79 deletions(-)
 create mode 100644 editors/frame.py
 rename editors/{fredinit.py => frameinit.py} (84%)
 delete mode 100644 editors/fred.py
 create mode 100644 editors/test/lines10.txt
 create mode 100644 editors/test/lines30.txt
 create mode 100644 editors/test/lines40.txt

onathans-MacBook-Pro:editors jon$ git diff frame.py ~/Piety.patch/editors
Jonathans-MacBook-Pro:editors jon$ git diff sked.py ~/Piety.patch/editors

Jonathans-MacBook-Pro:editors jon$ echo *~
README.md~ ed.py~ sked.md~ sked.py~ skedinit.py~
Jonathans-MacBook-Pro:editors jon$ rm *~
Jonathans-MacBook-Pro:editors jon$ diff --brief ~/Piety/editors ~/Piety.patch/editors
Only in /Users/jon/Piety/editors: __pycache__
Only in /Users/jon/Piety/editors: frame.py.no-kill-line
Common subdirectories: /Users/jon/Piety/editors/test and /Users/jon/Piety.patch/editors/test


We are not keeping BRANCH.md up-to-date in all the branches.  Maybe delete it?


Now make the first function with a function parameter: e, passing in display_e.

...$ git diff sked.py
...
-move_dot_e = move_dot  # placeholder, can be replaced by display code
-
-def e(fname): 
+def e(fname, move_dot=move_dot):  # move_dot is a hook for display code 
...
-    move_dot_e(min(S(),1)) # start of buffer, empty buffer S() is 0
+    move_dot(min(S(),1)) # start of buffer, empty buffer S() is 0
...

...$ git diff frame.py
...
-_move_dot_e = ed.move_dot_e
-
...
+def e(fname):
+    ed.e(fname, move_dot=display_e)
+
...
-    global _move_dot, _restore_buffer, _st,  _set_saved, _move_dot_e, \
+    global _move_dot, _restore_buffer, _st,  _set_saved,  \
...
-    _move_dot_e = ed.move_dot_e
...
-    ed.move_dot_e = display_e
...
-    ed.move_dot_e = _move_dot_e

Ready to test.  Restart python so we don't have old move_dot_e hanging around.


...$ python3 -i
...
>>> import sked
>>> from sked import *
>>> import frame

But NOT from frame import * - we don't want frame.e to shadow sked.e yet.

>>> e('sked.py')
sked.py, 387 lines
>>> v()
"""
sked.py - Stone Knife Editor, line editor inspired by classic Unix ed.
...
def e(fname, move_dot=move_dot):  # move_dot is a hook for display code 
...

... and no move_dot_e - so we have loaded the right version.

>>> frame.win(24)

It does the right thing.

>>> from frame import *

Now e should be frame.e not sked.e

>>> e('frame.py')
frame.py, 304 lines

It does the right thing!  window updates with frame.py

>>> s('def e')
def e(fname):

Oh dear, window did not update around that line, and line printed in 
command region.   BUT I didn't touch that code ... !?

>>> refresh()

But window does not refresh - even though status line says 'at line 183'
it still displays top of buffer.
...
Do git diff again to confirm that we *only* changed e() in sked and frame 
and removed sked move_dot_e and frame _move_dot_e and move_dot_e_.

>>> frame.displaying
False

Oops.  Looking back in history, we see we did win(24) not wopen(24).
So *none* of the other display_* were enabled!  Exit and restart python
again, do it right this time.

...$ python3 -i 
...
>>> import sked
>>> from sked import *
>>> import frame
>>> e('sked.py')
sked.py, 387 lines

but not yet from frame import *

>>> v()
"""
sked.py - Stone Knife Editor, line editor inspired by classic Unix ed.
...

>>> wopen(24)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
NameError: name 'wopen' is not defined
>>> from frame import *
>>> wopen(24)

Now top of sked.py appears in window.

>>> s('def e(')

 Now window refreshes around 'def e(', status line says 'at line 99 of 387'.

>>> l()
>>> rl()
>>> v()
>>> rv()
>>> n()
 scratch.txt           0   scratch.txt                     saved
>>> e('frame.py')
frame.py, 304 lines

Window updates with top of frame.py

>>> s('def e(')

Window updates around 'def e(' at line 183 of 304.   

So the fparam scheme seems to be working, and the old code is still working too.
Jonathans-MacBook-Pro:editors jon$ git commit -am 'fparam (function parameter) scheme working for e()
> Revise sked e to use move_dot=move_dot, frame e to use move_dot=display_e
> remove move_dot_e from sked and _move_dot_e and move_dot_e_ from frame'
[fparam b90d4ca] fparam (function parameter) scheme working for e() Revise sked e to use move_dot=move_dot, frame e to use move_dot=display_e remove move_dot_e from sked and _move_dot_e and move_dot_e_ from frame
 3 files changed, 10 insertions(+), 11 deletions(-)
Jonathans-MacBook-Pro:editors jon$ git push
Total 0 (delta 0), reused 0 (delta 0)
To https://github.com/jon-jacky/Piety
   a3db850..e63a700  ed -> ed

Did we push to the right branch at github?
No!  fparam branch does not appear in github web page branches/tags pull down!
Not even after I refresh page - BUT the page for the patch branch is still
okay - did not get updated by this last push.  BUT what about ed?
That branch is okay too.  I recall we have to name new branch in push.

ed is okay too.   HEre is the push command we want:

Jonathans-MacBook-Pro:editors jon$ git push -u origin fparam
Counting objects: 6, done.
Delta compression using up to 4 threads.
Compressing objects: 100% (6/6), done.
Writing objects: 100% (6/6), 845 bytes | 0 bytes/s, done.
Total 6 (delta 5), reused 0 (delta 0)
remote: Resolving deltas: 100% (5/5), completed with 5 local objects.
remote: 
remote: Create a pull request for 'fparam' on GitHub by visiting:
remote:      https://github.com/jon-jacky/Piety/pull/new/fparam
remote: 
To https://github.com/jon-jacky/Piety
 * [new branch]      fparam -> fparam
Branch fparam set up to track remote branch fparam from origin.


We refresh sked.py and frame.py pages at github, confirm that new fparam
branch is present, confirm newly pushed fparam code is there.

Now let's try converting move_dot.   This is interesting because it is
used in several or many commands, not just one.

Hmn, sked a() calls both move_dot and move_dot_a.

Here are the signatures of sked fcns that call move_dot:

def e(fname, move_dot=move_dot):  # move_dot is a hook for display code 

def p(start=None, end=None, move_dot=move_dot): # move_dot is hook for display

def rv(nlines=None, move_dot=move_dot): # move_dot is a hook for display

def s(target=None, forward=True, move_dot=move_dot): # move_dot hook display

def a(iline=None, move_dot=move_dot, move_dot_a=move_dot): # hooks for display

Ready to test -- I think.

 9 Apr 2023

Restart python to get rid of superceded functions still in the session.

First run without frame to make sure we didn't break the editing fcns in sked.

sked works, tried e p rv s a.  then after import frame, from frame import *,
then e rv a do update the window but p s do not update window, oh dear.  

>>> s('line 15')
? 'Line 10' not found

I recall I did s('Line 10') with no display, that worked.

>>> p(1,10)

Moves to line 40

>>> p(30,35)
>>> p(1,10)

Display does not update for either.
rv() does update display as it should but v() does not update display.
Status line does not update when p(...), v(),
does update with correct line after rv(), each line in a().
v() uses p(), rv() uses move_dot.  I think there must be a problem with p().
I think the problem with s(...)  ?'Line 10' not found is a different problem.
Hey, remember we had trouble editing p() - maybe source text is messed up?
Looked at current source in emacs, compared to last working source at github -
source is what I intended.

10 Apr 2023

I don't see any obvious explanation for these problems (although I'm sure
there is one - see our experience with c() last week).   How do approach it?

One problem might be that we are running with a combinatino of patched and
unpatched functions.  In particular, p() takes the function parameter
display_move_dot, but also uses the patched display_printline.  Try passing
both to p() so there is no patching in p().

11 Apr 2023

But of course now display editing is impossible because our latest code
doesn't work.   Can we do it with just sked?

>>> s('p(r')
? 'def p' not found

No, even in sked this doesn't work anymore.  It's using the stored 
old string, it must think the 'target' argument is None so it uses 
the stored search string instead.  So there is something wrong with
the arg list for s().

Bah.  Let's back out this mess and work on the other sked fcns that 
dont' use move_dot or printline or st - those are the complicated ones.

Jonathans-MacBook-Pro:editors jon$ cp frame.py frame.py.move_dot
Jonathans-MacBook-Pro:editors jon$ cp sked.py sked.py.move_dot
Jonathans-MacBook-Pro:editors jon$ git checkout frame.py
Jonathans-MacBook-Pro:editors jon$ git checkout sked.py


Jonathans-MacBook-Pro:editors jon$ diff sked.py sked.py.move_dot
... as expected ...

Ditto diff frame.py.  Oh, but frame.py.move_dot also has those comment
blocks that explain the function parameters scheme.  For now, don't copy those.

Next do restore_buffer, which is only used in b() and k().

Note k() has no other arguments.  e() had one argument, not optional.
b() does have one optional argument.

Ready to test, restart python, try e, b, k with just sked to make sure
we didn't break them with new arg, be sure to test b with and without 
bufname arg.  They all work.   Now from frame import *, wopen, try them
all again.   They all work, display updates as it should.

Next do set_saved, which is only called by w, which has optional filename.
We only use set_saved(True) in w().   The several saved = False immediately
precede the several move_dot_<x> which call update_status so 'unsaved' 
appears on the status line due to that.
Tested w() with no arg and with arg in both sked and frame, works.

Now the only simple ones left to do are display_d, display_y, display_c.
display_a has move_dot and move_dot_a - so that would make combination
of patched and wrapped.    Lets do d, y, c, then try a with both 
display_move_dot and display_a.  Test d, y, c in sked - they work.

12 Apr 2023

Test d, y, c with frame.

>>> reload(frame)
>>> e('test/lines40.txt')
...
>>> s('10')
>>> d(o(),o()+5)

no visible effect

>>> refresh()

Now we can see lines were deleted.

>>> y()

That has expected visible effect

>>> s('20')
>>> y()

So did that.

>>> c('15','fifteen')

No visible effect

>>> refresh()

No visible effect - apparently c(...) changed nothing

>>> p()

Of course it doesn't print anything - we're in display mode.

It seems odd that y() works but d() and c() do not - what's the difference?
To avoid possible confusion from old fcns hanging around, restart.

>>> from frame import *
>>> wopen(24)
>>> e('test/lines40.txt')
test/lines40.txt, 40 lines
>>> s('10')
>>> d()
>>> y()
>>> d(o(),o()+5)

d(), y() work as expected by d(o(),o()+5)  only deletes line 10 again,
and y() pastes just that one line.

>>> d(o())
>>> y()

This works - so one arg works - but this doesn't

>>> d(o(),o()+5)
>>> y()

Still just deletes line at dot.

>>> d(o()+5)
>>> y()

Still just deletes line at dot - it's not using first arg, just default.

>>> c('10','ten')
Line ??? 

It's using default replacestring - it's not using args.

>>> c('line 1','line one-',1,S())

Does nothing because 'line 1' is not at dot, doesn't use other args.

>>> c
<function c at 0x10752aaf0>
>>> frame.c
<function c at 0x10752aaf0>
>>> sked.c
<function c at 0x107437ee0>

So we are using the intended function. I guess args just aren't working.
Do they work in any of the wrapped functions?

We have b(bname=None) and w(fname=None) - didn't they work in display mode?
Make sure we were not just using defaults!

And e(fname) works - there is no default

>>> b('lines40.txt')
>>> sked.filename
'test/lines40.txt'
>>> w('test/lines40???.txt')
test/lines40???.txt, 40 lines

works, test/lines40???.txt is there in file system, also status line updates.


>>> e('sked.py')
sked.py, 381 lines
>>> e('frame.py')
frame.py, 296 lines
>>> sked.prev_bufname
'sked.py'
>>> b('scratch.txt')

Works.

>>> sked.prev_bufname
'frame.py'

>>> b('sked.py')

works

>>> sked.prev_bufname
'scratch.txt'
>>> b()

works.


So args in e(), b(), w() work, non-default args work.  But they all just 
have one arg, not two or more.
Do these work in sked only, then they have the extra arg.

12 Apr 2023

There is confusion here between default arguments and keyword arguments.
We want regular positional arguments (not keyword args) but we want to
have default arguments for all of them.

In frame, in our ed.c(...) etc. calls, it looks like we are calling them
as keyword args wtih name=value.   Shouldn't it just be value -? 
Review default args vs. keyword args in the Python tutorial and ref manual.
and maybe Python in a Nutshell - but I believe there are 3.x changes.


Reading the tutorial, 
file:///Library/Frameworks/Python.framework/Versions/3.9/Resources/English.lproj/Documentation/tutorial/controlflow.html#more-on-defining-functions

It appears we have defined fcns w/ default args correctly, but then
in frame we call fcns as if they had kw args.   BUT then at REPL we did
not provide keyword args.

Tutorial sect 4.7.3 shows how to use optional '/' and '*' in arg lists
to explictly mark positional and keyword args.

Revise command fcn bodies - calls to sked - to use positional parameter syntax.


Trying to use sked only to edit frame.py

>>> r('ed.b(')
    ed.b(bname, restore_buffer=display_restore_buffer)
>>> c('restore_buffer=')
    ??? bname, restore_buffer=display_restore_buffer)
>>> c('restore_buffer=','')
>>> p()
    ??? bname, restore_buffer=display_restore_buffer)
>>> c('??? bn','ed.e(bn')
>>> p()
    ??? bname, restore_buffer=display_restore_buffer)

Oh dear.  Let's exit Python and start over.
Doh, I think I forget to 'from sked import *' after wclose - so we were 
still trying to use the wrapped frame commands, not the bare sked commands.

>>> r('ed.b')
    ed.b(bname, restore_buffer=display_restore_buffer)
>>> c('restore_buffer=','')
    ed.b(bname, display_restore_buffer)

That's more like it.   NOw see if that works.  First test in just sked,
that would be b() and k().
We changed ed.b and ed.k.
b() and k() work in sked - no display.  And, they work in the display.
Now we can fix the rest.
Done.  Test all the wrapped commands in frame: b k e w d y c.
We have already tested b k e in frame, do w d y c now.

Start over.  Confirm we have the frame commands in the REPL:

>>> import sked
>>> from sked import *
>>> d
<function d at 0x10464ddc0>
>>> import frame
>>> from frame import *
>>> d
<function d at 0x1047408b0>


Tested w d y c in frame - they work with and without args in frame, 
update window as intended.

Now go on to wrap (or otherwise fix) printline move_dot st a.
How do handle printline?  It's print in sked, do nothing in frame.
So the commands that use printline should be declared in sked as
(..., printline=print) and then called in frame as (..., no_print)
Oh, but p() is a sked command that calls sked printline and sked move_dot.
BUT p() is also called by the sked commands l, rl, v, rv, tail.


Can we just define sked p() with args move_dot=move_dot and printline=print
and then define l rl etc. with arg p=p, then in frame define 
def display_p(...): ed.p(..., display_move_dot, no_print), then in l, rl,
etc. in frame pass display_p

Once again, what sked fcns use printline? st p s that's all.
sked st is nothing but printline(status()).  sked display_st is nothing but
update_status.   What sked fcns call st? b k  that's all
I think in in sked we can declare b(..., st=st) ditto k  Then 
in frame we can have b(..., update_status) ditto k.   We shouldn't
need to wrap st in frame at all.   So if we ever type st() after
from frame import * we will still get sked st() - it will print someting,
even thought it's just what you see on status line.   Might be handy to
have p(...) print something after from frame import * also.

How can we stage this?  Can we fix st and printline before move_dot and p?

Oh, we can define frame display_p to pass to the other cmds that use p(),
but we won't define a top-level frame p command itself - so we can continue
to use sked p to print out lines in the command regino to check on the display.

13 Apr 2023

Start with st.  Replace printline with print.  In sked b and k, have
arg st=st.   In frame b and k, have arg st=update_status.
So we can eliminate display_st from frame.  Also sked st doesn't all
printline, it jsut calls print.  st is only called in sked, never in frame.
Done.

Do we need printline at all?  In sked can't we just have print=print 
and in frame pass print_nothing?  Let's keep printline as the arg name but
there is no module level printline anywhere.
Done.

Now fix p().  Oh, but p() uses move_dot.  Do that too.  Restore lines from
sked.py.move_dot and frame.py.move_dot?
Fcns that use p() are l, rl, v, rv, tail.  In sked pass p=p.
In frame pass display_p.
Done.

Can I test this without wrapping all the sked fcns that use move_dot?
So far we have just wrapped p, passing display_move_dot.   But won't 
patching in all the other fcns that use move_dot still work?
Are we patching move_dot in any functions we have already wrapped?

14 Apr 2023

What about testing now?  In frame we wrap sked p with fparam display_p.
where display_p has fparam display_move_dot.   BUT is sked p() *also*
getting patched with display_move_dot?  Yes.   I think we just have to 
continue and finish all the fparams, wrapping and passing display_move_dot
in all the sked commands where move_dot appears.

In sked a() there is a call to move_dot before the loop with call 
to move_dot_a.   Can't we just replace that first move_dot with dot = ... ?
Yes, I think so.  So what sked functions are left that still have move_dot?

rv s - that's all! except a() - where we now think we don't need it.
All the other move_dot have already been included in move_dot_<x>.
Oh, come do think of it I do think we need to pass that move_dot in a()
if we really do assign dot there - to keep display consistent.
It would be better if we didn't assign dot there at all - that's just
supposed to be the starting point for the search.
No, we definitely *do* need to assign dot there and run display_move_dot
so marker appears where we are going to start appending.

Oh - does rv() really need move_dot - isn't it redundant?  We already
do p() -- oh, but we do really need that last move_dot because p() 
puts dot at the end of the printed lines, but we need dot at the beginning.

15 Apr 2023

Let's just finish it, pass display_move_dot to s(), rv(), a()

Ready to test.  Lots of new stuff here.
Now we eliminte enable_,disable_display, wopen, wclose - we can just
use win, clr.

>>> w()
frame.py, 257 lines

That's quite a bit less!   We will add some comments, maybe 10 lines.

>>> w()
sked.py, 377 lines

we didn't remove anything here.

Now restart python.   First just import sked and makes sure it works without
the display.
p(...) works, including with o(), o()+<n>, and S() args

the first problem appears:

line 39
line 40
>>> r('line 10')
? 'line 10' not found
>>> p()
line 40
>>> p(1)
line  1
>>> s('line 10')
? 'line 10' not found
>>> p()
line  1

In sked.py s(...) code looks unchanged - !?  All we added was new printline
and move_dot args, right?   Review git diff.  Yes, that's right.

DOH!   The file contains 'Line 10' not 'line 10'.  s() does work.  Let's 
try using c to fix it:

>>> c('Line','line',1,S())
line 10
line 15
line 16
line 17
line 18
line 19
line 20
>>> s('Line')
? 'Line' not found
>>> r('Line')
? 'Line' not found

Try all the commands - they all seem to work.  Next, load frame and 
from frame import *

win, l, rl, v, rv work but p(30) off bottom of page does not do page down.
refresh() does update page.  BUT l() refreshes to next page, as it should - !?

l() at page bottom does do page down.  r('13') does not move cursor up,
though o() says 13.  then l() moves marker to 13, though it remains at 14.
rl() at page top pages up.  refresh() does move mark after s().  BUT 
s('25') does page down.  r('10') doesn't page up.  refresh() doesn't refresh
page. 

r() doesn't display at all.  s() does display and does page down.

l() and rl() do display and do page up/down.

refresh() does work on the same page.  refresh() does not page up or down.

p() does not display and does not page down.

v() and rv() do display and do page up/down

It appears fcns are working in sked - print of line number and o() of
line number show dot is actually getting moved as it should.

Oh - r is a separate function from s - we didn't wrap it in frame.
Rather than complicate sked r with more args, just define frame r in 
terms of frame s - just copy the defn from sked.
d(o(),o()+3) works.  y() works.   y() def r into frame, then w(), then
reload(frame), the from frame import * - now r() works! including page up.
Oh, I never defined frame p().   Try this in frame: p = display_p
the w() reload etc.  Yes, now p() works with display including page up/down
Now refresh() is the only one that 'doesn't work' - but I think it works
like it always did - it refreshes the currently displayed page, it doesn't
change the page.  We have the function that does it - recenter().

>>> sked.p(30)
    in the buffer.  Clip nlines to fit in window if needed.  Pad buffer lines
>>> refresh()
>>> recenter()

refresh just puts the marker at line 1.  recenter moves the page and refreshes.
So it appears everything is working.   

Jonathans-MacBook-Pro:test jon$ git commit -am 'sked, frame: wrap all the sked commands in frame 
> After from frame import * all the sked commands update the display'
[fparam d90deba] sked, frame: wrap all the sked commands in frame After from frame import * all the sked commands update the display
 2 files changed, 63 insertions(+), 114 deletions(-)
Jonathans-MacBook-Pro:test jon$ git push
...


17 Apr 2023

Jonathans-MacBook-Pro:editors jon$ git commit -am 'sked, frame: rearrange order of functions, add/revise comments
> README.md: add some draft text, not finished'
[fparam 34bb9f0] sked, frame: rearrange order of functions, add/revise comments README.md: add some draft text, not finished
 3 files changed, 131 insertions(+), 95 deletions(-)
Jonathans-MacBook-Pro:editors jon$ git push
...

Jonathans-MacBook-Pro:editors jon$ git commit -am 'sked, frame: re-order a few mor functions
> '
[fparam b2e7b93] sked, frame: re-order a few mor functions
 2 files changed, 15 insertions(+), 15 deletions(-)
Jonathans-MacBook-Pro:editors jon$ git push
...

Jonathans-MacBook-Pro:editors jon$ git commit -am 'frame: revise comments that mention old wopen(), now gone'
[fparam d37dec0] frame: revise comments that mention old wopen(), now gone
 1 file changed, 1 insertion(+), 2 deletions(-)
Jonathans-MacBook-Pro:editors jon$ git push
...

Next: revise a(ppend) so we type new lines in-place in the window,
not in the command region.  We will need new placeholders in sked a()
and new/revised functions in frame, in addition to display_a()

When we start a(), move cursor to dot in window, open line below 
to make room to type in new line, push all the lines below down one line.

Then after we type in each line, once again open line below and push
lower lines down.  

After we type in each line, add to buffer, but do *not* display in window.
It
s already there!  Just leave the text we put there when typing into input().

When we exit append mode by typing .  must close up open line with . on it
by moving all the lines below up one line.

So we need new frame start_a and finish_a functions, and we need to revise
display_a function.   We need new hooks in sked a() for start_a and finish_a.

Can we merge new start_a and display_a ?  They both involve open line and 
put cursor on open line.   But on start_a we have to move cursor from 
command region to window, and in display_a previous line processing has
already put cursor on the right line.  So the code will look something like:

start_a: move cursor to dot in window

display_a: open line at cursor; insert into buffer = input(line);  
            move cursor down to next line

finish_a: close line at cursor, move cursor back to command region

where open_line at cursor: clear (kill) line, move lines below down

Make sure when we move lines down, we do nothing when we're at the 
end of the buffer!

In sked a(), the first move_dot arg could be bound to something
other than display_move_dot - a new fcn that calls display_move_dot
and then puts cursor at dot in window.


18 Apr 2023

Trying to edit home/computing.txt in frame, I found that
marker on screen did not actually sit at line dot, as 
indicated by sked.p().   The problem seems to arise from
unwrapped paragraphs preceding dot.  Maybe it works in
just sked?

19 Apr 2023

Jonathans-MBP:editors jon$ git commit -am 'BRANCH.md: bring up to date with recent work in patch branch'
[fparam c3ed361] BRANCH.md: bring up to date with recent work in patch branch
 1 file changed, 33 insertions(+), 26 deletions(-)
 rewrite BRANCH.md (84%)
Jonathans-MBP:editors jon$ git push
...

Doh, I meant fparam branch.


22 Apr 2023

Jonathans-MBP:editors jon$ git commit -am 'BRANCH, editors/README: bring up to date with recent work on sked and frame'
[ed 0eb56d9] BRANCH, editors/README: bring up to date with recent work on sked and frame
 2 files changed, 115 insertions(+), 36 deletions(-)
 rewrite editors/README.md (69%)

Jonathans-MBP:editors jon$ git branch
* ed
  fparam
  master
  ...

Now when I git push will this go into ed branch?

Just to be sure do: git push -u origin ed.

Jonathans-MBP:editors jon$ git push -u origin ed
Counting objects: 5, done.
Delta compression using up to 4 threads.
Compressing objects: 100% (5/5), done.
Writing objects: 100% (5/5), 2.12 KiB | 0 bytes/s, done.
Total 5 (delta 3), reused 0 (delta 0)
remote: Resolving deltas: 100% (3/3), completed with 3 local objects.
To https://github.com/jon-jacky/Piety
   e63a700..0eb56d9  ed -> ed
Branch ed set up to track remote branch ed from origin.


That worked - the new BRANCH.md and README.md are in the ed branch at github.

Jonathans-MBP:editors jon$ git commit -am 'editors/README.md: tweak formatting, describe a(ppend) command.'
[ed b083209] editors/README.md: tweak formatting, describe a(ppend) command.
 1 file changed, 16 insertions(+), 7 deletions(-)
Jonathans-MBP:editors jon$ git push
...

Now, fix help text (comment strings) in sked.py and frame.py?  Also, can
we fix function declarations so they wrap in help for nicer formatting?

Bah, that's a big job, maybe just go on to inwindow branch for now.
Shouldn't take long, we could go back to revising doc after merging
inwindow back into ed.

Jonathans-MBP:editors jon$ git branch inwindow
Jonathans-MBP:editors jon$ git checkout inwindow
Switched to branch 'inwindow'

Jonathans-MBP:editors jon$ git commit -am 'BRANCH.md: update for new inwindow branch'
[inwindow 883c7a5] BRANCH.md: update for new inwindow branch
 1 file changed, 5 insertions(+), 1 deletion(-)
Jonathans-MBP:editors jon$ git push -u origin inwindow
Counting objects: 3, done.
Delta compression using up to 4 threads.
Compressing objects: 100% (3/3), done.
Writing objects: 100% (3/3), 458 bytes | 0 bytes/s, done.
Total 3 (delta 2), reused 0 (delta 0)
remote: Resolving deltas: 100% (2/2), completed with 2 local objects.
remote: 
remote: Create a pull request for 'inwindow' on GitHub by visiting:
remote:      https://github.com/jon-jacky/Piety/pull/new/inwindow
remote: 
To https://github.com/jon-jacky/Piety
 * [new branch]      inwindow -> inwindow
Branch inwindow set up to track remote branch inwindow from origin.


23 Apr 2023

L6848 ff on 17 Apr discuss how revised a() should work.

In sked a(), first move_dot param will be assigned to new start_a,
move_dot_a() oaram will be assigned to new display_a, but what gets 
assigned finish_a ?

Oh dear, I looked at sked a() code - in the while loop it calls 
line = input() *before* testing for . for calling move_dot_a.
I think we have to change it - I think we have to wrap line = input()
with a placeholder function that gets replaced by new display_a.
And then after if line == '.' but before return we need another placeholdr
fcn we can replace with finish_a.  Then I think that move_dot_a  at 
then end can just be removed - its work is done by new display_a up above.

Oh, but be careful - in present code that move_dot_a at the end runs
only if the input line was *not* '.' - that's a special case to look out for.
We have to define the new sked read_input() placeholder.  Then 
the frame display_read_input has the new input line so it can test
for '.' and do the finish_a case.  It can leave the normal case to
be handled by the present sked.move_dot_a/frame.display_a at the end.
So that requires the smallest change to sked, but the code organization
in frame is a bit unobvious.

27 Apr 2023

In sked a(ppend), replace inline line=input() with new placeholder fcn
input_line().   First confirm that sked without display works, then 
code frame display_input_line initially no-op, confirm frame still works.

 1 May 2023

Those tests (above, 27 Apr) worked.  Now code the 3 append display fcns
in frame, ready to test.  First test just a() followed by .   We should
see line open, then close, but no lines added to buffer.

start_a iline arg can be different from dot - you can a(iline) to 
append at a location different from dot, start_a assigns iline to dot
BUT display_a already begins at dot, it does not move dot, it always 
advances dot by one line - actually, it opens the line *after* dot and
dot is only advanced if input() returns a line other than '.'.

 2 May 2023

Consider writing open_line with iline arg, don't assume ed.dot.  
We see locate_segment() has no arg, centers on ed.dot, but we could
parameterize with iline, then pass ed.dot.  Would that break anything?
locate_segment does not update ed.dot, it just returns a line number
that can be used as buftop.   Let's do that, make locate_segment iline arg
then pass ed.dot.   Done.

In display_a, we do not want to advance dot before open line because if 
line is '.' we don't want to advance dot.   This is why open_line cant
use dot, because we only advance dot *after* we examine input() result.
It looks like only display_a can advance dot, because we only reach it
if input did *not* return '.'

Finish coding first draft of frame a() display functions.   In lines40.txt,

>>> p(1)
>>> a(10)

In window we see 

...
line 10
line 12
...
line 24 

frame.py, 335 lines
>>> ...

That's an empty space between line 24 and 'frame.py 335 lines' 
'frame.py' 335 lines is leftover message from w().  Status line
was overwritten by blank line.  Also, cursor is on line 12.  We 
should have seen:

line 10
[]
line 11
line 12

Now type . to exit append mode.

 File "/Users/jon/Piety/editors/sked.py", line 326, in a
    line = input_line()  # Can this fail?  Yes, by ^C for example
  File "/Users/jon/Piety/editors/frame.py", line 219, in display_input_line
    wstart = wline(dot+1)
NameError: name 'dot' is not defined

Lots to fix here.  Attempt fix, try again.  Okay, this time we get

line 10
[]
line 11

which is correct but we still erase status line at end of window.
Typing . at cursor above does the right thing - line closes again,
we restore status line at bottom:

...
line 23
[lines40.txt, at line 10 .... ] all with gray background indicated by [...]

Fix again.  Even better now we get line 10 (open line) line 11 as before, at
the end we have 

...
line 21

[lines40.txt]

So we wrote one too few lines at the end.  Is the problem in open_line 
or update_lines?  display_input_line still does exactly the right thing.

 3 May 2023

In open_lines if... block, increase nlines by 1 with c('- 1','# - 1')
No, that doesnt' work, it just disappears the status line:

...
line 22

>>> ...

However, typing . does work.   So the nlines was currect before, but
update_lines prints the blank line at the end when it should print one
more text line.   So the problem seems to be in update_lines.
BUT update_lines works correctly everywhere else we use it - !?  Doesn't it?
Change: for line in ed.buffer[bstart:bstart+nblines]: to ...+nblines+1 ?
BUT shouldn't nelines, number of empty lines, be 0 here?

update_lines is also used in refresh, update_window, open_line,
display_restore_buffer, display_input_line.  update_window is used by
display_y, display_d.   Those all seem to work, except open_line.  
Confirm these work: refresh, display_restore_buffer (in b, k), display_y, _d.
In particular, they all handle the last line in the window correctly.
refresh, b, k update the whole screen but display_y and _d just update the 
bottom part - much like (exactly like?) what we are trying to do in open_line.

Aren't display_y and _d just move_lines_down and move_lines_up?   Isn't 
that exactly what we need for display_start_a, _a and display_input_line,
respectively?   So display_input_line is already working, does it resemble
display_d ?   display_input_line has:

            wstart = wline(ed.dot+1)
            nlines = wlines - wstart
            update_lines(nlines, ed.dot+1, wstart) # move lines up

display_d has update_window(iline, iline+1) which contains

def update_window(new_dot, bstart):

    ...
        wstart = wline(bstart) # bstart line in window
        nlines = wlines - wstart # wstart to end of window
        update_lines(nlines, bstart, wstart)

Yes, they look the same, bstart is bound to arg iline+1, like  ed.dot+1

display_start and display_a both have open_line(ed.dot) which contains

def open_line(iline):
    ...
        wstart = wline(iline) + 2
        nlines = wlines - wstart - 1
        update_lines(nlines, iline+1, wstart) # push lines down

Hey, maybe we want update_lines(... iline+2 ...)  -?

display_y has:

def display_y(iline):
    ...
    update_window(iline, iline-len(ed.yank)+1)

See update_window excerpt at L7130 above.   Isn't the display_start_a case
just this with len(ed.yank) of 1 ?
BUT is iline here the line where yanked text starts or ends?  Where it ends.

In open_line, try changing update_lines(... iline+1, ...) to iline+2
That did *not* work.  Results in:

line 10
[[
line 12
...
line 22

[lines40.txt ...]

So it leaves the problem at the bottom of the window BUT it puts the wrong
line after the opened line.  Bah.  Revert now.

...
line 10
[]
line 11
...
line 21

[lines40.txt ...]

It's better, but end of window is still wrong.

This might be because update_lines writes blank lines at the end.
If refresh() and e() b() k() and recenter() just cleared the whole
window, this wouldn[t be necessry - only needed for d() which moves lines
up.  We tried that a few days/weeks ago but there was some reason it
wouldn't work for d(), I recall.  Review that now.

Does open_line need another argument?  Can we get the effect we want
by backing out to just update_lines?


Doesn't open_lines just need to be revised so in update_lines 
nblines (lines from buffer) is one greater and nelines (n empty lines at end)
is one less?   Is it possible to get that from changing args to update_lines?
Or should we write the code inline in open_line?
It looks like we can achive that by reducing bstart passed to update_lines
by 1.  Just pass in iline not iline+1.  Try it.

No, that doesn't work either:

...
line 10
[[
line 10
...
line 20

[lines40.txt ...]

So it starts with the wrong line but still doesn't fill in the bottom right.
Revert.   So now it's like it was - it just has that darn blank line above
the status line while in append mode - after we exit mode with .  it's fine.

This is becoming a gumption trap.  If we want to fix this we should abandon
open_line and just try update_lines.  That way I think we can fix 
nblines and nelines inline.  That is, if we replace update_lines inline.
Or we could try to copy what we do with display_y.   Maybe we can't have
open_line with just one arg but we need to call update_lines and change 
more than one arg.

BUt haven't we tried changing every arg to update_lines in open_line?
What does display_y pass to update_lines?
Test at L7096 shows nlines is right, we are just putting in a blank 
line where there should be one more buffer line.  It really looks like
we need to increase nbline by 1 and decrease neline by 1 without changing
anything else.

Is it possible existing update_lines and update_window is *wrong* 
and are doing just what test at L7096 shows, but we usually don't see it
because status line overwrites the extra line?  That is, maybe fix update_lines
by reducing nlines by 1?  But keep nblines the same, so nelines is reduced
by 1.   And keep bstart and wstart the same.  Make sure nelines is 0 when
the buffer is longer than the window.  In our test case with a(10) just
calc by hand what nlines nblines nelines should be.

Test to see if display_d and _y are really doing the right thing at 
the end of the window.  Comment out update_status from them but not
refresh e b k.   See if d erases the status line, if it does refresh,
then see if y erases the status line.
Yes, both _d and _y use update_window, which calls update_lines then
update_status.  So we could just comment out update_status in update_window.
update_window is only called by _d and _y.   Could we remove update_status
from update_window, then use update_window in all three append fcns, then
add update_status back to callers _d and _y, also display_input_line which
finished append?

We still might want to revisit the empty-lines-at-the-end in update_lines.

Consider changing order of args to make the progression more clear:

 update_lines(bstart, wstart, nlines)

 update_window(bstart, wstart) # update from wstart to end of window

 open_line(iline) # open line after iline in buffer

Define each in terms of the preceding - in update_window calc nlines,
call update_lines.  In open_line calc bstart, wstart, call update_window.
This is orthogocanl to the empty-lines-at-the-end issue, which I think
can be solved (or not) in update_lines.

Commit the present version before revising these three functions.

Is there ever a need for update_lines, except to define update_window?

First we have to confirm that update_lines is correct - do the update_window
without update_status experiment first.   BUT the problem could be just
nlines calc in update_window.

None of these three functions should refer to dot.  Neither should any of
the building block functions.
I think I see a problem already. Now we have update_window(new_dot, bstart)
which moves dot to new_dot.   BUt update_lines and open_line do not assign dot.

 4 May 2023

It might make sense to remove the empty-lines-at-the-bottom code from
update_lines to update_window or, if we return to clear-whole-window-on
-refresh, just to display_d which would be the only place it was needed.

Now let's try the experment of commenting out update_status in update_window.
YES!  Now display_d and display_y replace the status line with a blank line!
so update_window (and thus update_lines) must count the lines wrong.

I just restored update_status to update_window and it works like before.
Commit this version now so we can revise some functions.

Jonathans-MBP:editors jon$ git commit -am 'sked, frame: typing in append mode updates display window in place.
> Bug: in append mode, last line in window above status line is empty'
[inwindow b9970ac] sked, frame: typing in append mode updates display window in place. Bug: in append mode, last line in window above status line is empty
 2 files changed, 69 insertions(+), 22 deletions(-)
Jonathans-MBP:editors jon$ git push
...


Review 'clear window' to try to eliminate empty-lines-at-end problem,

Review 'clear window' to try to eliminate empty-lines-at-end problem,
see Apr 4 and 5 above - exactly a month ago!   

Let's get started on revs.  Begin with update_lines, change arg order 
and also remove blank lines padding at the end - that should be handled
in update_window or maybe even display_d.  So we also need to revise 
refresh() to first clear the window.

First, just change order of args in update_lines defn and uses.
Also remove code at end of update_lines that writes blank lines.
Still haven't put clear window code in refresh().  Try same test as 7 Apr.
Yes, reproduce 7 Apr Step 1 - when we page to last page of lines40.txt, lines
from previous page remain on bottom of screen.
Then we do Step 2: add display.erase_above() to refresh().  Now when we page
to last page, bottom of page is empty, as it should be.  
Also e('test/lines10.txt') shows empty window after line 10, as it should.
BUT switching from lines10.txt to frame.py back to lines10 with b() leaves
lines at the bottom below line 10.  Ditto when we switch back to lines10
with k().  So b() and k() need to use erase_above() also.
b() and k() both use display_restore_buffer, we must put erase_above there.
Done.  It works, tested with b() and k() back and forth to lines10.txt.

Try a() d() y() in lines40.txt.  a() works - and no more blank line at
window bottom above status line!  So we fixed that!  d() appears to work
and sked.yank contains the deleted lines but y() draws the wrong thing on 
the screen.  Just redraws screen with lines further up on screen that were
not deleted - !?

Starting with a fresh lines40.txt in buffer, d(10,13) results in this:

...
line 9
line 18
line 19
...

>>> sked.yank
['Line 10\n', 'line 11\n', 'line 12\n', 'line 13\n']

So it looks like bstart for update_window was way off - did we fix
update_lines arg order everywhere?  Whoa - !  In frame.py, d() causes text
to appear in scrolling command region.  So does y() - but it worked in 
lines40.txt - !?

In lines40.txt repeat d(10,13) again see line 9\nline 18 in window but
refresh() restores to line 9\nline 14 as it should be.  Then y()
shows line 9\n\line 14...line 17 and puts cursor on line 17.  
refresh() restores the screen as it should be 9,10,...14,15,...
So everything is working but display code in d() and y().  refresh()
display code works.

Ah, I see we didn't change update_lines arg order in update_window.  Fix now.
All the other instances of update_lines look right.  w(), reload, ... import.
Test d() and y() again in lines40.txt.  Now they work.  Try in frame.py.
That works too.

We still have to fix the empty lines at the end problem for d() -!

Look again at update_window.  Args look wrong.  It assigns dot - that
looks wrong.  Is this fcn a replacement for move_dot?  Better check.
Maybe caller display_d or _y should assign dot.

 5 May 2023

Before revising update_window, display_d should review empty-lines-at-end.
Find a test that shows it: page to end of lines40.txt, several empty lines
at bottom of page after line 40.   Then delete line 34.  Yes, now old line 40
at the bottom stays there when the other lines move up one, so we have two
line 40 at the end.  y() restores line 34 in place and moves all the lines
down so now we have one line 40 at the end again.  On the first page, which
is full of text with no empty lines at the end, the same test works as
intended: when we delete lines in the middle of the page, the lines below
move up and the proper lines appear in order at the bottom to fill the page.

So we have at least two things to fix: empty-lines in delete (correctness), 
and untangling update_window (style).
We considered fixing empty-lines in delete about Apr 7 and found it it would
require some code reorganization, so we decided to defer it.

The fix we proposed back then was to have update_lines calculate and return
nelines, number of empty lines needed at the end, but not delete those lines
itself.  Then display_d could collect nelines from update_lines and delete
those lines. Oh, but it didn't work because display_d calls update_window
not update_lines, which calls update_status etc.   Can we calculate nelines
right in display_d?  Can't we just take difference of prev S() and current S()?

Start by expanding update_window inline in display_d.  Test to make sure
it works.  Yes, it does, and the last page of lines40 still shows problem. 
Now fix empty-lines problem by adding code inline in display_d.
When display_d is called, S() has already changed - prev S() is lost.
There is no arg in display_d to pass prev S(), adding global in sked is bad.
How did old update_lines do it?

    nblines = min(nlines, len(ed.buffer)-bstart+1) # n of lines from buffer
    nelines = nlines - nblines # number of empty lines at end of window

put calc of nblines and nelines in display_d after update_lines, then
for ... nelines ...: ...kill_line.   That works, yay!

Jonathans-MBP:editors jon$ git commit -am 'frame: d(elete) near end of buffer correctly shows blank lines at bottom of window'
[inwindow 93c967f] frame: d(elete) near end of buffer correctly shows blank lines at bottom of window
 1 file changed, 37 insertions(+), 19 deletions(-)
Jonathans-MBP:editors jon$ git push
...

We still have to test append, delete, yank that cross bottom of window.
We still have to test appending starting with an empty file.

What about renaming frame to edsel?

Now update_window is only used in display_y, and the style is wrong - 
it assigns ed.dot.  Maybe just put it inline in display_y - ?  Find 
some commonality among display_d, update_window and open_line. It seems
the common thing - which we could call update_window - is to write from
bstart to the end of the window.

But maybe we should run those other tests to make sure the code works first.
Adding lines to an empty buffer - or at the end of the buffer -
when you type . to exit append mode, the . doesn't disappear, and
the marker doesn't appear.
When in append mode, passing the end of the window, the window contents
are redrawn to put dot in the middle of the page - that's the end of the
buffer.  But the old lines remain at the bottom of the window - I thought
recenter called refresh, which should clear the window - ?

 6 May 2023

Fix append

1. At end of buffer with empty lines following, exit append mode with .
does not erase . from screen

2. " "  does not put marker on last line

3. In append mode, appending line at bottom of window does page forward,
but lines at end of window are not blank, instead they remain from prev page.

2a.  Exiting append does not put marker at dot even when *not* at end of buf.

Attempted fixes, all fixed except 1.  kill_whole_line there not working.
Have we already executed display.next_line() -- or something?
That's fixed, but now open_line is not pushing down the last line.
That's fixed now.

Jonathans-MBP:editors jon$ git commit -am 'frame: append in place in window is working'
[inwindow a8c1c7a] frame: append in place in window is working
 1 file changed, 14 insertions(+), 8 deletions(-)
Jonathans-MBP:editors jon$ git push
...


Now test d() and y() at the bottom of the window.  It does the right thing:
d() at window bottom stays on same page but pulls in line from next page.
Then y() goes to next page becaue now dot is at the bottom of the yanked text.

The code is correct, now fix style.  update_window is a mess due to next_dot
arg, also it's only used one place, in _y.  Just put the useful code inline 
there?  Or make a new function that updates from bstart to end of window, then
use it in _y, open_line, maybe other places?

 7 May 2023

Remove update_window and put its body inline in display_y.   That works.

Found a bug in append.  When appending on the last page with blank lines
at the bottom, but *not* appending at the end of the buffer, at exit when
close line with . on it, so lines below move up, the last line in the buffer
is duplicated at the end of the window because when lines move up the last
line is not erased.  This is similar to what d() does, but it's a special case
because there is always just one line left at the end.
Here we don't need to calculate the number of lines to delete, it's one or
nothing.  'if we are on the last page, but dot is not the last line, delete
that is kill - the line after the last line.
Or just 'if we are on the last page, kill the line after the last line.'

if in_window(S()):
   display.put_cursor(wline(S())+1)
   display.kill_whole_line()

Better check we don't kill status line, also.  Done, that fix worked.

Jonathans-MBP:editors jon$ git commit -am 'frame: remove update_window, put its body inline in display_y
> also fix bug in display_input_line, remove . after exit from a on last page.'
[inwindow 5d0884c] frame: remove update_window, put its body inline in display_y also fix bug in display_input_line, remove . after exit from a on last page.
 1 file changed, 16 insertions(+), 18 deletions(-)
Jonathans-MBP:editors jon$ git push
...


Getting rid of update_window was good.  Any further style improvements?
Is there anything in common between open_line, display_y, other uses of 
update_lines?   Aren't there several instances of 'update from this bstart
starting line to end of buffer' - ?  That could be the new update_window.

open_line(iline) has:

        wstart = wline(iline) + 2
        nlines = wlines - wstart
        update_lines(iline+1, wstart, nlines) # push lines down

oh dear, bstart used in wstart is not the same bstart as in update_lines.
Because wstart, that is iline+2, the line in the win *below* the opened line.
But bstart is the line in the buffer below dot.

display_d(iline)   has:

        bstart = iline + 1
        wstart = wline(bstart) # bstart line in window
        nlines = wlines - wstart # n of lines from wstart to end of window
        update_lines(bstart, wstart, nlines)

how about: update_below(iline + 1)

display_y(iline) has:

    ed.dot = iline
    ...
        bstart = ed.dot - len(ed.yank) + 1
        wstart = wline(bstart) # bstart line in window
        nlines = wlines - wstart # wstart to end of window
        update_lines(bstart, wstart, nlines)

how about: update_below(ed.dot - len(ed.yank) + 1) # first yanked line

(hey, shouldn't that be display.put_marker after?)
No, put_marker is defined in this module - put_cursor is in display module.

display_input_line()
# Call this function when cursor is already on open line, ready for input()

            wstart = wline(ed.dot+1)
            nlines = wlines - wstart
            update_lines(ed.dot+1, wstart, nlines) # move lines up

how about: update_below(ed.dot + 1)

We can't use update_below in open_line, but we can in display_d, display_y
and display_input_line.  That's enough - two would be enough.

 8 May 2023

We can have additional optional arg to update_below(bstart, offset=0)
Set offset to 1 in open_line.

We might separate edsel module out of frame.  In frame, retain the building
block fcns that don't depend on ed.  In edsel, define just the fcns that
are used for editing with sked.

Requires some revs in building block fcns.  Pass iline arg instead of
using ed.dot.   For update_status, pass in mesg arg instead of using
ed.status etc.

Oh, but don't those building-block functions use ed.buffer pervasively?
Well, we could pass in buffer arg - maybe call it lines - but that's 
a lot of revs and makes fcns less convenient to use from REPL.

Oh, but passing in buffer to use for frame fcns is essential for our 
timestamp demo - if we want to update in two windows at once.

Maybe we could be less ambitious and just use Python REPL while window
is updating from timestamp.

Let's just defer the whole demo problem.  Fix today's problems today.
Having global buffer etc. and few fcn args is what makes it easy to use
the fcns from the REPL - that's been our philosophy so far, let's keep it.

I do think it's a good idea to let mesg be an arg to update_status - we
are already doing that with our 'Appending...' mesg.

Revise frame to define update_below and use it throughout, including with
optional offset arg in open_line.

Do we want to define and use new update_window(bstart) to update whole window?
Define it right before update_below, and define both right after update_lines.
Must define wline *before* update_lines.

 9 May 2023

Tested all four uses of new update_below.  They all work, including open_line.

Jonathans-MBP:editors jon$ git commit -am 'frame: add update_below and call in open_line, display_d, display_y, display_input_line'
[inwindow d779e43] frame: add update_below and call in open_line, display_d, display_y, display_input_line
 1 file changed, 20 insertions(+), 19 deletions(-)
Jonathans-MBP:editors jon$ git push
...


Next define update_window and call in refresh, display_restore_buffer,
and open_line.

We notice display_restore_buffer ends with same code as recenter, except
it's missing update_status.  But then in sked, b() calls restore_buffer
then st().  We could merge st() into sked restore_buffer, and update_status()
into frame display_restore_buffer(), then frame display_restore_buffer()
could just call recenter() rather than several lines inline.  Morever,
we could remove st arg from sked b, k and frame display_b,_k.
(k also calls restore_buffer then st).

The only downside to this simplification is, we couldn't call restore_buffer
*without* update_status.  But when would we ever do that?

Are there any other uses of st arg in sked that could also be eliminated?
No, it looks like st arg is *only* used with b and k.  So I think we can do
that simplification.  BUT first just test with new update_window().  Done.

It looks like update_status is not clipping at col 80, but 81.  Full status
line wraps one char to next line.  It uses [:tcols+1] where tcols is 80.
I thought slice [:n] was not inclusive, only goes up to n-1.   But change
to :tcols.  Oh, :tcols+1 appears in four places!  Seems to work other places.
Leave it for now.  We only noticed this problem after calling update_window
in refresh.  Hmn, I recall seeing this in the window too.  Change them
all to [:tcols].  I think that is 80 char - indices 0..79.

Jonathans-MBP:editors jon$ git commit -am 'frame: define update_window, call in  refresh, open_line, display_restore_buffer
> bug fix, frame: change [:tcols+1] to [:tcols] to clip at 80 cols not 81'
[inwindow 4bdd648] frame: define update_window, call in  refresh, open_line, display_restore_buffer bug fix, frame: change [:tcols+1] to [:tcols] to clip at 80 cols not 81
 1 file changed, 11 insertions(+), 7 deletions(-)
Jonathans-MBP:editors jon$ git push
...


The name update_below looks wrong because it's not update-<noun> like the other
update functions.  update-bottom is update-<noun> - but it looks odd too.
Other nouns, synonyms: footer, trailer, follower, following, suffix, ...
Maybe update_after would work - after as nearly synonym for below.  
remainder, remaining, tail, end, rest ... ?  Maybe some typesetting term ...
Or maybe make it two words:  update_lines_below, _lines_after, _lines_following

What did I call it in version1?

10 May 2023

So st() is separate from restore_buffer() in b() and k() - we plan to merge it in.
What about other uses of st()?  In frame, update_status is included in 
display_set_saved, display_d,_y,_c, dislay_input_line.  So st() is already 
merged in to those.  Confirm that in sked.  display_e calls refresh via recenter,
which calls update_status.   Can we just use display_e for restore_buffer?

sked: Now call st() from restore_buffer, not b() and k().
Remove st= arg from b() and k().  Remove st() fcn - just use print inline.
frame: remove update_status arg from b() and k(), call from d_restore_buffer.
Test just that much - the removal of st() - before revising d_restore_buffer.
reload(sked) leaves old st() fcn still in the session.
Test: b() and k() still work in frame.  clr() then test both in sked to
confirm we still get printed status msg in repl.

Tests all work but we still want sked st() to use ad-lib at REPL.
Or, we can just type status().  That works!  If we want we can say st=status


We can put update_status right at the end of display_restore_buffer because,
in the cases where display_restore_buffer is called, that call is the last
line executed in b() or k().   BUT it is only called in *some* branches - some
paths through the code - in b() - so we still need to pass it as an arg.
BUT in k() it is called unconditionally as the last line - so couldn't we
just wrap k() and call display_restore_buffer after sked k() returns?

Review where there might be other cases like this, where we could eliminate
function args in sked fcn and just call the frame fcn after sked fcn returns. 
Oh, that wouldn't work because display_restore_buffer has code in it that
*substitutes* for code in sked restore_buffer.  So we can't pass it just to
b() but not k().   BUT are there any display fcns that are *only* called 
at the very end of the sked fcn?

Jonathans-MBP:editors jon$ git commit -am 'sked, frame: remove sked st() fcn and fcn args
> simplify display_restore_buffer, just call recenter'
[inwindow 01cfbb3] sked, frame: remove sked st() fcn and fcn args simplify display_restore_buffer, just call recenter
 2 files changed, 6 insertions(+), 17 deletions(-)
Jonathans-MBP:editors jon$ git push
...

Would it be simpler to just have do-nothing placeholders for display fcn args
in sked?  No, that wouldn't work because the display code runs both *before*
and *after* the substituted code.    For example, in display_move_dot, we 
have to erase the old marker *before* we reassign dot, then place the new 
marker *after* we reassign dot.   So it appears our present fcn arg scheme
is necessary.  BUT keep an eye out for any more cases like st() which are 
redundant and not needed.

In sked a(), first move_dot is not the first line and final move_dot_a is
not right before return, so we can't move those out of a() - they have to be
passed fcn args.

Even in sked e(), move_dot() is almost at the end but then there is a 
print statement.   So even there we couldn't just wrap sked.e in frame
and then call recenter.   Our present fcn arg scheme is best, quite versatile.

Do we really need print_nothing fcn and args?  Can't we just handle it
inline, like we did with st()? print_nothing is passed arg to display_p(), s()
But in p, printline (print or print_nothing) is called many times in a loop,
while move_dot is just called once at the end, so they can't be merged.
In s(), printline immediately precedes move_dot in the same block, so it 
seems they could be combined - but then we would have to define new frame fcn
for combined printline + move_dot because move_dot doesn't include printline.
So that's no simpler, leave it.

We're down to style changes.  Let's re-order the frame building block fcns for
better reading order:

in_window
wline 
locate_segment
update_lines
update_window
update_below
open_line
------------------ below are already in order
put_marker
update_status
refresh
recenter

I think that finishes the code!  Revise README.md to describe in-window a().

Jonathans-MBP:editors jon$ git commit -am 'frame: re-order functions to improve presentation
> README.md: explain revised frame append command: type text right in the window'
[inwindow f620a0e] frame: re-order functions to improve presentation README.md: explain revised frame append command: type text right in the window
 2 files changed, 59 insertions(+), 46 deletions(-)
Jonathans-MBP:editors jon$ git push
...

Is it time to merge inwindow branch back into ed?

Considering separating edsel (imports sked) out from frame (which would
no longer import sked).   Not sure yet.  But that would happen in ed branch, 
not inwindow.

12 May 2023

Jonathans-MBP:editors jon$ git commit -am 'editors/README.md: tweak formatting'
[inwindow 0f10aad] editors/README.md: tweak formatting
 1 file changed, 1 insertion(+), 1 deletion(-)
Jonathans-MBP:editors jon$ git push
...


Later committed and pushed another tweak.

Jonathans-MBP:Piety jon$ git checkout ed
Switched to branch 'ed'
Your branch is up-to-date with 'origin/ed'.
Jonathans-MBP:Piety jon$ git merge inwindow
Updating a488c6d..3cd10df
Fast-forward
 BRANCH.md         |   6 +-
 editors/README.md |  18 ++++-
 editors/frame.py  | 216 +++++++++++++++++++++++++++++++++++++-----------------
 editors/sked.py   |  25 ++++---
 4 files changed, 183 insertions(+), 82 deletions(-)
Jonathans-MBP:Piety jon$ git branch
* ed
  fparam
  inwindow
  master
  patch
  rewrite
  wrap
Jonathans-MBP:Piety jon$ git push -u origin ed
Total 0 (delta 0), reused 0 (delta 0)
remote: To https://github.com/jon-jacky/Piety
   a488c6d..3cd10df  ed -> ed
Branch ed set up to track remote branch ed from origin.

Then in github web interface I set branch to ed and confirm all the
pages look like the most recent versions in inwindow branch.  


Jonathans-MBP:Piety jon$ git commit -am 'BRANCH.md: merge inwindow branch back into ed branch'
[ed bdf8cd4] BRANCH.md: merge inwindow branch back into ed branch
 1 file changed, 3 insertions(+)
Jonathans-MBP:Piety jon$ git push
...

What next in the ed branch?  Possibilities:

- Separate edsel from frame.  Make frame usable as a library without ed:
  remove all references to ed. from frame.   Does that make it too complicated?

- Add in/outdent, wrap functions to sked and frame.  We need these to make
  sked/frame/edsel able to update our .md pages at github.

- Add essay on 'Program development in Piety' on our in-the-REPL method.

frame.py has assumption of just one window built in.  It's in the update_window
function, where update_lines wstart arg is hardcoded 1.  It should be wintop,
which is already defined in frameinit, initialized to 1.

Does adding a string arg to update_status - rather than hard-coding 
ed.status into the body - make it too complicated?

What frame fcns would require a new buffer arg?  We don't need to add it
to any of the command fcns, do we?  They can just refer to global ed.

ed.buffer appears in the bodies of these frame functions:
update_lines put_marker

But put_marker just uses ed.buffer to get first char on line
could change args to put_marker(char, iline, attribs).

open_line uses ed.S() - could pass buffer and use len(buffer).

update_status uses ed.status() - couldn't we just pass in a msg arg?

refresh(), recenter() use ed.dot - we could pass iline arg.

What would callers look like if we added these args?
We would have to add args to their callers in frame.py.
update_window and update_below call update_lines.  They
would need buffer arg.  Oh dear, this is starting to look ugly.

Why do we want buffer to be arg to frame again?  Demo requires it - 
we want to update window from source other than ed.buffer.
It might be many months til we get to that - leave it for now?
BUT it's not really a problem unless ed.... appear as args in command fcns
you call from REPL - isn't that right?  So maybe it's not too ugly.

BUT what's not yet clear is, what's the dividing line between
frame and edsel?  We initially though just the building blocks section is 
frame.  BUT what about display_d, display_y, display_c, maybe parts of
the three append fcns.  They all seem pretty generic.  Oh, not the a() fcns.

I'm leaning toward making a frame module with passed buffer arg, including
display_d, _y, _c.

Maybe open_line is just a special case of yank, yanking one empty line
instead of N lines of text.

Look ahead to how we will code in/outdent and wrap in sked, frame, edsel.

Another issue.  I was really surprised how much code it took to add
in-window append.   Was all that really necessary?  Was it worth it?

14 May 2023

Let's *not* add buffer as arg to frame methods.  We're committed to 
the everything-is-global style.  What's the point of making buffer
an arg if wintop, wlines are still global?   If we want to have more
than one window, then we will need something like save_,restore_window
analogous to save_,restore_buffer - to save and then reassign all the
pertinent globals.

If we recreate our version1 demo with two windows updating simultaneously,
then save_,restore_window will have to be part of each context switch.
Remember all the complication we had managing the cursor on context switch in
version1?  save_,restore_window will handle that.

How much code did we add to support in window append?

open_lines: lines 69 - 84, including 4 line comment header
append display functions: lines 210 - 262, including 6+5+8+8 lines comments 

So it took 67 lines, a bit over a page of code, including 31 comment lines -
almost half of the total - can that be right?  Looks like it.
So that's not too unreasonable.

frame.py is now 357 lines.   Github says (304 SLOC).  That includes what?

frameinit.py, github says 20 lines (15 SLOC).   It has 5 empty lines - 
so every non-empty line is counted.   The module has a 3-line block comment
at the top (including starting and ending """ lines) and 4 lines of #...
full line comments with # in col 1.   There are only 8 lines of Python 
statements in the file.  So this overcounts what I would call Python SLOC --
it includes Python block comments and full-line comments in the count.

frame.py 357 lines (304 sloc), frameinit.py 20 lines (15 sloc)

What are the line counts of the corresponing version1 modules?

textframe.py 135 lines (105 sloc)

frame.py 346 lines (302 sloc)

window.py 404 lines (346 sloc)

version1 handled multiple windows not just one but this is still much more code.

Also - compare 

sked.py 384 lines (343 sloc) + skedinit.py 28 lines (22 sloc)

What are the line counts of the corresponing version1 modules?

buffer.py 348 lines (305 sloc)

ed.py 587 lines (518 sloc)

The old ed supported more commands, but this is much much more code.

Then the old ed.py command line interpreter also used

parse.py 180 lines (166 sloc)

check.py 96 lines (81 sloc)


17 May 2023

Let's leave frame module as it is for now.  Any scheme for
separating frame from ed involves adding complexity and code --
the two alternatives are 1.) adding buffer arg to frame fcns (but
also other args?  iline for ed.dot, msg for ed.status() )
and 2.) continuing to use global vars but assigning the globals -
so ed.buffer would be assigned to frame.buffer etc.

I will change the module *name* from frame to edsel - the name of the editor.

Then add functions in/outdent and wrap - needed to edit our commonplace
book etc.

19 May 2023

Jonathans-MBP:editors jon$ git commit -am 'edsel, edselinit, README: rename frame to edsel, frameinit to edselinit'
[ed a009803] edsel, edselinit, README: rename frame to edsel, frameinit to edselinit
 3 files changed, 27 insertions(+), 19 deletions(-)
 rename editors/{frame.py => edsel.py} (96%)
 rename editors/{frameinit.py => edselinit.py} (91%)
Jonathans-MBP:editors jon$ git push
...

Jonathans-MBP:editors jon$ git commit -am 'BRANCH.md: rename frame to edsel, start format branch'
[ed 712b2ae] BRANCH.md: rename frame to edsel, start format branch
 1 file changed, 6 insertions(+)
Jonathans-MBP:editors jon$ git push
...

Jonathans-MBP:editors jon$ git branch format
Jonathans-MBP:editors jon$ git checkout format
Switched to branch 'format'
...
Jonathans-MBP:editors jon$ git commit -am 'BRANCH.md: update for new format branch'
[format 2be3cdb] BRANCH.md: update for new format branch
 1 file changed, 2 insertions(+), 1 deletion(-)
Jonathans-MBP:editors jon$ git push origin format
...
To https://github.com/jon-jacky/Piety
 * [new branch]      format -> format

Jonathans-MBP:editors jon$ git commit -am 'sked, skedinit: add indent, outdent, no display code yet'
[format 037da64] sked, skedinit: add indent, outdent, no display code yet
 2 files changed, 29 insertions(+), 1 deletion(-)
Jonathans-MBP:editors jon$ git push
...

To display indent/outdent we could just use display_c, with move_dot
inside the loop.  But that's wasteful in several ways.

The display code should just be a trivial call to update_lines(start, end)
but we are substituting for move_dot(iline) which just has one arg, which
happens to be end.  We can't assume start is dot.   I think we need
new placeholder fcn, change_lines(start, end), then display_change_lines in
edsel.

Jonathans-MBP:editors jon$ git commit -am 'sked, edsel: add change_lines to display indent, outdent'
[format c8d33a6] sked, edsel: add change_lines to display indent, outdent
 2 files changed, 26 insertions(+), 4 deletions(-)
Jonathans-MBP:editors jon$ git push
...

20 May 2023

Look up textwrap in doc in our local Python:

file:///Library/Frameworks/Python.framework/Versions/3.9/Resources/English.lproj/Documentation/index.html

Bug, indent(0,3) treats 0 like None - so it defaults to dot.

>>> sked.buffer[1:4]
['line  1\n', 'line  2\n', 'line  3\n']
>>> indent(1,4)
>>> sked.buffer[1:4]
['    line  1\n', '    line  2\n', '    line  3\n']

>>> import textwrap as tw
>>> tw.wrap(sked.buffer[1:4])
...
AttributeError: 'list' object has no attribute 'expandtabs'

Right, tw.wrap expects a string, not a list of string

>>> string14 = ''.join(sked.buffer[1:4])
>>> string14
'    line  1\n    line  2\n    line  3\n'
>>> tw.wrap(string14, width=7)
['line  1', 'line  2', 'line  3']
>>> slist14 = tw.wrap(string14, width=7)
>>> slist14
['line  1', 'line  2', 'line  3']
>>> snlist14 = [ s + '\n' for s in slist14 ]
>>> snlist14
['line  1\n', 'line  2\n', 'line  3\n']
>>> slist14 = tw.wrap(string14, width=12,subsequent_indent=sked.lmargin*' ')
>>> slist14
['    line  1', '    line  2', '    line  3']

We coded sked and edsel.  Use edsel display_y to replace sked wrap move_dot.
sked wrap assigns sked yank so display_y can use it - it only uses the
*length* of yank.  In this case yank holds the wrapped text.
If we passed start instead, we wouldn't need to assign yank.  BUT then
we would need a new fcn in edsel only slightly different from display_y.

New wrap seems to be working
use new sked/edsel wrap command on all the unwrapped text added since
about 1 Feb 2023

Jonathans-MBP:piety jon$ git commit other.txt -m 'use new sked/edsel wrap command on all the unwrapped text added since about 1 Feb 2023'
[master 61a8190] use new sked/edsel wrap command on all the unwrapped text added since about 1 Feb 2023
 1 file changed, 403 insertions(+), 110 deletions(-)

Next try fixing in recent home/*.txt.   In commonplace.txt:

 start=o()
 ...
 end=o()
>>> start
20
>>> end
116
>>> indent(start,end,2)

That's the most recent post, the Weizenbaum quote.  WE see it adjust
on the screen.

Jonathans-MBP:home jon$ git commit -am 'commonplace: fix indentation most recent post, 14 Mar 2023 Weizenbaum'
[gh-pages ad8de9d] commonplace: fix indentation most recent post, 14 Mar 2023 Weizenbaum
 2 files changed, 192 insertions(+), 192 deletions(-)
Jonathans-MBP:home jon$ git push
...

Next we can indent the several most recent posts in computing.txt.

Jonathans-MBP:editors jon$ git commit -am 'sked, edsel: wrap function and display working'
[format c84b843] sked, edsel: wrap function and display working
 3 files changed, 41 insertions(+), 6 deletions(-)
Jonathans-MBP:editors jon$ git push
...


21 May 2023

Use wrap(start) with end default to dot and lmargin, rmargin default to 
2, 78 to refomat two most recent entries in computing.txt


22 May 2023

Jonathans-MBP:home jon$ git commit -am 'computing: indent Weizenbaum and Oblique Strategies entries
> add two more short entries on programming method'
[gh-pages da7d674] computing: indent Weizenbaum and Oblique Strategies entries add two more short entries on programming method
 2 files changed, 271 insertions(+), 191 deletions(-)
Jonathans-MBP:home jon$ git push
...

Jonathans-MBP:home jon$ python3 diary2md.py  < design.txt > design.md
Jonathans-MBP:home jon$ git commit -am 'design: wrap and fix indentation in recent entries'
[gh-pages 55e1170] design: wrap and fix indentation in recent entries
 2 files changed, 18 insertions(+), 14 deletions(-)
Jonathans-MBP:home jon$ git push
...

23 May 2023

Add join lines j() to sked and edsel.  Try move_dot=display_d edsel j().
Doesn't quite work because it doesn't display the newly joined line at dot.
It does move up the lines below dot as it should.
Right, in display_d, dot is the line *preceding* the deletion so it is 
not updated.

Is there some other display_x in edsel that will just work?
It is easy enough to define a new one for j(), but that seems 
a bit much - is it really necessary?  Not sure, but just define display_j().

Done.  Wrap six lines on the last page, confirm lines below move up and
leave empty space to the end of the window.

Jonathans-MBP:editors jon$ git commit -am 'sked, edsel: add j(oin lines)'
[format 2edb0de] sked, edsel: add j(oin lines)
 2 files changed, 26 insertions(+), 2 deletions(-)
Jonathans-MBP:editors jon$ git push
...


24 May 2023

Use j() to add entries to precursors.md.  Type in each column entry
on its own line, then j() to make one long line.
Then wrap() to fit the long line on several lines for editing, then
j() again.  After j(), wrap(), j() we see j() is putting
in unnecessary spaces.  Instead of harcoding ' ' separator maybe we
should add optional separator arg, default to ' ', could optionally use ''.

Jonathans-MBP:doc jon$ git commit -am 'precursors: add Dusk OS'
[format 9d1289d] precursors: add Dusk OS
 1 file changed, 1 insertion(+)
Jonathans-MBP:doc jon$ git push
...

precursors.md is markdown so the unecessary spaces do not appear 
on the page.

In precursors.md, replace "Native OS" by "Hosted" throughout, using
grep() then c().   

Jonathans-MBP:doc jon$ git commit -am 'precursors: replace "Native OS" with "Hosted"'
[format afac2c0] precursors: replace "Native OS" with "Hosted"
 1 file changed, 28 insertions(+), 28 deletions(-)
Jonathans-MBP:doc jon$ git push
...

It worked very well.  I've been wanting to do that for ages but was
afraid I might mess it up.

Next in precursors, add Tuplip Creative Computer and EGOS.
TulipCC done, also Circuit Python on RPi.  EGOS next.

In utilities, add Julia Evans' DNS and TLS.

26 May 2023

Circuit Python on RPI, EGOS (actually egos-2000) and Julia Evans' DNS done.
Evans' TLS is in Go, not Python, so not included.

27 May 2023

Jonathans-MBP-4:editors jon$ git branch
  ed
* format
...
Jonathans-MBP-4:editors jon$ git checkout ed
Switched to branch 'ed'
Your branch is up-to-date with 'origin/ed'.
Jonathans-MBP-4:editors jon$ get merge format
-bash: get: command not found
Jonathans-MBP-4:editors jon$ git merge format
Updating 712b2ae..6812d6c
Fast-forward
 BRANCH.md           |  3 +-
 doc/precursors.md   | 60 +++++++++++++++++++++-------------------
 doc/utilities.md    |  6 +++-
 editors/edsel.py    | 30 ++++++++++++++++++++
 editors/sked.py     | 79 ++++++++++++++++++++++++++++++++++++++++++++++++++++-
 editors/skedinit.py |  2 ++
 6 files changed, 149 insertions(+), 31 deletions(-)
Jonathans-MBP-4:editors jon$ git push origin ed
Total 0 (delta 0), reused 0 (delta 0)
remote: To https://github.com/jon-jacky/Piety
   712b2ae..6812d6c  ed -> ed

Confirm all the recent work in the format branch - wrap() and j() -
is now in the ed branch.  Edit BRANCH.md.

Jonathans-MBP-4:editors jon$ git commit -am 'BRANCH.md: merge format branch back into ed branch'
[ed d942ff8] BRANCH.md: merge format branch back into ed branch
 1 file changed, 4 insertions(+), 2 deletions(-)
Jonathans-MBP-4:editors jon$ git push
...

There are two obvious next steps for the editor:

1. pmacs: invoke editor functions with emacs keycodes so you don't have
to invoke the functions from the Python REPL.  

This can be a minimal, contained revision: invoke pmacs with C() a la
old DEC EDT, exit pmacs with ^Z again like EDT.   While pmacs is running,
editor responds to emacs C- and M- keycodes, which simply invoke our
existing sked and edsel functions.

We will continue to add text with the existing a(ppend) command, using
Python input() with readline so pmacs doesn't need to provide in-line editing.
In pmacs, simply type RET to open a line and enter append mode.

First pmacs won't do any prompting for text, so no e b s r c commands.
Later we might add prompting/reading text.

It should be possible to add pmacs without changing any existing code,
other than adding the C() function to sked.

2. windows: add commands to split window, move to other window, return
to a single window.  

Can we do this without changing any existing code?  
Will we need to add the current window's buffer to the edsel global data?
Maybe not, changing window might just invoke sked restore_buffer.

Separating a new frame module out of the edsel module might be part of
the windows project.

After pmacs and windows, we could go on to tasking, and reproducing
the timestamp tasking demo.    That requires two big changes:

1. Replace built-in Python REPL with non-blocking REPL.   Requires
writing a new non-blocking readline, something like version1 console
module but much much simpler, and reviving our pysh callable Python 
interpreter.

1a. Non-blocking readline could be generalized to editline - edit an
existing line - and incorporated into pmacs to make a full-screen 
display editor so we could edit any line, not just the one line currently
being appended.

But 1a. is optional and is not on the path to tasking.

2. Building cooperative multitasking with Python 3 async.  
Must learn about all the new Python 3 async stuff.

Build the non-blocking REPL first so we can experiment with async
and tasking from the (new non-blocking) REPL, with tasks' activity
visible in editor windows.

Google pmacs finds Penn Medicine Academic Computing Services.
and a few other obscure things.   Google pmacs editor gets
'Did you mean emacs pics jmacs ymacs?'  So I think pmacs is
available - there is not already another pmacs emacs-like editor.
jmacs is the emacs mode of the JOE editor (native JOE emulates Wordstar).
There is also a hit for a jmacs javascript editor - a name analogous
to pmacs, good https://github.com/bennoleslie/jmacs.

ymacs is an emacs-like editor for the web. https://github.com/mishoo/ymacs

Is there a pmacs at Github or PyPI?

https://github.com/tom-seddon/bin/blob/master/pmacs.py
is a command-line tool for sending stdin to emacs, so 
you can use emacs as the target for pipes.  It's *not* an
emacs-like editor in Python, it's just a command line utility
that happens to be written in Python.
See https://github.com/tom-seddon/bin for explanation.

At PyPI we find https://pypi.org/project/pmacs/
'Python editing MACroS'
'The author of this package has not provided a project description'

Fine. Let's go ahead with the pmacs name.

Jonathans-MBP-4:editors jon$ git branch pmacs
Jonathans-MBP-4:editors jon$ git checkout pmacs
Switched to branch 'pmacs'

...

Jonathans-MBP-4:editors jon$ git commit -am 'BRANCH.md: make pmacs branch'
[pmacs 8ecd047] BRANCH.md: make pmacs branch
 1 file changed, 6 insertions(+), 1 deletion(-)
Jonathans-MBP-4:editors jon$ git push origin pmacs
...
To https://github.com/jon-jacky/Piety
 * [new branch]      pmacs -> pmacs

Jonathans-MBP-4:editors jon$ git commit -am 'add pmacs.py, invoke editor functions with emacs keycodes'
[pmacs 34ca9c1] add pmacs.py, invoke editor functions with emacs keycodes
 2 files changed, 6 insertions(+)
 create mode 100644 editors/pmacs.py
Jonathans-MBP-4:editors jon$ git push
...

The first pmacs codes will be C-n C-p C-v M-v for moving around the buffer.
Those don't require prompts.  I think we will want C-s C-r search commands
next, which do require prompts.

Jonathans-MBP-4:writing-1980s jon$ git commit index.html -m 'index.html: add first link, to Strategic Computing chapter'
... then push ...

31 May 2023

For pmacs, initially support only single-character commands, that is 
the C- keycodes, but no M- keycodes (which require two characters, 
esc and the key).

We can do a lot with just C- keycodes.  for M-v page down use C-(what?)
unfortunately C-v and C-V are the same character.  Check list of emacs keycodes
to find one which is little used, that we can use for page down.


 1 Jun 2023

We can't really call it pmacs if we don't support the M- commands,
and if we reassign traditional emacs C- commands to different commands.

Review version1 code, maybe it's not so bad.  What do we need?

We already have Piety/unix/terminal.py with set_char_mode, set_line_mode,
getchar.

We have old Piety.version1/console/getkey, which defines GetKey class
with self.prefix attribute and __call__ method.

Let's keep getkey, but get rid of the class - that adds nothing.
We'll just have a getkey module with the getkey function and the 
module-level variable prefix.

But - where to put this module?   We won't have a console dir, 
should it go in editors or vt_terminal?   It's rather pmacs specific,
let's put it in editor.

Nomenclature: see GNU Emacs Manual, 6th ed. 1987, sect 2.2.
Key sequences are called keys for short.

BUT this time let's not call terminal.getchar from getkey - that
tangles up event handling with key sequence collection.  The
raw character should be an arg passed to 'getkey' - which we
might rename?

pmacs will call terminal.getchar and pass it to getkey.
I could have tried this in version1.  In fact I might try that
when I start experimenting with async again.

so getkey module belongs in editor/    I think it is platform-independent - 
it only names the keys by their symbolic names in the key module, now
in vt_terminal/key.   key.py also has the ASCII codes for keys and control
characters, so it belongs in vt_terminal.   Another platform might use
keyboard scan codes or something else.   Likewise, display.py includes
ASCI codes and ANSI escape codes so it too belongs in vt_terminal.

Revise getkey to be fcn not class + method.  getkey no longer calls
terminal.getchar, instead single character is passed to new getkey(c).

I can already tell I don't like the name getkey for this new fcn.  
keyseq would be better.  k = getkey(c) looks wrong, k = keyseq(c) is better.

First rerun test in version1/console/getkey.py main().

Jonathans-MBP-4:console jon$ python3 -i getkey.py
> abcde
[['a'], ['b'], ['c'], ['d'], ['e'], ['\r']]
>>> ^D
Jonathans-MBP-4:console jon$ python3 -i getkey.py
> (type C-a C-b C-c M-d M-e M-f) 
[['\x01'], ['\x02'], ['\x03'], [], ['\x1b', 'd'], [], ['\x1b', 'e'], [], ['\x1b', 'f'], ['\r']]
>>> ^D
Jonathans-MBP-4:console jon$ python3 -i getkey.py
> (type up arrow, down arrow, left arrow, right arrow) 
[[], [], ['\x1b', '[', 'A'], [], [], ['\x1b', '[', 'B'], [], [], ['\x1b', '[', 'D'], [], [], ['\x1b', '[', 'C'], ['\r']]
>>> ^D
Jonathans-MBP-4:console jon$ python3 -i getkey.py
> (type esc, C-g) 
[[], ['\x07'], ['\r']]
>>> ^D

Now try the same tests. with our new getkey. Type in the same tests.

Jonathans-MBP-4:editors jon$ python3 -i getkey.py
> abcdef
[['a'], ['b'], ['c'], ['d'], ['e'], ['f'], ['\r']]
>>> ^D
Jonathans-MBP-4:editors jon$ python3 -i getkey.py
> 
[['\x01'], ['\x02'], ['\x03'], [], ['\x1b', 'd'], [], ['\x1b', 'e'], [], ['\x1b', 'f'], ['\r']]
>>> ^D
Jonathans-MBP-4:editors jon$ python3 -i getkey.py
> 
[[], [], ['\x1b', '[', 'A'], [], [], ['\x1b', '[', 'B'], [], [], ['\x1b', '[', 'D'], [], [], ['\x1b', '[', 'C'], ['\r']]
>>> ^D
Jonathans-MBP-4:editors jon$ python3 -i getkey.py
> 
[[], ['\x07'], ['\r']]

Rename getkey.py .md and the fcn to keyseq.  Test keyseq as above.


 2 Jun 2023

Maybe keyseq should go in vt_terminal.  It reveals that the M- keys 
are key sequences staring with esc, and that the arrow keys are 
ANSI escape sequences beginning with esc-[.

The old version1 edsel keymap table from keys to methods has M-... codes
and even combinations like C_x + 'o' but does not mention esc, [, csi
or any \x... hex codes.

On other platforms the M- keys might not be esc sequences so keyseq belongs
in vt_terminal.

Jonathans-MBP-5:editors jon$ git commit -am 'pmacs: first draft working with C_n C_p C_v M_v
> keyseq.py .md move from editors/ to vt_terminal/, explain why in keyseq.md'
[pmacs 5256aa3] pmacs: first draft working with C_n C_p C_v M_v keyseq.py .md move from editors/ to vt_terminal/, explain why in keyseq.md
 3 files changed, 47 insertions(+), 9 deletions(-)
 rewrite editors/pmacs.py (86%)
 rename {editors => vt_terminal}/keyseq.md (71%)
 rename {editors => vt_terminal}/keyseq.py (97%)
Jonathans-MBP-5:editors jon$ git push
...

We need to rename pmacs module or pmacs function.  From pmacs import pmacs
so we can use pmacs without prefix masks pmacs module name so reload(pmacs)
doesn't work.   I like the pmacs function name so we need to rename the module.

 3 Jun 2022

Keep pmacs.py but rename the fcn to pm().

Add more keys to pmacs.  key.cr: edsel.a *almost* works - it works until
. to exit append mode.  We don't get back to >>> prompt - instead 
control keys echo in REPL as ^C etc. but without effect.

Did we just neglect to set_line_mode, set_char_mode?   Try it.  It works!

add C_x + C_s : write file.  It works, then writes pmacs.py, 54 lines - 
but then an LF without a CR.   But subsequent emacs keys work.  So it's OK.

Now we have all the emacs keys that can work with sked+edsel without prompts.
So the next step is to support prompts for search commands s r   
and file/buffer commands e b.

Then we will have almost all the functionality of sked/edsel in pmacs.
The only really essential thing - without which we cannot edit - is 
the c(hange), that is, substitute command.   I suppose we can provide that
with *two* prompts, for search string and replace string.  

Or, we could
implement M-x to enter and run one Python statement and then return to pmacs.
BUT that means importing the callable Python interpreter - that's a big 
addition.

Another thing we'll want is to repeat s r searches *without* the prompt - 
keep track of the previous command.

Another thing is to set mark so C-w and M-q can work on regions not
just single lines.   I think that means adding new sked.mark variable,
which is set to None if C-w and M-q should just work on current line.
Probably should set mark = None initally and after each use of mark,
unconditionally in body of new pmacs wrapper fcns invoked by C-w and M-q.
We should add new wrappers, like our append() wrapper, *not* change sked 
fcns.  So, mark variable can live in pmacs.py, just init to None, then 
reloads will re-init it which is fine.


Do we need M-x at all?  We already have C-z to get back to REPL.
Typing pm() to return to pmacs is not too bad.   To make pm() unnecessary,
we have to bring in the callable interpreter, a big deal.  Seems not worth it.

Jonathans-MBP-5:editors jon$ git commit -am 'pmacs: implement all key commands that dont require prompt and text entry
> pmacs: change function name pmacs to pm, different from module name
> vt_terminal/keyseq: remove redundant comments from header'
[pmacs a72afca] pmacs: implement all key commands that dont require prompt and text entry pmacs: change function name pmacs to pm, different from module name vt_terminal/keyseq: remove redundant comments from header
 2 files changed, 27 insertions(+), 9 deletions(-)
Jonathans-MBP-5:editors jon$ git push
remote: Invalid username or password.
fatal: Authentication failed for 'https://github.com/jon-jacky/Piety/'

Grrr... I've been getting email from github bugging me about this.

 4 Jun 2023

I click on email to renew token.  It gives me this one:

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

This token expires on Sat, Sep 2 2023.

scopes is repo, not all the other stuff.

click [Update token]

" Personal access tokens (classic) function like ordinary OAuth access tokens. They can be used instead of a password for Git over HTTPS, or can be used to authenticate to the API over Basic Authentication."



So how do I use this to git push?

Jonathans-MBP-5:editors jon$ git push
Username for 'https://github.com': jon-jacky
Password for 'https:jon-jacky@github.com': (paste in that long token here) 
Counting objects: 6, done.
Delta compression using up to 4 threads.
Compressing objects: 100% (6/6), done.
Writing objects: 100% (6/6), 1.40 KiB | 0 bytes/s, done.
Total 6 (delta 4), reused 0 (delta 0)
remote: Resolving deltas: 100% (4/4), completed with 4 local objects.
To https://github.com/jon-jacky/Piety
   5256aa3..a72afca  pmacs -> pmacs

it apparently worked.  Yes, the latest versions are at github, all is well.

Later.  Start work on prompts.  pm() needs to set scroll one line less 
to make 1-line prompt region below frame, then set it back on exit.
Oh dear, when we change frame size with win() the scrolling region 
will not follow.  Well, we can just C-z to exit pmacs then pm() again
to reset it - that will be fine.

Coded prompt line and C_s : fwd_search.  Now when I C_z then reload(pmacs),
I immeidately get search: on the prompt line -- !?
Try typing some other command besides reload() after C_z.  Then try
reload(...) other modules besides pmacs.

 5 Jun 2023

reload(edsel) doesn't invoke search:  In pmacs.py keycode table,
we have C_s : fwd_search() - it calls it - get rid of final ()

Now C_s does prompt for search string then RET sends marker to 
that string - but keys after that just echo as ^P or whateverin
scrolling region.   I think we need to switch in/out of line
mode as we did for append.  Yes, that fixed it.

Now we need to put default in search prompt and clear the rest of the line.
Then we can handle repeated C_s keys so it only prompts on the first one.
Then support C_r, factor out code common to both.  Done.

Add C_x + 'b' : switch_buffer.  works.  BUT we realize we can't 
cancel a prompt with ^G because request() sets line mode then 
calls std lib input().   If you type ^G to input it doesn't return.

What about ^C ?

What should key for replace be?  In emacs there is M-x replace-string
RET string RET newstring RET - so it's not a single keycode at all

M-% is query replace: M-% string RET newstring RET
We can use that for our non-query replace.

Jonathans-MBP-5:editors jon$ git commit -am 'pmacs: add find file, write named file, kill buffer'
[pmacs f817400] pmacs: add find file, write named file, kill buffer
 1 file changed, 11 insertions(+)
Jonathans-MBP-5:editors jon$ git push
...

Previously we committed switch buffer and replace string.

All we have to do now is add C_space to set mark, then 
use range mark:dot inclusive to define C_w cut, also 
use range in M_q wrap, add keys for indent/outdent

 6 Jun 2023

I have switched to using pmacs for editing source code and these notes.
I now notice that delete (kill) line, C-k, is not nearly as convenient
as real emacs.  In pmacs, kill puts the cursor at the line *above* the 
deleted line, while in emacs, it puts it *below* the deleted line.  So
in emacs you can easily delete a sequence of lines from top to bottom,
just type C-k repeatedly in place, 
but to do that in pmacs you have to use C-n each time to move to the 
next line to delete.
Also, in emacs a sequence of killed lines is added in sequence to the 
yank buffer, so it's easy to use a sequence of C-k followed by a move 
then one yank C-y to move several lines without setting the mark and
using cut C-w.

To change sked/edsel to work this way might not be so easy.  We 
have to move cursor to line *after* (not before) deleted line(s),
but also must ensure that C-k followed by C-y restores the original
state.  That means C-y must insert *before* dot and leave dot at the
last yanked line.  But then repeated C-y wouldn't just repeat the 
text.  How does emacs do it?

emacs C-k leaves an empty open line where the deleted line was.
It leaves dot at the newly empty opened line.
Then to get rid of that open line, you have to C-k again,
to close the line and move the following lines up.
After C-k, C-y just replaces the deleted line in the open line again
and leaves dot there.  So it does restore the same state.

We should fix pmacs to work like this - it's more convenient and makes sense. 
It will require a branch of its own.  Let's finish current work first:
setting mark and using it for C-w also wrap and indent.  Then merge,
then go back and fix C-k.

Set mark is easy.  BUT we also need to decide what happens to mark 
after subsequent C-y.  I think C-y should cancel mark so C-w with 
no mark just cuts the current line, like C-k.

In emacs, C-w with no mark, or mark on the same line, does nothing.
C-w removes mark line down to line *before* dot, so dot is not cut.
C-y leaves dot after the last pasted line, so C-w followed by C-y
restores the state before.

How does C-w C-y relate to C-k C-y ?

A bit more thought reveals the emacs way where C-k opens a line
doesn't work with our append-oriented editor.
We can't have C-k put you into append mode - how do you get out?
Once you are in append mode you are in line mode can can't see C-...
characters anymore.

However, we can fix it so C-k moves dot to line *after* deletion,
not before.  Then C-y leaves dot at line after insertion.   
So C-k C-y leaves buffer in same condition, but it also advances dot --
that's okay.

Aside - I notice with pmacs, echoing changed lines from M-% adds lots of
of noise in the scrolling command region - let's eliminate it.

 8 Jun 2023

Jonathans-MBP-5:editors jon$ git commit -am 'sked, edsel: suppress printing in c() (change) when display is active'
[pmacs 5f675c1] sked, edsel: suppress printing in c() (change) when display is active
 2 files changed, 4 insertions(+), 3 deletions(-)
Jonathans-MBP-5:editors jon$ git push
...

Later ....   use key.C_at to set mark, C_space on some terminals 
does the same thing.

Jonathans-MBP-5:editors jon$ git commit -am 'pmacs: add set mark, cut, exchange mark and dot'
[pmacs fb2a42b] pmacs: add set mark, cut, exchange mark and dot
 1 file changed, 33 insertions(+)

No push yet, I'm not on the net.

Later - add range() function.  Haven't yet pushed.

We see mark doesn't move with yank - we want mark to be first yanked
line, so we could C-w again to move again.

Where does emacs mark go when we cut?  It goes to dot.  
In emacs, when mark = dot, C-w has no effect.  BUT after ^Y,
mark goes to first pasted line and dot goes to line after paste,
so ^W cuts the same chunk of text again.

Trying to fix this now is a mess.  Don't do any adjustment of 
mark - just reassign mark manually as needed.

Jonathans-MBP-5:editors jon$ git commit -am 'pmacs: add range fcn, use in cut'
[pmacs c669738] pmacs: add range fcn, use in cut
 1 file changed, 5 insertions(+), 1 deletion(-)
Jonathans-MBP-5:editors jon$ git push
...

This should push the earlier commit also.  Yes, appears at github.

We wrote out pmacs.py after backing out fix to move mark on yank,
but forgot to reload(pmacs) then from pmacs import pm.   Then
mark appears in the right place after each of multiple succesive paste!
BUT does C-w cut work correctly?

 9 Jun 2023

Lost some notes by exiting editor with >>> ^D before saving notes.txt.
We finished adding pmacs keys.

Jonathans-MBP-5:editors jon$ git commit -am 'pmacs: add wrap, join, indent, outdent
> key: add M_carat for pmacs join
> keyseq: add prefix C_c for pmacs indent, outdent'
[pmacs 8b17c21] pmacs: add wrap, join, indent, outdent key: add M_carat for pmacs join keyseq: add prefix C_c for pmacs indent, outdent
 3 files changed, 37 insertions(+), 11 deletions(-)
Jonathans-MBP-5:editors jon$ git push
...

All that's left is to fix C_k C_w to put dot after deletion, not 
before, and C_w to paste before dot not after.  That sounds easy,
but what will it do to graphics?

When that's working, fix so successive C_k add each line to yank buffer.

10 Jun 2023

After reload, do we really have to 'from pmacs import pm' ditto for 
sked and edsel?   Yes, for sked and edsel, to get *new* functions into REPL.
BUT are already existing functions reloaded at the same addresses?
Let's just change message for w() 

>>> w()
sked.py, 462 lines
>>> sked.w
<function w at 0x105a16d30>

>>> c("f'","f'Wrote ")
>>> w()
sked.py, 462 lines
>>> reload(sked)
>>> sked.w
<function w at 0x105a16ca0>

It has moved

>>> sked.w()
Wrote sked.py, 462 lines

That's the new version

>>> w()
Wrote sked.py, 462 lines

That's also the new version!  BUT ...

>>> w
<function w at 0x105b294c0>

That's another address.

So apparently we don't have to from sked import * after reload(sked)?
I don't understand why it works.  

We're trying to make pm so we never have to revert to REPL -
make keys for all commands.  Can we make a command for
reload(<module for current buffer>)

I looked in printed emacs manual to see if there was a keycode
for that - there isn't really - 

22.4 p. 162 has M-x eval-current-buffer for Lisp, that is nearest
to reloading the current module.


11 Jun 2023

I think I lost some ealier notes from today somehow...
Most of the information is in the commit msgs yesterday and today.

While editing home/computing.txt, two weirdnesses:

1.  Somehow we got out of pm() back to REPL - ^X^F echoed
in REPL, but then type RET and it did prompt for filename
on prompt line.

1a. C_z caused exit from Python, or maybe put it in background.
We must have been out of pm() back in REPL.    C_z was maybe
a poor choice since it also means something at the REPL.
How about M-x instead?

Maybe we get popped from pmacs back to REPL by failure of 
a prompte command?  Like if we try to load nonexistent file?
Code is supposed to check for this, not crash...
But I think crash pops us out of pmacs back to REPL.

2. M-^  wrapped whole buffer from the top to dot.  As if 
mark was line 1.  Maybe that's default after reload?  We
have to be careful about reloading pmacs - really we need pmacsinit
just like skedinit and edselinit.   BUT ALSO we need to make
sure we don't use invalid or stale mark.  Maybe revive mark=None?

Yes, and range() returns start == end == dot when mark is None.
And every fcn that uses mark - that is, every pmacs fcn that
calls range() - also sets mark = None again.  I think that would
fix it.  Or when mark == None, call f()
with no args to force f to act only on dot, only call f(start,end)
when mark != None.

Later, read in the emacs manual.  There is both mark and mark active.
Mark can be present but inactive.   Inserting text puts mark at start
of inserted text, but inactive.   Any action that inserts text makes
mark inactive. C-x C-x  activates inactive mark.  C-g de-activates
active mark.

We have to be careful not to turn this mark into a big thing.
We really just want it for a few operations - Cant' C-spc set it
*and* activate it, and those few operatons deactivate it?  How
about mark == 0 means deactivated?  When mark is deactivated,
C-w etc just act on dot, not a range.

Jonathans-MBP-4:editors jon$ git commit -am 'pmacs: add in_region and call for M_q wrap
> add pmacsinit.py and load from pmacs.py on the first import only, not reloads
> use M_x not C_z to exit from pmacs to REPL.  M_x is like emacs do command.'
[pmacs 1f0bd2c] pmacs: add in_region and call for M_q wrap add pmacsinit.py and load from pmacs.py on the first import only, not reloads use M_x not C_z to exit from pmacs to REPL.  M_x is like emacs do command.
 3 files changed, 33 insertions(+), 10 deletions(-)
 create mode 100644 editors/pmacsinit.py
Jonathans-MBP-4:editors jon$ git push
...

Next: call in_region for the other fcns that can work on regions, 
and delete range().

Then add maringalia "I don't know how to program" to top of home/computing.
That's more exercise for M-q wrap.

Then handle consecutive C-k -> append to yank buffer.

Somewhere in there, add ...??? to cancel pmacs prompt - ^G won't work
in input(), right?

We noticed that typing C-z in append mode interrupts session - apparently
puts python in the background?  Try getting out just by typing fg, then
maybe refresh() - or maybe just C-l.

I seem to recall some of the weirdness with echoing not executing ^P etc.
occurs after a prompt - like the terminal does not return to char
mode after the prompt.  Like request() does not return properly - ?
Because input(prompt) fails or ... ?

13 Jun 2023

Again, I lost some notes from today - must have forgot to save before restart.

Jonathans-MBP-4:editors jon$ git commit -am 'pmacs: use in_region to handle fcns with mark and dot'
[pmacs 959ad4d] pmacs: use in_region to handle fcns with mark and dot
 1 file changed, 7 insertions(+), 44 deletions(-)
Jonathans-MBP-4:editors jon$ git push
...

We notice we get into control keys in line mode after this query 
from sked:

>>> edsel.indent()
>>> pm()
lines40.txt has unsaved changes, type y to kill anyway: y
^X^F

Here I have to type RET after ^X^F.  But then we get Find file: prompt
on regular promptline, and it works.

Next: consecutive C-k append to yank buffer.  Now C-k does advance to
the next line as it should, but after a series, C-y just pastes last line.

Now sked d() handles updating yank buffer, but only pmacs knows if 
prev_k was C_k.  

Now pmacs C_w calls in_region(edsel.d) but C_k just calls edsel.d.
I think the solution is to define a *new* edsel fcn just for pmacs C_k.
What to call it?  We already used k() for kill buffer.  I guess kill().

Maybe better - add an optional arg to sked d() that appends to
yank buffer instead of rewriting it.  Then pmacs can do the logic
to call d() with or without this argument.

Aside - we shouldn't call this pmacs, save pmacs for the version 
that doesn't depend on input() and append mode.   This needs a 
more self-deprecating title: lame-macs or something.  How about dmacs,
that is D-macs, grade D - macs, or mabye cmacs for C- macs - nah, C
has other connnotations.  Or fmacs for Fail - macs, or lmacs for Lose - macs.
I like dmacs or fmacs because it's close to emacs  D for grade D or Dumb.
F for grade F or Fail.

Done. Google and PyPI don't turn up any close dmacs.

Jonathans-MBP-4:editors jon$ git commit -am 'rename pmacs to dmacs, dumb emacs or grade D emacs'
[pmacs 5955bb0] rename pmacs to dmacs, dumb emacs or grade D emacs
 3 files changed, 20 insertions(+), 16 deletions(-)
 rename editors/{pmacs.py => dmacs.py} (87%)
 rename editors/{pmacsinit.py => dmacsinit.py} (61%)
Jonathans-MBP-4:editors jon$ git push
...

14 Jun 2013

Try to get M-% replace_string working with in_region:

...
    # edsel.c()
    in_region(lambda start, end: edsel.c(ed.searchstring, ed.replacestring,
                                         start, end))

In lines40.txt I set mark at 5 and dot at 10 then M-% line Line.
Nothing happened - no visible change in the file.
Then M-x :

>>> dmacs.mark
5
>>> ed.searchstring
'line'
>>> ed.replacestring
'Line'

If in_region ran, then dmacs.mark should be 0, deactivated - !?

... and shouldn't that be (lambda start, end: ... start=None, end=None)) - ?

This looks like a candidate for pdb.run.  Set mark, move dot, then M-x,
then import pdb, then pdb.run('replace_string()').  S(tep into) in_region.

Confirm that other in_region calls work.  Try indent C-c > , outdent. They do.

Try debug on indent.  In pm, set mark at 5, dot at 10.  Then M-x:

>>> dm()

exit with M-x 

5
>>> sked.dot
10
>>> win(12)
>>> import pdb
>>> pdb.run('in_window(edsel.indent)')
> <string>(1)<module>()
(Pdb) n
TypeError: '<=' not supported between instances of 'int' and 'function'
> <string>(1)<module>()

- !? Maybe I should have started with s for step into fcn.

(Pdb) c
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/pdb.py", line 1597, in run
    Pdb().run(statement, globals, locals)
  File "/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/bdb.py", line 580, in run
    exec(cmd, globals, locals)
  File "<string>", line 1, in <module>
  File "/Users/jon/Piety/editors/edsel.py", line 23, in in_window
    return (buftop <= iline <= buftop + wlines - 2)
TypeError: '<=' not supported between instances of 'int' and 'function'
>>>

How did we get here?  Try again.

...
NameError: name 'in_region' is not defined
> <string>(1)<module>()
(Pdb) pdb.run('dmacs.in_region(edsel.indent)')
(Pdb) s
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/pdb.py", line 1597, in run
    Pdb().run(statement, globals, locals)
  File "/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/bdb.py", line 580, in run
    exec(cmd, globals, locals)
  File "<string>", line 1, in <module>
NameError: name 'in_region' is not defined
>>> dmacs.in_region
<function in_region at 0x10cecc940>
>>> in_region
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
NameError: name 'in_region' is not defined

So I guess I don't know how to use the debugger.

>>> dmacs.in_region(edsel.outdent)

works on dot only

>>> dmacs.mark
0

So mark got set to 0.

>>> dmacs.mark=5
>>> sked.dot
10
>>> dmacs.in_region(edsel.outdent)

Works as expected - we see lines 5 - 10 outdent.

>>> dmacs.mark
0
>>> dmacs.mark=5
>>> dmacs.in_region(edsel.indent)

Works as expected.  And, previous in_region set dot from 5 back to 0
as intended.

>>> pdb.run('dmacs.in_region(edsel.indent)')
> <string>(1)<module>()
(Pdb) s
--Call--
> /Users/jon/Piety/editors/dmacs.py(94)in_region()
-> def in_region(f):
(Pdb) n
> /Users/jon/Piety/editors/dmacs.py(97)in_region()
-> if mark: # mark activated
(Pdb) n
> /Users/jon/Piety/editors/dmacs.py(101)in_region()
-> f() # mark deactivated, just execute f on dot
(Pdb) n
> /Users/jon/Piety/editors/dmacs.py(102)in_region()
-> mark = 0 # deactivate mark
(Pdb) n
--Return--
> /Users/jon/Piety/editors/dmacs.py(102)in_region()->None
-> mark = 0 # deactivate mark

Now that works like we expect.  We step through in_region, we
do see one line indented in window.

(Pdb) n
--Return--
> <string>(1)<module>()->None
(Pdb) c


Let's try it again, this time with mark set.

>>> dmacs.mark=5
>>> dmacs.mark
5
>>> sked.dot
10

>>> pdb.run('dmacs.in_region(edsel.indent)')
> <string>(1)<module>()->None
(Pdb) s
--Call--
> /Users/jon/Piety/editors/dmacs.py(94)in_region()
-> def in_region(f):
(Pdb) n
> /Users/jon/Piety/editors/dmacs.py(97)in_region()
-> if mark: # mark activated
(Pdb) n
> /Users/jon/Piety/editors/dmacs.py(98)in_region()
-> start, end = (mark, ed.dot) if mark < ed.dot else (ed.dot, mark)
(Pdb) n
> /Users/jon/Piety/editors/dmacs.py(99)in_region()
-> f(start, end)
(Pdb) n

We see lines 5 - 10 indent in window

> /Users/jon/Piety/editors/dmacs.py(102)in_region()
-> mark = 0 # deactivate mark
(Pdb) n
--Return--
> /Users/jon/Piety/editors/dmacs.py(102)in_region()->None
-> mark = 0 # deactivate mark
(Pdb) n
--Return--
> <string>(1)<module>()->None
(Pdb) c

Now let's try it with c()

>>> sked.dot
10
>>> dmacs.mark
0
>>> dmacs.mark=5
>>> sked.searchstring
'line'
>>> sked.replacestring
'Line'
>>> pdb.run('in_region(lambda start,end: edsel.c(sked.searchstring, sked.replacestring, start, end))')
> <string>(1)<module>()->None

NameError: name 'in_region' is not defined
> <string>(1)<module>()->None

Right, we forgot prefix dmacs.in_region...

(Pdb) pdb.run('dmacs.in_region(lambda start,end: edsel.c(sked.searchstring, sked.replacestring, start, end))')
(Pdb) s
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/pdb.py", line 1597, in run
    Pdb().run(statement, globals, locals)
  File "/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/bdb.py", line 580, in run
    exec(cmd, globals, locals)
  File "<string>", line 1, in <module>
NameError: name 'in_region' is not defined
>>> dmacs.in_region
<function in_region at 0x10cecc940>

Just try again from >>> not (Pdb)

>>> pdb.run('dmacs.in_region(lambda start,end: edsel.c(sked.searchstring, sked.replacestring, start, end))')
> <string>(1)<module>()->None
(Pdb) s
--Call--
> /Users/jon/Piety/editors/dmacs.py(94)in_region()
-> def in_region(f):

Yay!

(Pdb) n
> /Users/jon/Piety/editors/dmacs.py(97)in_region()
-> if mark: # mark activated
(Pdb) n
> /Users/jon/Piety/editors/dmacs.py(101)in_region()
-> f() # mark deactivated, just execute f on dot

Deactivated - !?

(Pdb) p dmacs.mark
*** NameError: name 'dmacs' is not defined
(Pdb) p mark
0

I clearly don't understand scope rules in pdb

TypeError: <lambda>() missing 2 required positional arguments: 'start' and 'end'
> /Users/jon/Piety/editors/dmacs.py(101)in_region()
-> f() # mark deactivated, just execute f on dot
(Pdb) n
TypeError: <lambda>() missing 2 required positional arguments: 'start' and 'end'
> <string>(1)<module>()->None
(Pdb) n
--Return--
> <string>(1)<module>()->None
(Pdb) n
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/pdb.py", line 1597, in run
    Pdb().run(statement, globals, locals)
  File "/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/bdb.py", line 580, in run
    exec(cmd, globals, locals)
  File "<string>", line 1, in <module>
  File "/Users/jon/Piety/editors/dmacs.py", line 101, in in_region
    f() # mark deactivated, just execute f on dot
TypeError: <lambda>() missing 2 required positional arguments: 'start' and 'end'
>>> 

Somehow mark got deactivated then it tried to run f() but here I think
we have the problem because lambda didn't declare start=None, end=None.
Can we even put those in a lambda expr?   Let's try it all again.

>>> sked.dot
9
>>> dmacs.mark
0
>>> dmacs.mark=5
>>> sked.searchstring
'line'
>>> sked.searchstring = 'Line'
>>> sked.replacestring
'Line'
>>> sked.replacestring = 'line'
>>> pdb.run('dmacs.in_region(lambda start,end: edsel.c(sked.searchstring, sked.replacestring, start=None, end=None))')

> <string>(1)<module>()->None
(Pdb) s
--Call--
> /Users/jon/Piety/editors/dmacs.py(94)in_region()
-> def in_region(f):
(Pdb) n
> /Users/jon/Piety/editors/dmacs.py(97)in_region()
-> if mark: # mark activated
(Pdb) n
> /Users/jon/Piety/editors/dmacs.py(98)in_region()
-> start, end = (mark, ed.dot) if mark < ed.dot else (ed.dot, mark)

Good, that means mark is activated.

(Pdb) n
> /Users/jon/Piety/editors/dmacs.py(99)in_region()
-> f(start, end)
(Pdb) n
> /Users/jon/Piety/editors/dmacs.py(102)in_region()
-> mark = 0 # deactivate mark

It only substituted Line 9 -> line 9 not lines 5 - 8. 

(Pdb) n
--Return--
> /Users/jon/Piety/editors/dmacs.py(102)in_region()->None
-> mark = 0 # deactivate mark
(Pdb) n
--Return--
> <string>(1)<module>()->None
(Pdb) n

We should do it again, this time step into f(start, end), but
first p start, p end.


15 Jun 2023

>>> sked.dot
10
>>> dmacs.mark
5

Line 5
...
Line 10

>>> sked.searchstring='Line'
>>> sked.searchstring
'Line'
>>> sked.replacestring='line'
>>> sked.replacestring
'line'

>>> pdb.run('dmacs.in_region(lambda start,end: edsel.c(sked.searchstring,sked.replacestring,start=None,end=None))')
> <string>(1)<module>()->None
(Pdb) s
--Call--
> /Users/jon/Piety/editors/dmacs.py(94)in_region()
-> def in_region(f):
(Pdb) s
> /Users/jon/Piety/editors/dmacs.py(97)in_region()
-> if mark: # mark activated
(Pdb) p f
<function <lambda> at 0x10cff7c10>
(Pdb) p mark
5
(Pdb) n
> /Users/jon/Piety/editors/dmacs.py(98)in_region()
-> start, end = (mark, ed.dot) if mark < ed.dot else (ed.dot, mark)
(Pdb) n
> /Users/jon/Piety/editors/dmacs.py(99)in_region()
-> f(start, end)
(Pdb) p start
5
(Pdb) p end
10

As intended up to here

f here is sked.c so its a big thing that loops over lines.
For now don't step into it.

(Pdb) n
> /Users/jon/Piety/editors/dmacs.py(102)in_region()
-> mark = 0 # deactivate mark

Once again, it only Line -> line in the last line, dot, not 
the whole range start .. end.

-> mark = 0 # deactivate mark
(Pdb) n
--Return--
> /Users/jon/Piety/editors/dmacs.py(102)in_region()->None
-> mark = 0 # deactivate mark
(Pdb) n
--Return--
> <string>(1)<module>()->None
(Pdb) n
>>> 

So we're getting close, but it doesn't handle range start..end - it
just does end.  Weird.  Edit start=None, end=None into lambda expr in source 
and use debugger on entire replace_string so we don't have to 
type that big lambda expr into pdb again.

First run M-% without debugger - with mark disabled, it only does the
substitution at dot.  And, with mark enabled at line 5, again it only
does the substitution at dot.   Next try >>> edsel.c('Line','line',dmacs.mark,
sked.dot)

Oh, do we need in_region for this at all - ?

...

16 Jan 2023

Started editing consecutive C-k in sked:

Jonathans-MBP-5:editors jon$ git diff 
diff --git a/editors/sked.py b/editors/sked.py
...
-def d(start=None, end=None, move_dot=move_dot): # hook for display code
+def d(start=None, end=None, append=False, move_dot=move_dot):
... etc. ...

set it aside

Jonathans-MBP-5:editors jon$  mv sked.py sked.py.append
Jonathans-MBP-5:editors jon$ git checkout sked.py

Jonathans-MBP-5:editors jon$ git log
commit daa69b1ec29f4600f84efedbc1b953fb557cdd0a
Author: Jon Jacky <jon@u.washington.edu>
Date:   Thu Jun 15 14:02:41 2023 -0700

    dmacs: M-% replace string working with region defined by mark, dot
    rename keycode to keymap

We committed this yesterday, off the net.

Jonathans-MBP-5:editors jon$ git push
...

Push yesterday's commit.

Now try to fix dmacs replace_string one more time

Now C-k doesn't work in dmacs  in python editor term window - ?
BUT it does work here in notes term window.

Problem with pycache?  Try rm -rf __pycache_/ then restart Python.

Now C-k C-y work again, we have a new __pycache__/

Fix for dmacs replace_string:

+    # Tried to fix edsel.c arg list for in_region with lambda, didn't work so:
+    def c1(start, end): edsel.c(ed.searchstring, ed.replacestring, start, end)
+    in_region(c1)

Jonathans-MBP-5:editors jon$ git commit -am 'dmacs: fix replace_string to use in_region with def local function'
[pmacs 0cc0dc0] dmacs: fix replace_string to use in_region with def local function
 1 file changed, 11 insertions(+), 16 deletions(-)
Jonathans-MBP-5:editors jon$ git push
...

Now return to consecutive C-k

Jonathans-MBP-5:editors jon$ mv -i sked.py.append sked.py
overwrite sked.py? (y/n [n]) y
Jonathans-MBP-5:editors jon$ git diff
... as expected ...

Now we have to fix edsel.d to match changed arg list of sked.d

-def d(start=None, end=None):
-    ed.d(start, end, display_d)
+def d(start=None, end=None, append=False):
+    ed.d(start, end, append, display_d)

Now C-w and C-k should work as before because we never call
d() with append=True

Now C-k at one line works but C-w over a range failed:

...
f(start, end)
                                      File "/Users/jon/Piety/editors/edsel.py", line 330, in d
                  ed.d(start, end, append, display_d)
                                                     TypeError: d() takes from 0 to 3 positional arguments but 4 were given


Oh dear, failed to match up arg list again.
in_region expects f(start,end) but now we have d(start,end,append).

Later - after writing out and reloading - 
Now C-w works on both single lines and region.
BUT C-k doesn't work - on a single line, it doesn't update the display.
You have to use refresh C-l to update the display.  
C-w calls in_region(edsel.d) but C-k just calls edsel.d
Make C-k just like C-w - confirm it works the same - then
revise C-k to use d(... append=True)

17 Jun 2023

Coded dmacs C-k to run in_region(edsel.d) just like C-w - they do
indeed work the same, on line line or on a region, they display correctly,
and are reversed by C-y.   Now add code to append consecutive C-k to yank buf.

 File "/Users/jon/Piety/editors/dmacs.py", line 91, in in_region
                             f() # mark deactivated, just execute f on dot
                                                                          TypeError: d_append() missing 2 required positional arguments: 'start' and 'end'

To heck with all that in_region stuff here.  C-k should mean kill *single* 
line.  Doesn't that make it simpler? It works.

Another thing to fix is to back out of prompt with ??? - I stumble into
prompt a lot.

Last thing would be to consistently print from sked with \n\r.  Looks
much nicer, more finished.

No it doesn't, because when print() occurs after a prompt, it doesn't 
appear at bottom of scrolling region but right after prompt, overwriting
line that was there - except any longer part at the end - and preceding
lines lower down that were printed earlier.

After prompt, can we put cursor at bottom of term window?  Then any
print from code after prompt will appear at the bottom, in the proper order.

Jonathans-MBP-5:editors jon$ git commit -am 'sked, dmacs: consecutive C_k append deleted lines to yank buffer 
> sked: put \n\r at end of string not found msg so it prints right in char mode
> dmacs: confirm: put_cursor at the bottom of term window on exit'
[pmacs 8e9ad02] sked, dmacs: consecutive C_k append deleted lines to yank buffer sked: put \n\r at end of string not found msg so it prints right in char mode dmacs: confirm: put_cursor at the bottom of term window on exit
 3 files changed, 19 insertions(+), 6 deletions(-)
Jonathans-MBP-5:editors jon$ git push
...


18 Jun 2023

Note C-f C-x find file already prints prompt for filename then puts
cursor at tlines.  BUT then when it prints filename of loaeded file,
it only does LF not CR.

We got cancel and also restoring prompt/inform cursor to window bottom
workin with search, C-s and C-r.   Now must handle cancel with C-x C-f 
etc.

Done.  One last thing C-x C-r to save and reload does not update status
line with "saved".  Does it update sked.saved ?   Oh, we see dmacs
save_reload calls ed.w() but there is an edsel.w() that calls
display_set_saved.   Call edsel.w() instead.  That fixed it.

Jonathans-MBP-5:editors jon$ git commit -am 'dmacs: add cancel to all commamds that prompt
> also C-x C-r save-reload calls edsel.w not ed.w so status line shows saved
> sked: print all use print("...\n\r", end="") so they work in char mode'
[pmacs 9f53fcf] dmacs: add cancel to all commamds that prompt also C-x C-r save-reload calls edsel.w not ed.w so status line shows saved sked: print all use print("...\n\r", end="") so they work in char mode
 2 files changed, 36 insertions(+), 11 deletions(-)
Jonathans-MBP-5:editors jon$ git push
...

I think the code for the pmacs branch is done.  Next: update README.

19 Jun 2023

Jonathans-MBP-5:editors jon$ wc *.py
     220     964    7788 dmacs.py
      10      45     257 dmacsinit.py
     393    1958   14998 edsel.py
      20     163     849 edselinit.py
     467    2441   17529 sked.py
      30     251    1421 skedinit.py
    1140    5822   42842 total

Jonathans-MBP-5:vt_terminal jon$ wc *.py
     133     629    4195 display.py
     110     524    2656 key.py
      94     419    2746 keyseq.py
     337    1572    9597 total

Jonathans-MBP-5:unix jon$ wc *.py
      73     259    2130 terminal.py
      12      50     416 terminal_util.py
      85     309    2546 total

So we have about 1500 lines so far - that includes blank lines
and comments, and code that is not used in the editors
(like main() used only for testing, fcns from display.py the editors 
don't call, etc.)

onathans-MBP-5:editors jon$ git commit -am 'sked, edsel, dmacs: move block comments to new NOTES.md'
[pmacs e8e7a7a] sked, edsel, dmacs: move block comments to new NOTES.md
 4 files changed, 76 insertions(+), 29 deletions(-)
 create mode 100644 editors/NOTES.md
Jonathans-MBP-5:editors jon$ git push
...


20 Jun 2023

I think I found the "lost" sections alluded to above at L8769 etc.

There are two files notes.txt and other.txt in Piety/edsel - I think 
I wrote them out there, then exited.  They should have been saved
in ~/notes/piety/.   Move them there now:

Jonathans-MBP-5:editors jon$ mv notes.txt /Users/jon/notes/piety/notes-misplaced.txt
Jonathans-MBP-5:editors jon$ mv other.txt /Users/jon/notes/piety/other-misplaced.txt

Jonathans-MBP-5:piety jon$ git commit -am 'notes/piety/ add notes-misplaced.txt and other-misplaced.txt
> notes/uw-access/hstam340a/ add many .pdf and .pptx'
[master 5ea7566] notes/piety/ add notes-misplaced.txt and other-misplaced.txt notes/uw-access/hstam340a/ add many .pdf and .pptx
 32 files changed, 21806 insertions(+)
 create mode 100644 piety/notes-misplaced.txt
 create mode 100644 piety/other-misplaced.txt
 create mode 100644 uw-access/hstam340a/1 Gender Theory.pdf
 create mode 100644 uw-access/hstam340a/1 Gender Theory.pptx
 ...

Piety/editors/NOTES.md is a bit too grand for an .md file, 
change to NOTES.txt to emphasize its roughness and incompleteness.
This should look make its github page look rough.

Jonathans-MBP-5:editors jon$ git commit -am 'NOTES.md: rename to NOTES.txt, fix references in sked edsel dmacs.py'
[pmacs 1e8995a] NOTES.md: rename to NOTES.txt, fix references in sked edsel dmacs.py
 5 files changed, 8 insertions(+), 3 deletions(-)
 rename editors/{NOTES.md => NOTES.txt} (100%)
Jonathans-MBP-5:editors jon$ git push
...

21 Jun 2023

Jonathans-MBP-5:editors jon$ git commit -am 'README: add section on dmacs
> NOTES: tweaks'
[pmacs 6d26d8d] README: add section on dmacs NOTES: tweaks
 2 files changed, 80 insertions(+), 6 deletions(-)
Jonathans-MBP-5:editors jon$ git push
...

I think we are ready to merge pmacs branch back into editors branch.

Jonathans-MBP-5:editors jon$ git commit -am 'README: add link to GNU emacs reference card in dmacs section'
[pmacs 160a6c3] README: add link to GNU emacs reference card in dmacs section
 1 file changed, 2 insertions(+), 1 deletion(-)
Jonathans-MBP-5:editors jon$ git push
...

Jonathans-MBP-5:editors jon$ git commit -am 'README, dmacs section: explain M-%'
[pmacs 6b8213d] README, dmacs section: explain M-%
 1 file changed, 6 insertions(+), 4 deletions(-)
Jonathans-MBP-5:editors jon$ git push
...

Jonathans-MBP-5:editors jon$ git commit -am 'README, correct pmacs -> dmacs'
[pmacs c258e5c] README, correct pmacs -> dmacs
 1 file changed, 1 insertion(+), 1 deletion(-)
Jonathans-MBP-5:editors jon$ git push
...


22 Jun 2023

Jonathans-MBP-5:editors jon$ git commit -am 'add HOW.md, How we program'
[pmacs 0667664] add HOW.md, How we program
 2 files changed, 91 insertions(+)
 create mode 100644 editors/HOW.md
Jonathans-MBP-5:editors jon$ git push
...


24 Jun 2023

Pretty happy with new HOW.md, "How we program" with just intro
and these sections so far:

No programs, applications, or command interpreters

Reload functions, not data

No classes or objects

Maybe add crossrefs between README and HOW ?


25 Jun 2023

Jonathans-MBP-5:editors jon$ git commit -am 'README.md: add Introduction, how to reload, crossref to HOW.md
> HOW.md: add crossref to README.md'
[pmacs 3a83502] README.md: add Introduction, how to reload, crossref to HOW.md HOW.md: add crossref to README.md
 3 files changed, 33 insertions(+), 10 deletions(-)
Jonathans-MBP-5:editors jon$ git push
...


26 Jun 2023

Inspired by 'How we program' essay, I resolve to replace tuples in 
saved buffers by dictionaries.  More flexible and extensible - can
add 'attributes' (key-value pairs) without breaking existing code

To test, first revise save_buffer, write new_restore_buffer but still
use restore_buffer to restore old saved buffers still saved as tuples.

Wrote sked.py, 474 lines
Reload module sked

 scratch.txt           0   scratch.txt                     saved
 dmacs.py            215   dmacs.py                        unsaved changes
 README.md           256   README.md                       saved
*sked.py             474   sked.py                         saved
 edsel.py            386   edsel.py                        saved
 NOTES.txt            69   NOTES.txt                       saved
 HOW.md               89   HOW.md                          saved

>>> buffers['scratch.txt']
('scratch.txt', 'scratch.txt', ['\n'], 0, True)

>>> b('scratch.txt')
...
  File "/Users/jon/Piety/editors/sked.py", line 102, in save_buffer
    buffers[bufname]['bufname'] = bufname
TypeError: 'tuple' object does not support item assignment

I see how to fix this.  Rewrite save_buffer with     buffers[bufname] = bstate

Wrote sked.py, 475 lines
Reload module sked

  File "/Users/jon/Piety/editors/sked.py", line 102, in save_buffer
    bstate['bufname'] = bufname
NameError: name 'bstate' is not defined

Add bstate = dict()

Wrote sked.py, 476 lines
Reload module sked

>>> b('scratch.txt')

Apparently worked - no crash - must have saved sked.py

>>> buffers['sked.py']['bufname']
'sked.py'
>>> buffers['sked.py']['filename']
'sked.py'
>>> buffers['sked.py']['dot']
102
>>> buffers['sked.py']['saved']
True
>>> buffers['sked.py']['buffer'][:3]
['\n', '"""\n', 'sked.py - Stone Knife Editor, line editor inspired by classic Unix ed.\n']


So that all worked.

Now we have save_buffer to the new dict format and restore_bufer
in the old tuple format.  So just restoring each buffer will result
in the previous buffer getting saved in the new format, and each
buffer getting restored using the old format.  Then we can
rename new_restorebuffer to restore_buffer and restore each of the
svaed buffers now in the new format.

Don't we also have to rewrite status() - ?

>>> b('dmacs.py')
>>> b('README.md')
>>> b('edsel.py')
>>> b('NOTES.txt')
>>> b('HOW.md')

So all of those, as well as sked.py, should now be saved in new format.
Oh, except HOW.md - 

>>> e('skedinit.py')
skedinit.py, 30 lines

That should do it!

>>> buffers.keys()
    dict_keys(['scratch.txt', 'dmacs.py', 'README.md', 'sked.py', 'edsel.py',
    'NOTES.txt', 'HOW.md', 'bufname'])


Not sure how 'bufname' got in there ...  maybe transitional.

(Why is wrap() still using lmargin 4 ?)

>>> sked.lmargin
0

-- !?

>>> b('dmacs.py')

  File "/Users/jon/Piety/editors/edsel.py", line 37, in locate_segment
    if iline < wlines - 1: # iline is near top of buffer, show first page
TypeError: '<' not supported between instances of 'str' and 'int'

Right, we are still using old restore_buffer that tries to read tuple.

So there is no way to edit and reload sked.py.  We'll have to do 
edit it in another editor instance and reload module in working instance.

Switch to buffer (default HOW.md): dmacs.py
  File "/Users/jon/Piety/editors/edsel.py", line 150, in display_restore_buffer
    recenter()
  File "/Users/jon/Piety/editors/edsel.py", line 113, in recenter
    buftop = locate_segment(ed.dot)
  File "/Users/jon/Piety/editors/edsel.py", line 37, in locate_segment
    if iline < wlines - 1: # iline is near top of buffer, show first page
TypeError: '<' not supported between instances of 'str' and 'int'

>>> buffers['dmacs.py']['dot']
3

>>> sked.dot
'dot'

Our new restore_buffer isn't right.

>>> buffers['dmacs.py'].get('dot',0)
3

But that is right!

>>> restore_buffer('dmacs.py')
bufname, at line dot of 5, file filename, saved

I think status() is the problem here.  Fix now.

No, status() just prints the values of the sked.xxx variables.

>>> restore_buffer('dmacs.py')
bufname, at line dot of 5, file filename, saved
>>> sked.bufname
'bufname'
>>> buffers['dmacs.py'].get('bufname','scratch.txt')
'dmacs.py'

What's going on here?  I think we are not runing
the new restore_buffer, even though we re-imported
sked.  I think we have to re-import edsel and dmacs 
also.

We're still getting the same error.  Lets restart Python session. 

...
>>> e('dmacs.py')
dmacs.py, 215 lines
>>> e('sked.py')
sked.py, 476 lines
>>> status()
'sked.py, at line 1 of 476, file sked.py, saved'

That suggests both save_ and restore_buffer are now working.

>>> n()
...
 scratch.txt           0   scratch.txt                     saved
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "/Users/jon/Piety/editors/sked.py", line 191, in n
    for bname in buffers: print(bstatus(bname)+'\n\r', end='') # for char mode
  File "/Users/jon/Piety/editors/sked.py", line 182, in bstatus
    ('*' if bufname == buf[0] else ' ', 
KeyError: 0

Right, we still have to fix n().

>>> n()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "/Users/jon/Piety/editors/sked.py", line 191, in n
    for bname in buffers: print(bstatus(bname)+'\n\r', end='') # for char mode
  File "/Users/jon/Piety/editors/sked.py", line 182, in bstatus
    ('*' if bufname == buf['bufname'] else ' ', 
TypeError: tuple indices must be integers or slices, not str

- !?

>>> buffers['scratch.txt']
('scratch.txt', 'scratch.txt', ['\n'], 0, True)

This is tuple not dict - !?

>>> buffers['dmacs.py']['bufname']
'dmacs.py'
>>> buffers['dmacs.py']['filename']
'dmacs.py'
>>> buffers['dmacs.py']['buffer'][0:3]
['\n', '"""\n', 'dmacs.py - Invoke editor functions with emacs keys (control keys or key seqs).\n']

That's a dict.  Look at initialization of buffers with scratch buffer. Fixed.

>>> dm()
sked.py, 476 lines
edsel.py, 386 lines
dmacs.py, 215 lines
 scratch.txt           0   scratch.txt                     saved
 sked.py             476   sked.py                         saved
 edsel.py            386   edsel.py                        saved

Now it seems to be working.

>>> buffers['scratch.txt']
{'bufname': 'scratch.txt', 'filename': 'scratch.txt', 'buffer': ['\n'], 'dot': 0, 'saved': True}


>>> buffers['edsel.py']['buffer'][0:3]
['\n', '"""\n', 'edsel.py - Display editor that uses the same commands as *sked*.\n']


That confirms saved buffers are dicts not tuples.

>>> b('sked.py')
Switch to buffer (default edsel.py): sked.py
  File "/Users/jon/Piety/editors/edsel.py", line 113, in recenter
    buftop = locate_segment(ed.dot)
  File "/Users/jon/Piety/editors/edsel.py", line 37, in locate_segment
    if iline < wlines - 1: # iline is near top of buffer, show first page
TypeError: '<' not supported between instances of 'str' and 'int'
>>> sked.dot
'dot'
>>> buffers['sked.py']['dot']
1

>>> buffers['edsel.py']['dot']
1

>>> restore_buffer('sked.py')
sked.py, at line 1 of 476, file sked.py, saved
>>> buffers['edsel.py']['dot']
1

BUT still we get to 

Switch to buffer (default edsel.py): sked.py
  File "/Users/jon/Piety/editors/edsel.py", line 113, in recenter
    buftop = locate_segment(ed.dot)
  File "/Users/jon/Piety/editors/edsel.py", line 37, in locate_segment
    if iline < wlines - 1: # iline is near top of buffer, show first page
TypeError: '<' not supported between instances of 'str' and 'int'
>>> sked.dot
'dot'

>>> restore_buffer('sked.py')
sked.py, at line 1 of 476, file sked.py, saved
>>> sked.dot
1

- !?

Found the problem.  edsel.py display_restore_buffer also
has code to restore buffer - was still using tuple.
Revised to use dict.  Now it works.  Bah, this is
more work than I expected - and it's more code.
A line for each attribute, phooey.  

Later - had to fix sked fcn bname, used tuple index not dict key.

27 Jun 2023 - 29 Jun 2023

Several commits for saved buffers as dictionaries work.

Revise bname() so it looks up filenames in saved buffers using
dictionary get() not just index.

Finally, fix e() so you can't e() the same file twice - it just
warns and exits.

Oops, appears to be a problem with saved buffers and restoring saved
buffers.  

30 Jun 2023

Investigate problem with saved buffers

>>> dm()

Now try some C-x C-f

sked.py, 478 lines
edsel.py, 385 lines
dmacs.py, 215 lines

Each appears in window as it should.  Now dmacs is in window

C-x C-b

 scratch.txt         385   edsel.py                        saved

- !?

Now C-x C-f dmacs.py when dmacs.py is already the current buffer:

? file dmacs.py is already in the current buffer

That's correct.  Now C-x C-f edsel.py when edsel.py should be stored

? file edsel.py is already in the saved buffer scratch.txt

- !?  Try C-x C-b again

*scratch.txt         385   edsel.py                        saved

So it appears sked.py then edsel.py were saved with the bufname - the key -
of scratch.txt.  

I must have broken bname() or maybe save_buffer.

C-x C-b sked.py

? no buffer sked.py

C-x C-f sked.py

sked.py, 478 lines

That worked.  Now sked.py is in the window.

C-x C-b

 scratch.txt         215   dmacs.py                        saved

Yup, former current buffer dmacs.py got stored under name scratch.txt.

>>> sked.bufname
'sked.py'
>>> sked.filename
'sked.py'
>>> sked.buffer[:3]
['\n', '"""\n', 'sked.py - Stone Knife Editor, line editor inspired by classic Unix ed.\n']

those are all correct now, so e() apparently works correctly,
including bname().   Problem must be in save_buffer.

>>> sked.buffers.keys()
dict_keys(['scratch.txt'])

>>> buf = sked.buffers['scratch.txt']
>>> buf['filename']
'dmacs.py'
>>> buf['buffer'][:3]
['\n', '"""\n', 'dmacs.py - Invoke editor functions with emacs keys (control keys or key seqs).\n']
>>> buf['bufname']
'scratch.txt'

Yes, save_buffer is saving the wrong bufname.  But ... it used to work!
Look at the code that calls save_buffer.

Or, maybe restore_buffer is not restoring the filename?
But e() is setting bufname.

Aside - b() calls save_buffer even in cases where it doesn't
actually save the buffer.  Fix?   Looks like e() does it right.

Could the problem be in edsel save_buffer?
There isn't one - just edsel restore_buffer.

Just C-x C-f README.md then

>>> sked.bufname
'README.md'

That's right.  So e() assigns bufname correctly.

>>> import pdb
>>> pdb.run('save_buffer()')
> <string>(1)<module>()
>>> pdb.run('save_buffer()')
> <string>(1)<module>()
(Pdb) n
--Return--
> <string>(1)<module>()->None
(Pdb) n

Oh, I should have s not n

>>> n()
 scratch.txt         385   edsel.py                        saved
*README.md           257   README.md                       saved

Hey, that worked!  But then when e() calls save_buffer, it doesn't wok.

>>> e('skedinit.py')
skedinit.py, 31 lines

>>> n()
 scratch.txt         385   edsel.py                        saved
 README.md           257   README.md                       saved
>>> sked.bufname
'skedinit.py'

>>> e('edselinit.py')
edselinit.py, 20 lines
>>> sked.bufname
'edselinit.py'

>>> n()
 scratch.txt         385   edsel.py                        saved
 README.md            31   skedinit.py                     saved

It looks like it's using prev_bufname - !?  
Try running e() under the debugger.

First run it in sked only.  RE-initialize buffers.

>>> clr()
>>> from sked import *
>>> e('scratch.txt')
scratch.txt, 0 lines
>>> n()
 scratch.txt         385   edsel.py                        saved
 README.md            20   edselinit.py                    saved
>>> buffers = dict()
>>> buffers[bufname] = {'bufname': bufname, 'filename': filename, 
...                     'buffer': buffer, 'dot': dot, 'saved': saved }
>>> n()
 scratch.txt         385   edsel.py                        saved
 README.md            20   edselinit.py                    saved

Right.  Try again:

>>> sked.buffers = dict()
>>> n()

>>> sked.buffers[bufname] = {'bufname': bufname, 'filename': filename,
...                     'buffer': buffer, 'dot': dot, 'saved': saved }
>>> n()
 edselinit.py         20   edselinit.py                    saved

>>> bufname
'edselinit.py'
>>> filename
'edselinit.py'

- !?  How did that happen?

Restart Python, just run edsel.

Jonathans-MBP-5:editors jon$ python3 -i
Python 3.9.0 (v3.9.0:9cf6752276, Oct  5 2020, 11:29:23) 
[Clang 6.0 (clang-600.0.57)] on darwin
Type "help", "copyright", "credits" or "license" for more information.
>>> import sked
>>> from sked import *
>>> status()
'scratch.txt, at line 0 of 0, file scratch.txt, saved'
>>> n()
*scratch.txt           0   scratch.txt                     saved
>>> sked.bufname
'scratch.txt'
>>> sked.filename
'scratch.txt'

Now run e()

>>> e('sked.py')
sked.py, 478 lines
>>> sked.bufname
'sked.py'
>>> sked.filename
'sked.py'
>>> n()
 scratch.txt           0   scratch.txt                     saved

as expected.  Now e() again.

>>> e('edsel.py')
edsel.py, 385 lines
>>> sked.bufname
'edsel.py'
>>> sked.filename
'edsel.py'
>>> status()
'edsel.py, at line 1 of 385, file edsel.py, saved'
>>> n()
 scratch.txt         478   sked.py                         saved

So it loaded edsel.py but did not save bufname - or saved prev bufname.
It looks like other buffer items did get saved.

> <string>(1)<module>()
(Pdb) s
--Call--
> /Users/jon/Piety/editors/sked.py(111)e()
-> def e(fname, move_dot=move_dot):  # move_dot is a hook for display code
(Pdb) p sked.bufname
*** NameError: name 'sked' is not defined
(Pdb) p bufname
'edsel.py'
(Pdb) p filename
'edsel.py'
(Pdb) p buffer[:3]
['\n', '"""\n', 'edsel.py - Display editor that uses the same commands as *sked*.\n']
(Pdb) n
> /Users/jon/Piety/editors/sked.py(117)e()
-> if fname == filename:
(Pdb) n
> /Users/jon/Piety/editors/sked.py(120)e()
-> for bufname in buffers:
(Pdb) n
> /Users/jon/Piety/editors/sked.py(121)e()
-> bfname = buffers[bufname].get('filename','no filename')
(Pdb) n
> /Users/jon/Piety/editors/sked.py(122)e()
-> if fname == bfname:
(Pdb) p bfname
'sked.py'
(Pdb) n
> /Users/jon/Piety/editors/sked.py(120)e()
-> for bufname in buffers:
(Pdb) n
> /Users/jon/Piety/editors/sked.py(125)e()
-> if S() > 0: save_buffer()
(Pdb) p S(0)
*** TypeError: S() takes 0 positional arguments but 1 was given
(Pdb) p S()
385
(Pdb) s
--Call--
> /Users/jon/Piety/editors/sked.py(30)S()
-> def S():
(Pdb) n
> /Users/jon/Piety/editors/sked.py(32)S()
-> return len(buffer)-1  # -1 because of zero based index
(Pdb) n
--Return--
> /Users/jon/Piety/editors/sked.py(32)S()->385
-> return len(buffer)-1  # -1 because of zero based index
(Pdb) n
--Call--
> /Users/jon/Piety/editors/sked.py(93)save_buffer()
-> def save_buffer():
-> buffers[bufname] = {'bufname': bufname, 'filename': filename,
(Pdb) p bufname, filename
('scratch.txt', 'edsel.py')

-- !?  How did bufname: 'scratch.txt' happen - !?

At line 9985 above, we see bufname is edsel.py.  
Could it be the loop for bufname in buffers that reassigned bufname?

Change bufname to buffername in that loop.

+    if fname == filename:
+        print(f'? file {fname} is already in the current buffer\r\n', end='')
+        return
+    for buffername in buffers: # can't use bufname here - shadows sked.bufname
+        bfname = buffers[buffername].get('filename','no filename')
+        if fname == bfname:
+            print(f'? file {fname} is already in the saved buffer {buffername}\r\n', end='')
+            return

But it still didn't help:

>>> w()
Wrote sked.py, 478 lines
>>> from importlib import reload
>>> reload(sked)
<module 'sked' from '/Users/jon/Piety/editors/sked.py'>
>>> n()
 scratch.txt           0   scratch.txt                     saved
>>> status()
'sked.py, at line 125 of 478, file sked.py, saved'
>>> e('edsel.py')
edsel.py, 385 lines
>>> status()
'edsel.py, at line 1 of 385, file edsel.py, saved'
>>> n()
 scratch.txt         478   sked.py                         saved

bufname is still scratch.txt.  Why is it just this item?

Next: restart python, pdb.run, n through e(), check bufname after each
statement.

Jonathans-MBP-5:editors jon$ python3 -i
Python 3.9.0 (v3.9.0:9cf6752276, Oct  5 2020, 11:29:23) 
[Clang 6.0 (clang-600.0.57)] on darwin
Type "help", "copyright", "credits" or "license" for more information.
>>> import sked
>>> from sked import *
>>> status
<function status at 0x1091889d0>
>>> status()
'scratch.txt, at line 0 of 0, file scratch.txt, saved'
>>> n()
*scratch.txt           0   scratch.txt                     saved
>>> e('sked.py')
sked.py, 478 lines
>>> status()
'sked.py, at line 1 of 478, file sked.py, saved'
>>> n()
 scratch.txt           0   scratch.txt                     saved
>>> import pdn
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
ModuleNotFoundError: No module named 'pdn'
>>> import pdb
>>> pdb.run("e('edsel.py')")
> <string>(1)<module>()
(Pdb) s
--Call--
> /Users/jon/Piety/editors/sked.py(111)e()
-> def e(fname, move_dot=move_dot):  # move_dot is a hook for display code
(Pdb) p bufname
'sked.py'
(Pdb) n
> /Users/jon/Piety/editors/sked.py(117)e()
-> if fname == filename:
(Pdb) n
> /Users/jon/Piety/editors/sked.py(120)e()
-> for buffername in buffers: # can't use bufname here - shadows sked.bufname
(Pdb) p bufname
'sked.py'
(Pdb) n
> /Users/jon/Piety/editors/sked.py(121)e()
-> bfname = buffers[buffername].get('filename','no filename')
(Pdb) p bufname
'sked.py'
(Pdb) n
> /Users/jon/Piety/editors/sked.py(122)e()
-> if fname == bfname:
(Pdb) p bufname
'sked.py'
(Pdb) n
> /Users/jon/Piety/editors/sked.py(120)e()
-> for buffername in buffers: # can't use bufname here - shadows sked.bufname
(Pdb) p bufname
'sked.py'
(Pdb) p bufname
'sked.py'
(Pdb) n
> /Users/jon/Piety/editors/sked.py(125)e()
-> if S() > 0: save_buffer()
(Pdb) p bufname
'sked.py'
(Pdb) n
> /Users/jon/Piety/editors/sked.py(126)e()
-> try:
(Pdb) p bufname
'sked.py'

Hey, we ran save_buffer and bufname is still sked.py - !?

(Pdb) n
> /Users/jon/Piety/editors/sked.py(126)e()
-> try:
(Pdb) p bufname
'sked.py'

(Pdb) n
> /Users/jon/Piety/editors/sked.py(127)e()
-> with open(fname, mode='r') as fd:
(Pdb) p bufname
'sked.py'
(Pdb) n
> /Users/jon/Piety/editors/sked.py(130)e()
-> buffer = ['\n'] + fd.readlines() # each line in buffer ends with \n
(Pdb) p bufname
'sked.py'
(Pdb) n
> /Users/jon/Piety/editors/sked.py(133)e()
-> prev_bufname = bufname
(Pdb) p bufname
'sked.py'
(Pdb) p prev_bufname
'scratch.txt'
(Pdb) n
> /Users/jon/Piety/editors/sked.py(134)e()
-> filename = fname
(Pdb) p prev_bufname
'sked.py'
(Pdb) p bufname
'sked.py'
(Pdb) n
> /Users/jon/Piety/editors/sked.py(135)e()
-> bufname = bname(filename) # creates new buffer if e() on same file
(Pdb) p bufname
'sked.py'
(Pdb) n
> /Users/jon/Piety/editors/sked.py(136)e()
-> saved = True # put this *before* move_dot for display code
(Pdb) p bufname
'edsel.py'

Now bufname changed to edsel as intended and expected.

Pdb) n
> /Users/jon/Piety/editors/sked.py(137)e()
-> move_dot(min(S(),1)) # start of buffer, empty buffer S() is 0
(Pdb) p bufname
'edsel.py'
(Pdb) n
> /Users/jon/Piety/editors/sked.py(138)e()
-> print(f'{filename}, {S()} lines\n\r', end='')
(Pdb) p bufname
'edsel.py'
(Pdb) n
edsel.py, 385 lines
--Return--
> /Users/jon/Piety/editors/sked.py(138)e()->None
-> print(f'{filename}, {S()} lines\n\r', end='')
(Pdb) p bufname
'edsel.py'
(Pdb) n
--Return--
> <string>(1)<module>()->None
(Pdb) p bufname
'scratch.txt'

-- WHAT !!??

(Pdb) n
>>> 

>>> n()
 scratch.txt           0   scratch.txt                     saved
 sked.py             478   sked.py                         saved

That looks right.

>>> status()
'edsel.py, at line 1 of 385, file edsel.py, saved'

>>> bufname
'scratch.txt'
>>> filename
'scratch.txt'
>>> buffer[:3]
['\n']
>>> p()
"""
>>> l()
edsel.py - Display editor that uses the same commands as *sked*.
>>> l()

>>> l()
Display buffer contents in a window as they are updated by the sked editor.

Wait a minute...

>>> sked.bufname
'edsel.py'
>>> sked.filename
'edsel.py'
>>> sked.buffer[:3]
['\n', '"""\n', 'edsel.py - Display editor that uses the same commands as *sked*.\n']


So you dont
have to prefix with module name in the debugger, but you do have to 
prefix with module name in REPL.

So that seemed to work.  Try it without the debugger.

>>> e('dmacs.py')
dmacs.py, 215 lines
>>> status()
'dmacs.py, at line 1 of 215, file dmacs.py, saved'
>>> n()
 scratch.txt           0   scratch.txt                     saved
 sked.py             478   sked.py                         saved
 edsel.py            385   edsel.py                        saved

Try it in edsel

>>> import edsel
>>> from edsel import *
>>> win(24)
>>> e('README.md')
README.md, 257 lines

>>> status()
'README.md, at line 1 of 257, file README.md, saved'
>>> n()
 scratch.txt           0   scratch.txt                     saved
 sked.py             478   sked.py                         saved
 edsel.py            385   edsel.py                        saved
 dmacs.py            215   dmacs.py                        saved

It does seem to be working now.  Test bname() unique buffer name generation

>>> e('../README.md')
../README.md, 148 lines
>>> status
<function status at 0x1091889d0>
>>> status()
'README.md<2>, at line 1 of 148, file ../README.md, saved'
>>> n()
 scratch.txt           0   scratch.txt                     saved
 sked.py             478   sked.py                         saved
 edsel.py            385   edsel.py                        saved
 dmacs.py            215   dmacs.py                        saved
 README.md           257   README.md                       saved

>>> e('../vt_terminal/README.md')
../vt_terminal/README.md, 17 lines
>>> status()
'README.md<3>, at line 1 of 17, file ../vt_terminal/README.md, saved'

>>> n()
 scratch.txt           0   scratch.txt                     saved
 sked.py             478   sked.py                         saved
 edsel.py            385   edsel.py                        saved
 dmacs.py            215   dmacs.py                        saved
 README.md           257   README.md                       saved
 README.md<2>        148   ../README.md                    saved

Now e() with save_buffer and bname seems to be working.  Now try the
no-duplicate buffers check.

>>> e('../vt_terminal/README.md')
? file ../vt_terminal/README.md is already in the current buffer
>>> e('../README.md')
? file ../README.md is already in the saved buffer README.md<2>

Now restore a buffer

>>> b('sked.py')
sked.py, at line 1 of 478, file sked.py, saved

>>> n()
 scratch.txt           0   scratch.txt                     saved
*sked.py             478   sked.py                         saved
 edsel.py            385   edsel.py                        saved
 dmacs.py            215   dmacs.py                        saved
 README.md           257   README.md                       saved
 README.md<2>        148   ../README.md                    saved
 README.md<3>         17   ../vt_terminal/README.md        saved

That worked too.  It's ready to commit.

I think changing the name of the loop index variable from bufname
to buffername did fix it.  Not sure why reload() didn't fix it,
but restarting Python did.

Jonathans-MBP-5:editors jon$ git commit -am 'sked.py e(): do not allow loading a file that is already in current or saved buffers'
[pmacs 60b2810] sked.py e(): do not allow loading a file that is already in current or saved buffers
 1 file changed, 8 insertions(+), 1 deletion(-)
Jonathans-MBP-5:editors jon$ git push
Counting objects: 4, done.
Delta compression using up to 4 threads.
Compressing objects: 100% (4/4), done.
Writing objects: 100% (4/4), 618 bytes | 0 bytes/s, done.
Total 4 (delta 3), reused 0 (delta 0)
remote: Resolving deltas: 100% (3/3), completed with 3 local objects.
remote: To https://github.com/jon-jacky/Piety
   f1bd2bf..60b2810  pmacs -> pmacs

 
 1 Jul 2023

Why does status line say sked.py<2> -- !?

 scratch.txt           0   scratch.txt                     saved
 sked.py             478   sked.py                         saved
 edsel.py            385   edsel.py                        saved
 dmacs.py            215   dmacs.py                        saved
 README.md           257   README.md                       saved
 README.md<2>        148   ../README.md                    saved
 README.md<3>         17   ../vt_terminal/README.md        saved

Then select edsel.py - it shows up as edsel.py not edsel.py<2>

then C-x C-b :

 sked.py             478   sked.py                         saved
*edsel.py            385   edsel.py                        saved
 dmacs.py            215   dmacs.py                        saved
 README.md           257   README.md                       saved
 README.md<2>        148   ../README.md                    saved
 README.md<3>         17   ../vt_terminal/README.md        saved
 sked.py<2>          478   sked.py                         saved

Then C-x C-b goes back to sked.py<2> which has the change to save_buffer
location in b().

Then C-x C-b sked.py to version without that change. Then C-x k to get
rid of it.  Goes back to sked.py<2>

 scratch.txt           0   scratch.txt                     saved
 edsel.py            385   edsel.py                        saved
 dmacs.py            215   dmacs.py                        saved
 README.md           257   README.md                       saved
 README.md<2>        148   ../README.md                    saved
 README.md<3>         17   ../vt_terminal/README.md        saved
*sked.py<2>          478   sked.py                         saved

Now what if I try C-x C-f sked.py again?

? file sked.py is already in the current buffer

It doesn't create a sked.py<3>.

C-x C-r sked.py to reload sked, with the save_buffer change.

Then C-x C-b edsel.  BUT now it shows:

*edsel.py            385   edsel.py                        saved
 dmacs.py            215   dmacs.py                        saved
 README.md           257   README.md                       saved
 README.md<2>        148   ../README.md                    saved
 README.md<3>         17   ../vt_terminal/README.md        saved
 sked.py<2>          478   sked.py                         saved
 sked.py             478   sked.py                         saved

So C-x C-b calls bname() and creates new buffer?

No, but w() does rename bufname to filename - could that be the problem?

Use C-x k to get rid of both sked.

C-x C-f load sked

Try again, ? file sked.py is already in the current buffer

C-x b edsel

Switch to buffer (default edsel.py): 
 scratch.txt           0   scratch.txt                     saved
*edsel.py            385   edsel.py                        saved
 dmacs.py            215   dmacs.py                        saved
 README.md           257   README.md                       saved
 README.md<2>        148   ../README.md                    saved
 README.md<3>         17   ../vt_terminal/README.md        saved
 sked.py             478   sked.py                      

C-x C-f sked.py ? file sked.py is already in the saved buffer sked.py

C-x C-b back to sked

Switch to buffer (default sked.py): 
 scratch.txt           0   scratch.txt                     saved
 edsel.py            385   edsel.py                        saved
 dmacs.py            215   dmacs.py                        saved
 README.md           257   README.md                       saved
 README.md<2>        148   ../README.md                    saved
 README.md<3>         17   ../vt_terminal/README.md        saved
*sked.py             478   sked.py                         saved

C-x C-s  wrote sked.py, 478 lines

Now status line says sked.py<2>   C-x k to get rid of it.  sked.py
is still saved.

C-x C-b sked.py, then C-x C-s changes status line to sked.py<2>
So it is bname() in w() that it renaming current buffer.
What a lot of little nuisance bugs.  Did I really create this one
by revising bname()?  I must have.

Yes, I did.  The case I 'simplified' away was where the new 
candidate buffer name is associated with the *same* filename --
that is just this case!   

I think this case *only* appears in this situation in w() - 
we want to change bufname if w() has an fname arg that
differs from the existing filename - because the user
wanted to write out the buffer with a different filename.
The code and logic are clearer if we code that in w()
not bname() - when I saw it in bname() the other day I 
couldn't recall why it was there so I removed it.
So let's fix it in w().  Done.

Jonathans-MBP-5:editors jon$ git commit -am 'sked.py: in b(), save_buffer only if change buffer successful
> in w(), update buffer name only if buffer saved with different filename'
[pmacs 5ff868a] sked.py: in b(), save_buffer only if change buffer successful in w(), update buffer name only if buffer saved with different filename
 1 file changed, 4 insertions(+), 3 deletions(-)
Jonathans-MBP-5:editors jon$ git push
...

I think that does it.  I think we are finished with pmacs branch 
and can merge it back into ed branch.

BUT the last few days have been so ridden with little bugs I am 
not very confident.  Maybe we should work with it for a couple
of days.  Is updating other.txt, design.txt etc. sufficient exercise?

How about updating notes at bottom of precursors.md with notes
on Brown CS 167/169 Weenix and MIT 6.... JOS.  Done, committed, pushed.

Jonathans-MBP-5:editors jon$ git checkout ed
Switched to branch 'ed'
Your branch is up-to-date with 'origin/ed'.
Jonathans-MBP-5:editors jon$ git merge pmacs
Updating d942ff8..54c284d
Fast-forward
 BRANCH.md             |   7 +-
 doc/precursors.md     |   4 +-
 editors/HOW.md        |  99 +++++++++++++++++++++++
 editors/NOTES.txt     |  80 +++++++++++++++++++
 editors/README.md     | 135 +++++++++++++++++++++++++++++--
 editors/dmacs.py      | 215 ++++++++++++++++++++++++++++++++++++++++++++++++++
 editors/dmacsinit.py  |  10 +++
 editors/edsel.py      |  37 ++++-----
 editors/sked.py       | 110 +++++++++++++++-----------
 editors/skedinit.py   |   7 +-
 vt_terminal/key.py    |   8 +-
 vt_terminal/keyseq.md |  57 +++++++++++++
 vt_terminal/keyseq.py |  94 ++++++++++++++++++++++
 13 files changed, 783 insertions(+), 80 deletions(-)
 create mode 100644 editors/HOW.md
 create mode 100644 editors/NOTES.txt
 create mode 100644 editors/dmacs.py
 create mode 100644 editors/dmacsinit.py
 create mode 100644 vt_terminal/keyseq.md
 create mode 100644 vt_terminal/keyseq.py

Jonathans-MBP-5:editors jon$ git push origin ed
Total 0 (delta 0), reused 0 (delta 0)
remote: To https://github.com/jon-jacky/Piety
   d942ff8..54c284d  ed -> ed

Confirm all the work we did in pmacs branch is now in ed branch,
at github web site.


 3 Jul 2023

Jonathans-MBP-5:editors jon$ git checkout rewrite
Switched to branch 'rewrite'
Your branch is up-to-date with 'origin/rewrite'.
Jonathans-MBP-5:editors jon$ git merge ed
Updating a91e29d..3b6271d
Fast-forward
 BRANCH.md                |  61 +++++-
 DIRECTORIES.md           |   2 +-
 doc/precursors.md        |  62 +++---
 doc/utilities.md         |   6 +-
 editors/HOW.md           |  99 ++++++++++
 editors/NOTES.txt        |  80 ++++++++
 editors/README.md        | 257 +++++++++++++++++++++++++
 editors/dmacs.py         | 215 +++++++++++++++++++++
 editors/dmacsinit.py     |  10 +
 editors/edsel.py         | 385 +++++++++++++++++++++++++++++++++++++
 editors/edselinit.py     |  20 ++
 editors/sked.py          | 479 +++++++++++++++++++++++++++++++++++++++++++++++
 editors/skedinit.py      |  31 +++
 editors/test/lines10.txt |  10 +
 editors/test/lines30.txt |  30 +++
 editors/test/lines40.txt |  40 ++++
 shells/README.md         |  10 -
 shells/pycall.py         |  35 ----
 vt_terminal/display.py   |   6 +-
 vt_terminal/key.py       |   8 +-
 vt_terminal/keyseq.md    |  57 ++++++
 vt_terminal/keyseq.py    |  94 ++++++++++
 22 files changed, 1909 insertions(+), 88 deletions(-)
 create mode 100644 editors/HOW.md
 create mode 100644 editors/NOTES.txt
 create mode 100644 editors/README.md
 create mode 100644 editors/dmacs.py
 create mode 100644 editors/dmacsinit.py
 create mode 100644 editors/edsel.py
 create mode 100644 editors/edselinit.py
 create mode 100644 editors/sked.py
 create mode 100644 editors/skedinit.py
 create mode 100644 editors/test/lines10.txt
 create mode 100644 editors/test/lines30.txt
 create mode 100644 editors/test/lines40.txt
 delete mode 100644 shells/README.md
 delete mode 100644 shells/pycall.py
 create mode 100644 vt_terminal/keyseq.md
 create mode 100644 vt_terminal/keyseq.py

Jonathans-MBP-5:editors jon$ git commit -am 'merge ed branch into rewrite branch'
On branch rewrite
Your branch is ahead of 'origin/rewrite' by 131 commits.
Untracked files:
  ...
nothing added to commit but untracked files present
Jonathans-MBP-5:editors jon$ git push origin rewrite
Total 0 (delta 0), reused 0 (delta 0)
remote: To https://github.com/jon-jacky/Piety
   a91e29d..3b6271d  rewrite -> rewrite

Jonathans-MBP-5:Piety jon$ git commit BRANCH.md -m 'BRANCH.md: merge ed branch back into rewrite branch.
> However, work continues in the ed branch and its branches.'
[rewrite 0ffb70f] BRANCH.md: merge ed branch back into rewrite branch. However, work continues in the ed branch and its branches.
 1 file changed, 4 insertions(+), 2 deletions(-)
Jonathans-MBP-5:Piety jon$ git push
...

Put link to rewrite branch in master branch README

Jonathans-MBP-5:Piety jon$ git branch
  ed
  format
  fparam
  inwindow
* master
  patch
  pmacs
  rewrite
  wrap
Jonathans-MBP-5:Piety jon$ git commit -am 'README.md: add link to rewrite branch at github'
[master 5796a91] README.md: add link to rewrite branch at github
 1 file changed, 5 insertions(+), 3 deletions(-)
Jonathans-MBP-5:Piety jon$ git push origin master
Counting objects: 3, done.
Delta compression using up to 4 threads.
Compressing objects: 100% (3/3), done.
Writing objects: 100% (3/3), 401 bytes | 0 bytes/s, done.
Total 3 (delta 2), reused 0 (delta 0)
remote: Resolving deltas: 100% (2/2), completed with 2 local objects.
remote: To https://github.com/jon-jacky/Piety
   432d975..5796a91  master -> master

Here's what happened when I tried to run the new Piety editors 
in another directory, ~/notes/tech:

Jonathans-MBP-5:~ jon$ cd notes/tech
Jonathans-MBP-5:tech jon$ . ~/Piety/bin/paths
Jonathans-MBP-5:tech jon$ python3 -i
Python 3.9.0 (v3.9.0:9cf6752276, Oct  5 2020, 11:29:23) 
[Clang 6.0 (clang-600.0.57)] on darwin
Type "help", "copyright", "credits" or "license" for more information.
>>> import sked
Traceback (most recent call last):
  File "/Users/jon/Piety/editors/sked.py", line 20, in <module>
    _ = dot # if dot is already defined, then skedinit was already exec'd
NameError: name 'dot' is not defined

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "/Users/jon/Piety/editors/sked.py", line 22, in <module>
    exec(open("skedinit.py").read())
FileNotFoundError: [Errno 2] No such file or directory: 'skedinit.py'

So you can only import sked etc. when you are in Piety/editors, because
we are just opening, not importing, the skedinit.py file and other 
...init.py.  Oh dear, that's a nuisance.


 7 Jul 2023

It is a nuisance.  We want to start sked etc. in the same directory
as the files we are editing, *not* the Piety/editors directory - so
we don't have to type a long path name every time we load a file.

The obvious solution is to include the full path to skedinit.py 
in exec(open(...)...).   BUT that means each installation will hae
to edit the source files -- because no one else will be using /Users/jon/...
At least that would solve the problem for me!  I could use the editors
in any directory on my system.

A more general solution would be to parameterize the path to the ...init.py
in the program, and then assign the parameter outside the program - 
by assigning an environment variable, or by adding another command
line argument to the initial python3 -i ... command.  I think that's 
better because it's the most portable.

    python3 --help shows -c cmd : program passed in as string (terminates
    option list)

So we want something like python3 -i -c "EDITDIR = '/Users/jon/Piety/editors'"
then in sked.py: 
    exec(open(EDITDIR+"skedinit.py").read())

The only disadvantage with the -c method is, I don't see any way 
to default EDITDIR to the empty string.

I think if EDITDIR is an environment variable, then if it's not assigned
it just translates to empty string - but then we have to 
include code to look up the environment variable value.

 8 Jul 2023

I don't like using environment variable because that is an OS
dependent feature that might not be present on all platforms.

So that leaves the python -c option.  Add code to assign
EDITORDIR to '' if it is not already assigned.  Ugh, that's
ugly code.

For now, just fix it for ourselves, as follows:

EDITORDIR = '/Users/jon/Piety/editors' # FIXME? assign via env var or cmd line?
...
    exec(open(EDITORDIR+"skedinit.py").read())

Didn't we find that ~ doesn't work in paths in Python?

>>> f1 = open('/Users/jon/Piety/editors/skedinit.py')
>>> f2 = open('~/Piety/editors/skedinit.py')
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
FileNotFoundError: [Errno 2] No such file or directory: '~/Piety/editors/skedinit.py'

Right.

>>> EDITORDIR = '/Users/jon/Piety/editors/'
>>> EDITORDIR
'/Users/jon/Piety/editors/'
>>> f3 = open(EDITORDIR + 'skedinit.py')
>>> f3
<_io.TextIOWrapper name='/Users/jon/Piety/editors/skedinit.py' mode='r' encoding='UTF-8'>
>>> f3.readlines()
['"""\n', 'skedinit - Define and initialize ...

So that works.  Put it in the code and try it.

Do this work in the ed branch.  Now we're in the rewrite branch.
Did we edit anything in rewrite, other than BRANCH.md ?

Looking above, we see we merged ed into rewrite on Jul 3.  We edited
BRANCH.md in rewrite, then edited top level README.md in master.

So I think we can just set branch back to ed and continue with 
revs to editors there.

Jonathans-MBP-5:editors jon$ git checkout ed
Switched to branch 'ed'
Your branch is up-to-date with 'origin/ed'.


10 Jul 2023

I am getting impatient with the limitations of dmacs - 
in particular, that you can't break a line in the middle
or easily edit in the middle of a line already in the 
buffer.   

Start thinking about pmacs, dmacs successor.  

We would like pmacs to use existing dmacs, edsel, sked
without changing them.

Must abandon builtin input() for entering text - it provides no
way to break a line into two by typing RET in the middle.
Must write new editline module for editing inline.  

The name 'editline' recalls 'readline', and it uses
the same emacs control codes for inline editing.

editline module provides a bunch of editing functions that
each take a string and a point (index into string) and return
an updated string and point.   In a typical application,
like pmacs, the caller will assign the returned string
and point to the same variables that provided the inputs,
so we update the same string and point on each call.

I guess editline will have to update the screen also,
which builtin input() does automatically.

Then we have a new pmacs module that handles inline editing
by calling editline fcns and replaces dmacs handling of RET, C-n and C-p. 

pmacs is structured like dmacs - it is blocking,
after you start pmacs at REPL with >>> pm(), each key is handled
by looking up a callable in the pmacs keycode table, until
you exit back to >>> with M-x.

The line at dot is the input to all the editline fcns and
is updated by all of them.

In dmacs, C-n and C-p now just move dot and update cursor on screen.
Do they need to do more in pmacs?  Each of the editline
functions has already updated the screen in place.

In dmacs, RET opens a line and enters append mode.
In pmacs, RET splits the line at point, leaves prefix on same
line, opens line below and puts suffix there,
and puts cursor at beginning of suffix line.
Prefix line or suffix line, or both, can be empty string.

pmacs is a separate module from editline so our future
non-blocking python interpreter can also use editline.

editline does not handle RET.  Its caller handles RET.
So in pmacs, RET splits the line, in pysh RET submits the
line to the underlying Python interpreter.

pmacs, like dmacs, will have a dictionary from keycodes
to callables.  There will be entries that call all the inline
editing functions in editline.  There will be entries
for RET, C-n, and C-p that call new functions defined
in pmacs.  

We might construct one keycode table in pmacs that 
includes the entries from the table in dmacs, or
we could have code that just calls the lookup
fcn in dmacs for keycodes that are not in the pmacs table.

If we do make one table, we must ensure that 
pmacs entries for RET C-n C-p do not destroy
dmacs entries.  We must always be able to 
return to dmacs.

Exiting pmacs (with M-x) returns to Python >>> 
just like editing dmacs.   From >>> you can restart
dmacs or pmacs.

pmacs is blocking but we can make a non-blocking version.
Then we can work on the timestamp demo.  We don't have
to make a non-blocking pysh interpreter for this - 
we can start nonblocking pmacs task and timestamp
task from the standard (blocking) Python REPL.  Then
exiting from pmacs with M-x stops the tasks.
we can just have a different command from pm() that
starts the nonblocking version of pmacs.

Our editline module should not include command history - 
that is not needed for the editor.

When we make our pysh nonblocking Python interpreter, 
that should include command history.


11 Jul 2023

Now test EDPATH in sked:

Jonathans-MBP-5:~ jon$ cd ~/home
Jonathans-MBP-5:home jon$ pwd
/Users/jon/home
Jonathans-MBP-5:home jon$ . /Users/jon/Piety/bin/paths
Jonathans-MBP-5:home jon$ python3 -i
Python 3.9.0 (v3.9.0:9cf6752276, Oct  5 2020, 11:29:23) 
[Clang 6.0 (clang-600.0.57)] on darwin
Type "help", "copyright", "credits" or "license" for more information.
>>> import sked
>>> from sked import *
>>> sked.buffer
['\n']
>>> sked.buffers
{'scratch.txt': {'bufname': 'scratch.txt', 'filename': 'scratch.txt', 'buffer': ['\n'], 'dot': 0, 'saved': True}}

We haven't fixed edsel yet:

>>> import edsel
Traceback (most recent call last):
  File "/Users/jon/Piety/editors/edsel.py", line 17, in <module>
    _ = flines # if flines is already defined, then edselinit was already exec'd
NameError: name 'flines' is not defined

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "/Users/jon/Piety/editors/edsel.py", line 19, in <module>
    exec(open("edselinit.py").read())
FileNotFoundError: [Errno 2] No such file or directory: 'edselinit.py'

Now fix edsel and dmacs with EDPATH also.


onathans-MBP-5:home jon$ python3 -i
Python 3.9.0 (v3.9.0:9cf6752276, Oct  5 2020, 11:29:23) 
[Clang 6.0 (clang-600.0.57)] on darwin
Type "help", "copyright", "credits" or "license" for more information.
>>> import sked
>>> from sked imoprt *
  File "<stdin>", line 1
    from sked imoprt *
              ^
SyntaxError: invalid syntax
>>> from sked import *
>>> import edsel
>>> from edsel import *
>>> import dmacs
>>> from dmacs import dm
>>> win(24)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "/Users/jon/Piety/editors/edsel.py", line 366, in win
    display.put_cursor(flines+1, 1)
NameError: name 'flines' is not defined


We found all three modules import skedinit.py, not edselinit.py etc.  Fixed.
Now it works.  This session is running with default dir ~/notes/piety

Some problems today.  We got caught in the Appendin... dead end somehow
without using chatgpt at all.   Only escape is M-x then exit the session.

Also we got into the state where C-x C-b etc etc echo as ^X^B in the 
command area.   Did we drop into command mode somehow?


12 Jul 2023

Jonathans-MBP-5:editors jon$ git commit -am 'sked, edsel, dmacs: add EDPATH so editors can be run from any directory
> README.md, NOTES.txt: explain paths script, explain EDPATH'
[ed 12a1fd8] sked, edsel, dmacs: add EDPATH so editors can be run from any directory README.md, NOTES.txt: explain paths script, explain EDPATH
 5 files changed, 24 insertions(+), 5 deletions(-)
Jonathans-MBP-5:editors jon$ git push
...
   3b6271d..12a1fd8  ed -> ed

Jonathans-MBP-5:editors jon$ git branch
* ed
...
Jonathans-MBP-5:editors jon$ git checkout rewrite
Switched to branch 'rewrite'
Your branch is up-to-date with 'origin/rewrite'.
Jonathans-MBP-5:editors jon$ get merge ed
-bash: get: command not found
Jonathans-MBP-5:editors jon$ git merge ed
Merge made by the 'recursive' strategy.
 editors/NOTES.txt |  7 +++++++
 editors/README.md | 10 ++++++++--
 editors/dmacs.py  |  4 +++-
 editors/edsel.py  |  4 +++-
 editors/sked.py   |  4 +++-
 5 files changed, 24 insertions(+), 5 deletions(-)


13 Jul 2023

Revisions merged above not visible at github

Jonathans-MBP-5:editors jon$ git push origin rewrite
...
remote: To https://github.com/jon-jacky/Piety
   0ffb70f..6fa4525  rewrite -> rewrite

Now changes visible in rewrite branch at github.

We could get delete some of these branches:

Jonathans-MBP-5:editors jon$ git branch
  ed
  format
  fparam
  inwindow
  master
  patch
  pmacs
* rewrite
  wrap

We continue work in ed and should keep patch to record a road-not-taken.
See BRANCH.md.  fparam format inwindow can definitely go.  What is wrap?
Maybe an early version of format?  Keep pmacs as a recently merged branch?

Jonathans-MBP-5:editors jon$ git help branch
...
-d, --delete
           Delete a branch. The branch must be fully merged in its upstream
           branch
...

So it looks like git will warn if I try to delete a branch that is not merged.

Jonathans-MBP-5:editors jon$ git branch -d fparam
Deleted branch fparam (was c3ed361).
Jonathans-MBP-5:editors jon$ git branch -d format
Deleted branch format (was 6812d6c).
Jonathans-MBP-5:editors jon$ git branch -d inwindow
Deleted branch inwindow (was 3cd10df).

but

Jonathans-MBP-5:editors jon$ git branch -d wrap
warning: deleting branch 'wrap' that has been merged to
         'refs/remotes/origin/wrap', but not yet merged to HEAD.
Deleted branch wrap (was bc48feb).

So it warns but deletes anyway!  Grr...

Jonathans-MBP-5:editors jon$ git branch
  ed
  master
  patch
  pmacs
* rewrite

Found explanation at L4052.  Seems wrap was early try at fparam branch.
I think wrap was supercedec by fparam.

Yes, L3991 suggests says we intended to delete that wrap branch and 
create a new wrap branch off ed - which we did, it was called fparam.
So I think this is fine.

How to get rid of branches at github?

Jonathans-MBP-5:editors jon$ git push origin rewrite 
Everything up-to-date

They're still all there.

Jonathans-MBP-5:editors jon$ git commit -am 'delete obsolete branches'
On branch rewrite
Your branch is up-to-date with 'origin/rewrite'.

Jonathans-MBP-5:editors jon$ git push origin rewrite 
Everything up-to-date

Still all there.

Look back in notes.version1.txt

Jonathans-MBP-5:editors jon$ git push origin --delete fparam
remote: To https://github.com/jon-jacky/Piety
 - [deleted]         fparam
Jonathans-MBP-5:editors jon$ git push origin --delete format
remote: To https://github.com/jon-jacky/Piety
 - [deleted]         format
Jonathans-MBP-5:editors jon$ git push origin --delete inwindow
remote: To https://github.com/jon-jacky/Piety
 - [deleted]         inwindow
Jonathans-MBP-5:editors jon$ git push origin --delete wrap
remote: To https://github.com/jon-jacky/Piety
 - [deleted]         wrap

Yes, now they are gone at github.

Ready for new branch to work on iline editing.  Well, we already have
pmacs branch.  pmacs2 is not so good.  Call it editline?

Jonathans-MBP-5:editors jon$ git checkout ed
Switched to branch 'ed'
Your branch is up-to-date with 'origin/ed'.
Jonathans-MBP-5:editors jon$ git branch editline
Jonathans-MBP-5:editors jon$ git checkout editline
Switched to branch 'editline'

Jonathans-MBP-5:editors jon$ git commit -am 'BRANCH.md: new editline branch'
[editline a99ba33] BRANCH.md: new editline branch
 1 file changed, 7 insertions(+), 2 deletions(-)
Jonathans-MBP-5:editors jon$ git push origin editline
...
To https://github.com/jon-jacky/Piety
 * [new branch]      editline -> editline

It's there at github.  Begin working on editline module, non-blocking
alternative to readline.

C-k and C-y are different in editline than in dmacs.  pmacs will have to 
handle this somehow.

M-% doesn't accept the empty string as a replacement string - it
understands RET response to prompt to accept default.   
Fix so \\\ three backslashes uses empty string - that is, it
just deletes search string. We have to use '\\\\\\' to get \\\, \ is esc char.

tab_n(n_spaces) and insert_char(keycode) are special cases 
that differ from f(point, line) form.


19 Jul 2023

Now editline mostly works, except for some quirks with 
M-f M-b and C-y after C-k:

Jonathans-MBP-5:editors jon$ python3 -i editline.py
Line to edit: Now is the time

Here I M-b once, puts cursor on space before 'time', then C-k, C-y, get:

Now is thetime

Then press return to exit editor:

Now is the time

So here the line displayed by editline is not the same as line it returns.

Also, emacs M-b moves cursor back to first char in preceding word,
including to first char in line if a word starts there.

emacs M-f moves cursor forward to first char following word,
including the position after the end of the line.

That's the same place emacs puts cursor after C-e.  Then if you type
more it inserts char at end of line, extending line by one char.
That's also how our editline C-e works.

Our editiline M-b puts cursor back to space preceding current word,
so it stops at space after first word, does not reach start of line.

Our editline M-f moves cursor forward to space after current word.
so it stops at space before last word on line, doesn't reach end of line.


22 Jul 2023

Our M-f now works almost like emacs - puts cursor at first space or
punctuation character after word.  BUT stops before last word in line -
does not move to end of line.

Our M-b sometimes works like emacs - put cursor on first char of 
preceding word - but other times puts cursor in space after preceding
word, or on second char of preceding word, it looks quite erratic - !?

>>> line = 'abcde fghij klmno'
>>> point = len(s)-1
>>> s[point]
'o'

>>> import re
>>> start_word = re.compile(r'\W\w') # Non-word char then word char
>>> end_word = re.compile(r'\w\W') # Word char then non-word char
>>> line[point-1::-1]
'nmlk jihgf edcba'
>>> m = end_word.search(line[point-1::-1],0)
>>> m
<re.Match object; span=(3, 5), match='k '>

It's correct up to there

>>> point = (point-1) - m.end()
>>> point
10
>>> line[point]
'j'

That's not right!  We want point == 'k'.

>>> m.start()
3
>>> m.end()
5

>>> point=len(line)-1
>>> point = (point-1) - m.start()
>>> point
12
>>> line[point]
'k'

That's what we want.

point = (point-1) - m.start() in code moves point back to space *before*
word.  Try point - m.start().  Now point is assigned correctly
at first char in word, but then next M-b doesn't move point!

Examine vars when point is at start of word.

Jonathans-MBP-5:editors jon$ python3 -i editline.py
Line to edit: abcde fghij klmno pqrst uvwxyz
abcde fghij klmno pqrst uvwxyz
                  ^
                point here, M-b doesn't move it.

RET
>>>
>>> line
'abcde fghij klmno pqrst uvwxyz'
>>> point
19
>>> line[point]
'q'

But cursor was shown at p - !?

In key.py:
This page says 'Line and column numbers start at 1':
 http://www.umich.edu/~archive/apple2/misc/programmers/vt100.codes.txt

Comment in editline.py:
editline.py:    # move_to_column and start_col are 1-based but point is 0-based

But edline also has:

start_col = 0    # initial tests

def move_to_point(point, line):
    # start_col accounts for prompt or other chars in left margin
    # move_to_column and start_col are 1-based but point is 0-based
    display.move_to_column(start_col + point)

which suggests move_to_column is zero based like point

continue above session:

>>> backward_word(point, line)
                  (19, 'abcde fghij klmno pqrst uvwxyz')
>>> line[point]
'q'

No progress

>>> m = end_word.search(line[point-1::-1],0)
>>> m
<re.Match object; span=(0, 2), match='p '>

Reread docs.python.org on regular expression objects, try this code:

def backward_word(point, line):
    'Move back to first char in word'
    m = end_word.search(line[point-1::-1],1) # search reversed str from point
    if m:
        point = point - m.start()
        point, line = move_to_point(point, line)
    return point, line

It works!  It does not go all the way to start of line.
Also when starting at end of line it takes two M-b to get to
start of last word.
BUT this is good enough for now.

Jonathans-MBP-5:editors jon$ git commit -am 'add editline module
> dmacs: in M-%, use \\\ to replace old string with empty string
> '
[editline d7a4e31] add editline module dmacs: in M-%, use \\\ to replace old string with empty string
 2 files changed, 5 insertions(+), 4 deletions(-)

Jonathans-MBP-5:editors jon$ git add editline.py

Jonathans-MBP-5:editors jon$ git commit -am 'add editline module'
[editline 022b11a] add editline module
 1 file changed, 177 insertions(+)
 create mode 100644 editors/editline.py

Jonathans-MBP-5:editors jon$ git commit -am 'add editline module'
[editline 022b11a] add editline module
 1 file changed, 177 insertions(+)
 create mode 100644 editors/editline.py
...
remote: To https://github.com/jon-jacky/Piety
   a99ba33..022b11a  editline -> editline

Look at github, new editline.py doesn't have blank lines betwen functions - !?
Also appears that way in more, but not in edsel.  What about emacs?  No
blank lines there either.  Hmn.  Try editing them in, in edsel.
C-k blank line we see, then RET to enter append mode then RET .
That seems to fix it - tried first after move_to_point before move_beginning.

That does fix in in 'more'

Jonathans-MBP-5:editors jon$ git commit -am 'editline: restore blank lines between functions
add FIXME? comments to forward_,backward_word about not reaching end,start of line'
[editline 6841e19] editline: restore blank lines between functions add FIXME? comments to forward_,backward_word about not reaching end,start of line
 1 file changed, 20 insertions(+), 2 deletions(-)
Jonathans-MBP-5:editors jon$ git push
...

M-d doesn't quite work - leaves the last char in the word in the string.

Jonathans-MBP-5:editors jon$ python3 -i editline.py
Line to edit: abcde fghij klmno pqrst uvwxyz

C-a M-f M-f  M-d, now we see

abcde fghijo pqrst uvwxyz

Then type RET

abcde fghij  pqrst uvwxyz
>>> line
'abcde fghij  pqrst uvwxyz'

So after M-d it displayed ...ijo but the string actually contained ...ij

>>> point
12
>>> line[point]
' '

Jonathans-MBP-5:editors jon$ python3 -i editline.py
Line to edit: abcde fghij klmno pqrst uvwxyz

C-a M-f M-f M-d C-y 

abcde fghijklmnoo pqrst uvwxyz

RET

abcde fghij klmno pqrst uvwxyz
>>> line
'abcde fghij klmno pqrst uvwxyz'
>>> point
17

So it looks like the string is right but the editline display is wrong.

BUT on an earlier M-d C-y attempt we got

Jonathans-MBP-5:editors jon$ python3 -i editline.py
Line to edit: abcdef ghijk lmnop qrstu vwxyz
abcdefTraceback (most recent call last):
                                          File "/Users/jon/Piety/editors/editline.py", line 195, in <module>
                                main()
                                        File "/Users/jon/Piety/editors/editline.py", line 187, in main
                          point, line = fcn(point, line)
                                                        TypeError: cannot unpack non-iterable NoneType object

26 Jul 2023

editline, add refresh() to confirm line is being updated 

Jonathans-MBP-5:editors jon$ python3 -i editline.py
abLine to edit: abcde fghij klmno pqrst uvwxyz
abcde fghij klXmno pqrst uvwxyz
               ^

Move point to l type X then point is at m
Now type C-l refresh

abcde fghij klmXno pqrst uvwxyz
               ^

Note x follows m not L, point is at X.   Now type RET

abcde fghij klmXno pqrst uvwxyz

So the returned string is the same as refresh() drew.

>>> point
16
>>> line
'abcde fghij klmXno pqrst uvwxyz'
>>> line[point]
'n'

point is at n not X.   Is this confusion about point the explanation
for insertion occurring in wrong place?

Line to edit: abcdefg
abcdefg
       ^

cursor at space past last char
C-a to move cursor to start of line

abcdefg
^

Then press RET

>>> point
0
>>> line
'abcdefg'
>>> line[point]
'a'

So that's right.

Jonathans-MBP-5:editors jon$ python3 -i editline.py
abLine to edit: abcdefg
abcdefg
       ^
cursor is after last char
press RET

abcdefg
>>> point
7
>>> line
'abcdefg'
>>> line[point]
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
IndexError: string index out of range

That's correct.  Cursor past last character.   We have:

def insert_char(keycode, point, line): # not in keymap so keycode arg is okay
    line = (line[:point] + keycode + line[point:])
    point += 1
    display.insert_char(keycode)
    return point, line

Where does insert_char insert the char?  At the position of the
blinking cursor?  In display.py we have:

ef insert_char(key):
    'Insert character in front of cursor'
    putstr((ich % 1) + key) # open space to insert char

def insert_string(string):
    putstr((ich % len(string)) + string)

def delete_char():
    'Delete character under the cursor'
    putstr(dch % 1)

where

ich = csi+'%d@'  # insert chars, make room for %d chars at current position

dch = csi+'%dP'  # delete chars, remove %d chars at current position

Gather more information:

Jonathans-MBP-5:editors jon$ python3 -i editline.py
Line to edit: abcdef
abcdef
      ^
cursor after last char
type X

abcdefX
       ^
cursor after new last char.  Type C-l refresh

abcdefX
      ^
Now cursor is at last char. 

>>> point
7
>>> line
'abcdefX'
>>> line[point]
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
IndexError: string index out of range

So refresh showed the cursor in the wrong place.
Cursor position was correct before refresh().

Jonathans-MBP-5:editors jon$ python3 -i editline.py
Line to edit: abcdef
abcdef
^
Cursor is at first character.  Type X

Xabcdef
 ^

Now cursor is under character after X.  So insert_char inserts
char *before* char at cursor.

Now type C-l refresh:

Xabcdef
^

Now cursor is under X, char we just inserted.

Type RET

Xabcdef

>>> point
1
>>> line
'Xabcdef'
>>> line[point]
'a'

But this isn't what is shown - cursor is now shown at X not a

>>> line[1]
'a'
>>> line[0]
'X'

This is what refresh shows.   I think refresh is not showing the
cursor at the correct position.  Let's fix that first.
But first, more tests:

Jonathans-MBP-5:editors jon$ python3 -i editline.py
Line to edit: abcdef
abcdef
      ^

Then C-a to put cursor at the beginning

abcdef
^

now type C-l, refresh

abcdef
^

Now type RET

abcdef
>>> point
0
>>> line
'abcdef'
>>> line[point]
'a'

That's correct.

Jonathans-MBP-5:editors jon$ python3 -i editline.py
Line to edit: abcdef
abcdef
      ^

C-a to put cursor at start, then C-f C-f put cursor at c

abcdef
  ^

Now type C-l refresh

abcdef
 ^
Puts cursor under b not c.  Type RET

abcdef
>>> point
2
>>> line
'abcdef'
>>> line[point]
'c'

That's correct but it's not what refresh showed.

So refresh draws cursor at char before its actual position,
except at position 0.  It's as if refresh cursor position is 1-based
not zero based.

Fix move_to_point(.... point + 1).  move_to_point is used by refresh,
move_beginning, move_end, forward_word, backward_word.

Now test:

Jonathans-MBP-5:editors jon$ python3 -i editline.py
Line to edit: abcdef
abcdef
      ^
Now type C-l refresh

abcdef
      ^

cursor remains after end

>>> point
6
>>> line[point]
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
IndexError: string index out of range

That's correct.

Jonathans-MBP-5:editors jon$ python3 -i editline.py
Line to edit: abcdef
abcdef
      ^

Then type C-a to move cursor to start

abcdef
^

Then type C-l refresh

abcdef
^

cursor remains at first char.  Type RET

abcdef
>>> point
0
>>> line[point]
'a'

That's correct.

Jonathans-MBP-5:editors jon$ python3 -i editline.py
Line to edit: abcdef
abcdef
      ^

Type C-a to move cursor to start, then C-f C-f to put cursor at 'c

abcdef
  ^

Now type C-l refresh.  Cursor remains under c.  Type RET

>>> point
2
>>> line[point]
'c'

That's correct.   So C-l refresh is drawing the cursor at the right place.
Then do test where I type initial string abcdef then refresh, then C-b
all the way to first char, typing C-l after each C-b.  Then C-f all the
way back to the end, C-l after each C-f.   After each refresh, cursor does
not move.  So it does seem C-l refresh is drawing the cursor in the right place.

Now what about M-f and M-b, foward/backward word?
As expected, M-b puts cursor on *second* char of each word not first,
M-f puts cursor on first char of next word, not space after word.
But is that where point is?  Use refresh, then exit and print point.

C-l does not move cursor after M-f or M-b

Jonathans-MBP-5:editors jon$ python3 -i editline.py
aLine to edit: abcde fghij klmno pqrst uvwxyz
abcde fghij klmno pqrst uvwxyz
             ^
  cursor is on second letter in word after M-b

abcde fghij klmno pqrst uvwxyz
>>> point
13
>>> line[point]
'l'

So point and line are rendered correctly.  M-b is putting cursor at wrong char. 

Jonathans-MBP-5:editors jon$ python3 -i editline.py
Line to edit: abcde fghij klmno pqrst uvwxyz
abcde fghij klmno pqrst uvwxyz
            ^
        M-f puts cursor on first char of next word.

abcde fghij klmno pqrst uvwxyz
>>> point
12
>>> line[point]
'k'

Again, point and line are rendered correctly, M-f is putting cursor at wrong ch.
Fix M-f and M-b now.  They should both leave cursor one char ahead, 
one smaller point.  Just -1 in foward_word, bacward_word.

Tested.  That works, though it looks like a hack.

Jonathans-MBP-5:editors jon$ python3 -i editline.py
Line to edit: abcde fghij klnmo pqrst
abcde fghij klnmo pqrst
                       ^

Now C-a, C-e

abcde fghij klnmo pqrst
                        ^
Now cursor is *two* char past last char.  C-l does not move it.

>>> point
24

That is two spaces past the end.   So initially string and point
are displayed correctly but C-e moves point 1 char too far.
In move_end, change len(line) + 1 to just len(line)


27 Jul 2023

Test fixed C-e - now it works, moves cursor to space after last character.

Do readline M-f M-b work like emacs and our editline?
Yes, M-f moves to space *after* word and M-b moves to first char of preceding
word.

Now work on insert and delete chars, then M-d delete work and C-y yank.

In emacs, insert char (just type a printing char) inserts the char
*before* the char under the cursor.  When the cursor is at the
end of the line, just after the last character, typing a character
appends it to the line, extending the line by one more character.

In emacs, C-d deletes the character under the cursor.  C-d at the
end of the line, after the last character, joins the following line (with
no added space between the lines)
In readline (at the Python prompt) it's the same except C-d at the end
of the line does nothing.

In emacs, the DEL key deletes the character *before* the cursor.
At the beginning of the line, it joins this line to the preceding line.
In readline, it's the same except DEL at the start of the line does nothing.

What does our editline do with insert char?  It also inserts before
the character at the cursor:

Jonathans-MBP-5:editors jon$ python3 -i editline.py
Line to edit: abcde fghij 
abcde fghij
           ^

Now C-a then C-f and type X five times:

XabcdXe XfghiXjX

Now type C-l refresh.  It doesn't change.  Now type RET

XabcdXe XfghiXjX
>>> line
'XabcdXe XfghiXjX'

So our insert_char already works as it should.  Now try C-d:

onathans-MBP-5:editors jon$ python3 -i editline.py
Line to edit: abcde fghij klmno

After DEL then C-b and DEL, last DEL when cursor over starting 'a':
DEL does delete the character before the cursor, except when it's at 'a':

abcefghjklmn

Now C-l refresh then RET

abcefghjklmn
>>> line
'abcefghjklmn'

refresh doesn't change line, returned string is what editline displays,
so our DEL works like in emacs.

Now try our C-d.

Jonathans-MBP-5:editors jon$ python3 -i editline.py
Line to edit: abcde fghij klmno

Then edit with C-b and C-d:

bcd ghi lmn

Then C-l refresh

bcd ghi lmn
>>> line
'bcd ghi lmn'

refresh doesn't change it, and returned string is what editline shows,
so our C-d works like in emacs.

Next try M-d, delete word.

In emacs, M-d at the start of the line deletes all the characters
up to *but not including* the first space.   That is, it deletes
all the characters that M-f foward-word skips over.  It leaves
the cursor on the first character *after* those, which is where
M-f would put the cursor also.

In emacs, type M-d in the space between words and it deletes that space
and the word, leaving the cursor at the first space *after* the word.

In emacs, type M-d in the midst of a word, it deletes the character under the
cursor and the rest of the word, leaving the cursor at the first space
*after* the word.

In emacs, type M-d before or in the midst of the last word, it deletes
the character under the cursor to the end of the line, leaving the cursor
after the last remaining character (that preceded the cursor before M-d).

Now let's try our editline M-d.

It works like emacs *BUT* it doesn't delete the last word in the line!
Just what you would expect because it uses the same code as M-f which also
doesn't jump over the last word in the line.

In emacs, C-y inserts the contents of the yank buffer starting at the
current cursor position, then leaves the cursor after the last yanked
character.  Note that M-d delete word followed by C-y yank
has the effect of restoring the preceding state of the line.

Our C-y behaves the same way.  

We would like to use repeated M-d to cut a sequence of words, the C-y
to paste them all back.   Doesn't emacs do that?  Yes, also a series of
M-d followed by C-k to delete to end of line, then C-y restores the 
deleted words followed by the end of the line.   However emacs C-u
does *not* cut from cursor to start of line.  What about readline?

readline (in Python REPL) C-u deletes the *whole* line, not just 
the prefix.  Then C-y replaces the whole line.

(emacs C-u is (universal-argument), you can use to prefix numeric args etc.)

Currently in our editline, repeated M-d then C-y only yanks the *last* deleted
word.   We can fix this using the same technique as in dmacs for C-k, using
prev_key.  BUT here use prev_fcn instead so it continues to work if we
use a different keymap.

That's some work.  In the meantime return to dm.py script.
After running bin/paths, can start it anywhere with python3 -im dm
Very nice.   Confirm all the modules/functions/commands are 
in the right namespaces, in particular the commands are in the REPL.


 1 Aug 2023

Yesterday, 31 Jul, tried git pull into backup repo on hard disk,
/Volumes/WD2TB/Piety.   git pull didn't work, various messages 
about conflicts or uncommitted files or unmerged files.   Tried
Renamed to Piety.cant_merge and tried git clone.   But then I 
got repo with master branch.  Tried git branch editline the git checkout
editline, apparently didn't work, instead created a *new* branch named
editline.   Just rm -rf the Piety directory I just cloned.

Try clone again. Oh, but WD2TB is not mounted now.  Never mind.

Return to coding: in editline, consecutive M-d, C-k, C-u should append to 
yank buffer so I can cut then paste a whole sequence of words.

First confirm I can C-y to restore text cut by single M-d C-k C-u.  Confirmed.

Confirm subsequent M-d overwrite yank buffer, I can only C-y the most
recent word.  Confirmed.

On the way, I mistakenly type M-e and the program crashed.   Must fix.

...
                  File "/Users/jon/Piety/editors/editline.py", line 210, in <module>
        main()
                    File "/Users/jon/Piety/editors/editline.py", line 202, in
    main  point, line = fcn(point, line)
                                                                                  point, line = fcn(point, line)
                                    TypeError: cannot unpack non-iterable
    NoneType object

Try to repeat that. Yes, M-e causes that same crash.
But fcn = keymap.get(.... (key.bel)) is supposed to just beep if unsupported
keycode is typed.     What is keyseq doing?

Jonathans-MBP-5:vt_terminal jon$ python3 -im keyseq
> (type M-f, RET) 
[[], ['\x1b', 'f'], ['\r']]

Jonathans-MBP-5:vt_terminal jon$ python3 -im keyseq
> (type M-e, RET)
[[], ['\x1b', 'e'], ['\r']]

keyseq is doing the right thing.  But get() is not returning point, line.

Fixed, now no crash on M-e or other unrecognized keycodes.  BUT no key.bel
beep either - !?


 2 Aug 2023

Just go on and handle consecutive M-d C-k C-u, analogous to consecutive
C-k in dmacs.

Not working.  Put in debug print in kill_word

        cut_word = line[point:m.start()+1]
        # repeat kill_word to append successive words to yank buffer
        print(yank_buffer, cut_word, prev_fcn, cut_fcns) # DEBUG
        yank_buffer = (yank_buffer + cut_word if prev_fcn in cut_fcns
                       else cut_word)



Jonathans-MBP-5:editors jon$ python3 -im editline
Line to edit: abcde fghij klmno pqrst uvwxyz

    Now type:  C-a M-d C-y M-d M-d C-y RET

     abcde <function move_beginning at 0x1078b5040> (<function kill_word at
    0x1078b5550>, <function kill_line at 0x1078b55e0>, <function discard at
    0x1078b5670>)
                                                                                                                                                             abcdeabcde  fghij <function yank at 0x1078b5700> (<function kill_word at 0x1078b5550>, <function kill_line at 0x1078b55e0>, <function discard at 0x1078b5670>)
    abcdeabcde  fghij <function yank at 0x1078b5700> (<function kill_word at
    0x1078b5550>, <function kill_line at 0x1078b55e0>, <function discard at
    0x1078b5670>)

      fghij  klmno <function kill_word at 0x1078b5550> (<function kill_word at
    0x1078b5550>, <function kill_line at 0x1078b55e0>, <function discard at
    0x1078b5670>)
                                                                                                                                                           fghij klmno
     fghij klmno
    abcde fghij klmno pqrst uvwxyz

>>> line
'abcde fghij klmno pqrst uvwxyz'
>>> yank_buffer
' fghij klmno'

That looks like it did the right thing
Repeat - we get the same results.  Now comment out print and try again.
Yes, it does the right thing:

Jonathans-MBP-5:editors jon$ python3 -im editline
Line to edit: abcde fghij klmno pqrst uvwxyz
abcde fghij klmno pqrst uvwxyz
abcde fghij klmno pqrst uvwxyz
>>> line
'abcde fghij klmno pqrst uvwxyz'
>>> yank_buffer
' fghij klmno'

after last yank we did see fghij klmno get inserted in line.

Jonathans-MBP-5:editors jon$ git commit -am 'editline, kill_word: append consecutive killed words to yank buffer'
[editline 522347f] editline, kill_word: append consecutive killed words to yank buffer
 1 file changed, 15 insertions(+), 8 deletions(-)
Jonathans-MBP-5:editors jon$ git push
...

Later - what about global variables in editline, like yank_buffer and
inline_yank.   Shouldn't these be handled in an editLine_init, like
the other editor modules?   Then we don't need line and point to be
args of every method.   Caller like pmacs can reassign line and point
as needed when line moves around. 

M-x should return to Python >>> even when editline is active.
That way we can use Python itself to inspect point,line, yank_buffer etc.
(But ... what if we are using same globals for editline in pmacs and
editline in python?   That's okay, M-x reassigns those globals, then
at pysh command line, use prefix: pysh.line etc.

We should rename sked.yank (buffer) to yank_buffer, or maybe ybuffer.


 3 Aug 2023

Fix kill_line and discard to append to yank_buffer when consecutive kills.

Jonathans-MBP-5:editors jon$ git commit -am 'editline: fix kill_line, discard to work like kill_word
> append to yank buffer when doing consecutive kills'
[editline f01f793] editline: fix kill_line, discard to work like kill_word append to yank buffer when doing consecutive kills
 1 file changed, 23 insertions(+), 15 deletions(-)

Not on net so can't push now.

Next fix dmacs kill_line like editline - test prev_fcn not prev_key so 
it continues to work if we change keymap.

Code done.  A couple of things are affected:

 def request_search():
-    if not prev_k in (key.C_s, key.C_r):
+    if not prev_fcn in (fwd_search, bkwd_search):


 def kill_line():
     'Delete single line, accumulate consecutive deleted lines in yank buffer'
-    if prev_k != key.C_k: # first C_k, rewrite yank buffer
+    if prev_fcn != kill_line # first kill_line, rewrite yank buffer

They both work.

Jonathans-MBP-5:editors jon$ git commit -am 'dmacsinit, dmacs: replace prev_k(ey) with prev_fcn'
[editline abaeda8] dmacsinit, dmacs: replace prev_k(ey) with prev_fcn
 2 files changed, 6 insertions(+), 7 deletions(-)

Still not on the net, can't push.

Later:

Jonathans-MBP-5:editors jon$ git push
...

Next, separate editlineinit out of editline.   Also simplify:
get rid of inline_yank, this module should have nothing about 
the context where it runs.   inline_yank (or whatever we use instead)
should be in pmacs.py.  Etc.

Jonathans-MBP-5:editors jon$ git commit -am 'editline: separate out editlineinit'
[editline 8e74171] editline: separate out editlineinit
 2 files changed, 36 insertions(+), 21 deletions(-)
 create mode 100644 editors/editlineinit.py
Jonathans-MBP-5:editors jon$ git push
...

Next, remove point, line args from all the editline fcns, just declar
them global in fcn bodies.

Will we be able to use this scheme to edit lines in a buffer?  Test:


>>> buf = [ 'abcde fghij', 'klmno pqrst', 'uvw xyz']
>>> buf
['abcde fghij', 'klmno pqrst', 'uvw xyz']
>>> buf[0]
'abcde fghij'
>>> s = buf[0]
>>> s is buf[0]
True
>>> s = s[:5]
>>> s
'abcde'
>>> buf[0]
'abcde fghij'
>>> s is buf[0]
False

No, it doesn't work like we want becuase strings are immutable.
Any s = ... assigns a *new* string to s.

>>> buf[0] = s
>>> s is buf[0]
True
>>> buf[0]
'abcde'

So it can work if we remember to assign s back to buffer
when we are done editing in that line.

I think the problem is, buffer is a list of strings - which are
immutable.   So packaging the buffer as a class wouldn't help.

BUT arrays are mutable, what if we pass the array element to the
editing fcn?

>>> def first5(s):
...     s = s[:5]
... 
>>> first5(buf[1
... ])
>>> buf[1]
'klmno pqrst'
>>> buf[1] = first5(buf[1])
>>> buf[1]

because first5 returns None

>>> buf
['abcde', None, 'uvw xyz']

Now return updated s

>>> def xfirst5(s):
...     s = s[:5]
...     return s
... 

>>> buf[1] = 'fghij klmno'
>>> buf
['abcde', 'fghij klmno', 'uvw xyz']
>>> buf[1] = xfirst5(buf[1])
>>> buf[1]
'fghij'
>>> buf
['abcde', 'fghij', 'uvw xyz']

We have to assign returned value to immutable string to see update.

Here is what we plan to do in editline:

>>> def yfirst5():
...     global s
...     s = s[:5]
... 
>>> s = buf[2]
>>> s
'uvw xyz'
>>> yfirst5()
>>> s
'uvw x'
>>> buf[2]
'uvw xyz'
>>> buf[2] = s
>>> buf[2]
'uvw x'
>>> buf
['abcde', 'fghij', 'uvw x']

Here s is like line in editline.  We still have to assign line back 
to buffer[dot] after we're done editing in line.

Until we do that, line in editline will be different from line in buffer.

After than, change editline main() fcn to el() analogous to dm() so 
we can run it in same python session we are editing it, like everything else.


 5 Aug 2023

Let's try passing a mutable object to function that updates string:

>>> buf
['abcde', 'fghij', 'uvw x']
>>> def first3(buf, iline):
...     buf[iline] = buf[iline][:3]
... 
>>> first3(buf, 1)
>>> buf
['abcde', 'fgh', 'uvw x']

That worked!  Can we assign sked.buffer to editline.buffer and
sked.dot to editline.iline and update in the buffer on each call
to an editline fcn?

>>> skedbuf = ['abcde fghij', 'klmno pqrst', 'uvw xyz']
>>> lebuf = skedbuf
>>> lebuf is skedbuf
True
>>> lebuf
['abcde fghij', 'klmno pqrst', 'uvw xyz']
>>> first3(lebuf, 1)
>>> lebuf
['abcde fghij', 'klm', 'uvw xyz']
>>> skedbuf
['abcde fghij', 'klm', 'uvw xyz']

Yes! This is what we want!

>>> dot = 2
>>> first3(lebuf, dot)
>>> lebuf
['abcde fghij', 'klm', 'uvw']
>>> skedbuf
['abcde fghij', 'klm', 'uvw']

Let's pass array of string and index to each editline fcn. 
Then body of function updates string at that index.
That seems the most versatile.
Could even return the updated string also.

Later.  Nah, forget all that.  Just keep it as it is: each editline
fcn takes point, line args and returns updated point, line.   Then
the caller handles that - don't bake in any assumptions about the 
environment where it will be used.

Jonathans-MBP-5:editors jon$ git commit -am 'editline: replace standalone main() with el() to call from Python prompt'
[editline 7192f49] editline: replace standalone main() with el() to call from Python prompt
 2 files changed, 9 insertions(+), 18 deletions(-)
Jonathans-MBP-5:editors jon$ git push
...

Are we ready to start working on pmacs itself?  
Review ideas at L10715 on 10 July


 6 Aug 2023

Begin coding pmacs ('poor emacs' or 'pathetic emacs' - the latter suggested
by chatgpt, see notes/opengpt/notes.txt for today).

Unlike present emacs, must separate pm() with the main loop from 
pmcmd(), executes a single command, includes logic to select editline 
or dmacs.

In dmacs, must also separate dmcmd() single command from dm() main loop,
so dmcmd can be called from pm().


 8 Aug 2023

I didn't include some recent commits in notes above.

Now in editline we just keep appending to yank_buffer - prev_fcn
doesn't seem to be having its effect.  Oh, that's because we're 
calling fcn after assigning prev_fcn, duh.  Fixed.

Jonathans-MBP-5:editors jon$ git commit -am 'editline: elglob calls functional elcmd, updates global point, line'
[editline 0af4559] editline: elglob calls functional elcmd, updates global point, line
 1 file changed, 4 insertions(+), 3 deletions(-)
Jonathans-MBP-5:editors jon$ git push
...

Testing insert_char_param - it's still not updating buffer.

Add debug prints - now it seems to be working:

>>> el()
id(buffer) in caller el: 4544073792

axyzid(buffer) in called insert_char 4544073792

                                               buffer in called insert_char ['axyzA']

                                                                                     A

in called insert_char 4544073792

                                 buffer in called insert_char ['axyzAB']

                                                                        B
>>> editline.buffer
['axyzAB']

Now does it work if we comment out debug prints?

Yes!

Jonathans-MBP-5:editors jon$ git commit -am 'editline: add elcmd_aref, elinsert_aref to update mutable buffer array parameter'
[editline b1973f8] editline: add elcmd_aref, elinsert_aref to update mutable buffer array parameter
 2 files changed, 32 insertions(+), 8 deletions(-)
Jonathans-MBP-5:editors jon$ git push
...


See if we can merge insert_char into elcmd so we can eliminate 
elinsert_aref and the special case for insert in el.


9 Aug 2023

Jonathans-MBP-5:editors jon$ git commit -am 'editline: include insert_char in elcmd, omit elinsert_aref now unnecessary'
[editline f1254b1] editline: include insert_char in elcmd, omit elinsert_aref now unnecessary
 1 file changed, 34 insertions(+), 37 deletions(-)
Jonathans-MBP-5:editors jon$ git push
...

We notice that repeating C-r and C-s doesn't just search for the next
occurence, it also prompts for search string.   This used to work.
Is it confusion due to prev_key vs prev_fcn ?   Fix now.

dmacs fwd_search, bkwd_search both call request_search which tests prev_fcn.
Is prev_fcn not getting assigned correctly?

Right, dmcmd which invokes a single dmacs command assigns prev_fcn
BUT says 'global prev_cmd' not prev_fcn.  Fix now, C-x C-r to reload,
from dmacs import dm, dm() - now it works correctly, yay!
Did we really need to 'from dmacs ...' ?

Move on to pmacs.  I am eager to see if our _aref trick will work
seamlessly on sked.buffer and sked.dot as both are reassigned.


10 Aug 2023

For pmacs, look at version1 edsel fcns open_line (key.cr),
join_prev called by delete_backward_char (key.bs, key.delete),
join_next called by delete_char (key.C_d)


11 Aug 2023

Do we really need to pass and return point, line in the pmacs functions?
The only reason I can see is a few functions have branches where they
call functions in editline that works that way.   This seems tangled 
with the point, line -> buffer[dot] conversion in cmd_aref()

In version1 console, __init__ assigns self.inline_yank = True.
Then so does kill_word kill_line discard.

In version1 edsel, cut sets inline_yank = False.  Then yank
tests inline_yank, if True calls console yank() otherwise does
multiline yank.

Have to assign in sked y() so call it lines_yank there, 
lines_yank = True means multiline yank, False means inline word yank

Assign ed.lines_yank = False in editline kill_word kill_line discard

pmacs is almost ready to test.  The only think left is getting 
open_line to update the graphics.  Check all the other fcns.


13 Aug 2023

Decide to fix pmacs aref usage before testing. 
Some pmacs fcns already update buffer.   Fix others ro 
Fix others to update buffer directly so pmcmd doesn't need
to return anything and we can omit pmcmd_aref.

 $ cp pmacs.py pmacs_aref.py\

Now see if we can edit aref out of pmacs.py.

pmacs now ready to test, I think.  should diff pmacs.py pmacs_aref.py again.
to be sure, when I am less fatigued.

Can test pmacs in stages.

1.  Just use the dmacs functions - use pmacs as if it were dmacs.

2.  Try the editline functions on various lines in the window
    reached by C_n C_p

3.  Try pmacs refresh, C_l

4.  Try other pmacs functions.  RET open_line might have problems.

Oh dear, I realized I forgot something.  Many edsel functions set the cursor
back to the Python command line but in pmacs we need the cursor to remain
in the window -- except for M_x and some other cases.
This was a big nuisance in version1 - we had to keep track of command_mode.
I think this shouldn't be necessary.

At least we got pmacs to import without errors.

Jonathans-MBP-5:editors jon$ git commit -am 'pmacs etc.: first draft of pmacs, not yet tested'
[editline 6b2a873] pmacs etc.: first draft of pmacs, not yet tested
 5 files changed, 93 insertions(+), 14 deletions(-)
Jonathans-MBP-5:editors jon$ git push
...

Finally got pm() to start without errors.  Try the dmacs keys:
C_n, C_p work.   C_k has no apparent effect.  C_l clears screen
and puts python prompt >>> at the top of the screen.   Then
refresh() restores screen, we see line with only k on it.
Did pmacs insert that or replace previous line?   C_y crashes:
'sked' has no attribute 'yank_lines'  C_x b works.  C_s works.
C_x C_b works.

Ah, yank_lines is defined in skedinit.py, which won't be reloaded.
Also dmacs redefines C_y for yank_lines (vs. yank word).
C_x C_b works. C_at and C_W works, but C_y crashes.
C_v, M_v work.

I didn't try them all but it looks like dmacs works in pmacs,
which means top-level logic in pm fcn works.


15 Aug 2023

Our scheme in pmacs for choosing between edsel kill_line
and editline kill_line, using yank_lines, imitating version1,
doesn't really work.  It depends on sked.d setting yank_lines=True
edsel kill_line (which can also accumulate lines in yank buffer)
which is invoked by C_k invokes sked.d.  Also dmacs C_w invokes
edsel.d which invokes sked.d 

Oh, currently pmacs has no fcn to choose between edsel.kill_line
and editline.kill_line, pm() uses editline keycodes first.  
So it will always use editline.kill_line which always sets
yank_lines to False.   So in our present code, yank_lines is
always disabled.  Fine, let's test that.

No, lets make a pmacs.py kill_line which, for now, just uses
dmacs kill line. It's a placeholder for more logic later.  Done.

How did version1 choose between whole line and inline kill_line?

Later - test pm() again, first test dmacs branch in pm()
except keys redefined by pm: cr, delete, bs, C_d C_k C_y C_l

Test C_n C_p C_v M-v M_lt M_gt C_s C_r C_at C_x + C_x C_w but C_y has no effect
However sked.yank does have the correct contents.
M_q M_carat C_c + <  C_c + >  C_x + b C_x + C_b  C_x + C_f C_x + C_r 

So all the unchanged dmacs commands are working in pmacs as they should.

Now try editline commands.  Try C_f C_f C_f C_b C_b C_b.
They work - but on the command line at the bottom of the term window!
Duh, we forgot about managing the cursor position.   The marker shows
dot in the window, cursor remains in the Python command line.  Oh dear.

Well, at least this does show that editline.elcmd_aref is working.
It would be helpful to use refresh to see if it editline commands update
the line in the buffer.

I tried typing characters while cursor at Python command line.  Now
cursor does *not* advance, no characters echo, and C_l shows no change
in buffer.   So maybe elcmd_aref is not even calling editline insert_char.
C_f and C_b might just be moving cursor via terminal window itself,
not our code.  No, I don't think that can be right - terminal doesn't
know anthing about C_f C_b.


16 Aug 2023

Look again at test code and elcmd_aref in editline.py.  Does is still work?
Are we doing the same thing in pmacs elcmd case?

It's suspicious that arg names and updated mutable variables in 
editline.elcmd_araf are the same as the names of the global variables
in editlineinit.  Are we kidding ourselves - are we really just upating
that named global buffer from the function body? 
It's in the same module, there is no module qualification.

First, change name of buffer in editlineinit so it is different from 
name in elcmd_aref arg list and fcn body.  See if that differently 
named buffer updates.   Then make a little test module with a buffer 
in it, so we can test with name qualified by module name.

Can't we just do this interactively, at the repl, without editing anything?

>>> buffer2 = [ str() ]
>>> dot2 = 0
>>> buffer2
['']
>>> editline.elcmd_aref
<function elcmd_aref at 0x10ee9a430>
>>> editline.elcmd_aref('a',buffer2,dot2)
a>>>buffer2
['a']

Note that 'a' echoed.

>>> dot2
0
>>> editline.point
4

- !?

>>> editline.elcmd_aref('b',buffer2,dot2)
b>>>buffer2
['ab']
>>> dot2
0
>>> editline.point
5
>>> editline.elcmd_aref('c',buffer2,dot2)
c>>> editline.elcmd_aref('d',buffer2,dot2)
d>>> editline.elcmd_aref('e',buffer2,dot2)
e>>>buffer2
['abcde']
>>> editline.elcmd_aref(' ',buffer2,dot2)
 >>> editline.elcmd_aref('f',buffer2,dot2)
f>>> editline.elcmd_aref('g',buffer2,dot2)
g>>> editline.elcmd_aref('h',buffer2,dot2)
h>>> editline.elcmd_aref('i',buffer2,dot2)
i>>> editline.elcmd_aref('j',buffer2,dot2)
j>>>buffer2
['abcde fghij']
>>> editline.point
14
>>> import key
>>> editline.elcmd_aref(key.C_b,buffer2,dot2)
>>> buffer2
['abcde fghij']
>>> editline.point
13
>>> buffer2[dot2][editline.point]
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
IndexError: string index out of range
>>> buffer2[dot2][editline.point-sked.lmargin]
'i'

But

>>> editline.start_col
0

How did sked.lmargin get in there - !?

>>> editline.elcmd_aref(key.M_b,buffer2,dot2)
        >>> buffer2
['abcde fghij']
>>> editline.point
8
>>> editline.elcmd_aref(key.C_a,buffer2,dot2)
>>> buffer2
['abcde fghij']
>>> editline.point
0
>>> buffer2[dot2][editline.point]
'a'
>>> editline.elcmd_aref(key.M_f,buffer2,dot2)
     >>> buffer2
['abcde fghij']
>>> editline.point
5
>>> buffer2[dot2][editline.point]
' '

It looks like point got reset correctly.

>>> editline.elcmd_aref(key.C_e,buffer2,dot2)
    buffer2
['abcde fghij']
>>> editline.point
11
>>> buffer2[dot2][editline.point]
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
IndexError: string index out of range
>>> buffer2[dot2][editline.point-1]
'j'

This all looks right.  Why isn't it working in our pmacs?
Let's create another module in dmacs.

>>> text.buffer
['']
>>> text.dot
0
>>> text.buffer[text.dot]
''
>>> editline.point
11
>>> editline.point = 0
>>> editline.point
0
>>> editline.elcmd_aref('a',text.buffer,text.dot)
a>>> text.buffer
['a']
>>> editline.point
1
>>> editline.elcmd_aref('b',text.buffer,text.dot)
b>>> editline.elcmd_aref('c',text.buffer,text.dot)
c>>> editline.elcmd_aref(' ',text.buffer,text.dot)
 >>> editline.elcmd_aref('d',text.buffer,text.dot)
d>>> editline.elcmd_aref('e',text.buffer,text.dot)
e>>> editline.elcmd_aref('f',text.buffer,text.dot)
f>>> text.buffer
['abc def']
>>> editline.point
7
>>> text.buffer[text.dot][editline.point-1]
'f'
>>> editline.elcmd_aref('C_a',text.buffer,text.dot)
>>> text.buffer
['abc def']
>>> text.buffer[text.dot][editline.point]
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
IndexError: string index out of range
>>> editline.point
7

Why didnt' C_a reset point?  Try other cursor movement.

Wait - it's not 'C_a' string its key.C_a variable!

>>> editline.elcmd_aref(key.C_a,text.buffer,text.dot)
>>> editline.point
0

That's more like it!

>>> text.buffer
['abc def']

So elcmd_aref('C_a'...) didn't do anything to buffer, as intended.  Good.

>>> text.buffer[text.dot][editline.point]
'a'

>>> editline.elcmd_aref(key.M_f,text.buffer,text.dot)
   >text.buffer[text.dot][editline.point]
' '
>>> editline.point
3

Right, the space between words.

>>> editline.elcmd_aref(key.C_e,text.buffer,text.dot)
       >>> editline.point
7
>>> text.buffer[text.dot][editline.point]
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
IndexError: string index out of range
>>> text.buffer[text.dot][editline.point-1]
'f'

Right, point is past the end of the string.

So everything seems to be working as intended with elcmd_aref.
Why doesn't it work in our pmacs?

We could try one more test.  Update the buffer *displayed in the window*
and then use refresh() to see if window updates.

Display README_2.md in the window

>>> sked.buffer[2]
'editors\n'
>>> sked.dot
2
>>> editline.point
7
>>> editline.point=0
>>> sked.buffer[2][editline.point]
'e'
>>> sked.buffer[sked.dot][editline.point]
'e'

>>> editline.elcmd_aref('a',sked.buffer,sked.dot)
a>>>sked.buffer[sked.dot]
'aeditors\n'
>>> refresh()

Now 'aeditors' appears in the window.  Yay!

So our pmacs should work.  pmacs has:

import sked as ed

           elif k in editline.keymap:
                editline.elcmd_aref(k, ed.buffer, ed.dot)

This is almost exactly the same code as we typed above, that worked.
BUT that case doesn't include the printing characters!  In editline.py:

    if keycode in printing_chars:
        point, line = insert_char(keycode, point, line)

So change line in pmacs to:

            elif k in editline.printing_chars or k in editline.keymap:
                editline.elcmd_aref(k, ed.buffer, ed.dot)

Then reload

Wrote pmacs.py, 127 lines
Reload module pmacs
>>> from pmacs import pm
>>> pm()

C_x + b

README_2.md, at line 2 of 263, file README_2.md, saved
xyzabc  (that's what I typed - should have gone into README_2 buffer)

M_x

Traceback (most recent call last):
aeditors                            File "<stdin>", line 1, in <module>
=======                                                                  File "/Users/jon/Piety/editors/pmacs.py", line 121, in pm
Text editors                                          display.put_cursor(edsel.tlines, 1) # return cursor to command line
- **README.md**: Directions for using theNameError: name 'display' is not defined see below.
 >>> 

That's display.put_cursor(edsel.tlines, 1)

NameError: the name 'display' is not defined

>>> refresh()

In the window:

axyzabceditors
=======

It did update.   Why did it crash?  Oh, pmacs doesn't import display
but it uses it.  Fix now.

>>> dm()
pmacs.py, at line 121 of 127, file pmacs.py, saved
Wrote pmacs.py, 127 lines
Reload module pmacs


>>> pm()

Select README_MD.2 then Move cursor down to line 'Text editors'

Type C_e - then abd space or maybe space abc or something like that. Crash:

Switch to buffer (default README_2.md): 
                                                                   fcn(keycode)
                                                                                 File "/Users/jon/Piety/editors/pmacs.py", line 40, in delete_backward_char
                                                                               editline.elcmd_aref(keycode, editline.point, ed.buffer[dot])
                                                           NameError: name 'dot' is not defined
               >>> 

That's editline.elcmd_aref(keycode, editline.point, ed.buffer[dot])

NameError: name 'dot' is not defined
>>>

Right, should be ed.dot.  Replace several occurrences in fcns in pmacs.

Wrote pmacs.py, 127 lines
Reload module pmacs

>>> pm()

Switch to buffer (default README_2.md): 

Cursor down to HOW.md line.   Type abcdef, it echoes at bottom line.
Now type M-x

>>> refresh()

Now abcdef appears two lines below HOW.md

Why isn't it on the same line?   It is in the buffer somewhere.

Jonathans-MBP-5:editors jon$ git commit -am 'pmacs: editline commands working, but cursor goes to command line, doesnt stay in window yet'
[editline 627abf5] pmacs: editline commands working, but cursor goes to command line, doesnt stay in window yet
 1 file changed, 22 insertions(+), 11 deletions(-)
Jonathans-MBP-5:editors jon$ git push
...
   6b2a873..627abf5  editline -> editline


19 Aug 2023

Take care not to make a mess of this cursor placement
issue.   We might have to change existing code in edsel.py, grrrr.

In edsel:

update_status calls put_cursor(tlines, 1) # return cursor to command line

These fcns call update_status: refresh recenter (calls refresh)
display_move_dot display_change_lines display_set_saved display_d
display_y display_c display_input_line zen

These are passed to args in sked fcns.

Is there some way to replace put_cursor(tlines, 1) in update_status
with put_cursor(ed.dot, point) - ?   Not literally ed.dot but its
line on screen -- don't we already have a function for that?
Yes, it's wline - we already use wline(ed.dot) in edsel.

In pmacs, pm() command should put cursor at that location, M_x should
put cursor on command line.

How we might do it:  at the end of update_status: put_cursor(*location)
where edsel.location is usually (tlines,1) but in pmacs it's
(wline(ed.dot),editline.point).  The trick is getting location evaluated
anew each time.  I guess we need a function location() that returns
the current tlines, 1 or wline...   That's a 'thunk', right?

But does dm() always put the cursor back at the command line after each
keycode command?

Review marker.  Maybe setting marker instead of update_status
could be the hook for setting cursor and point.

We can't just eliminate the calls to update_status etc.  Many display
updates leave the cursor far from point so we have to restore it each time.

We're looking at these changes:

1. set cursor and its handling mode at pm() and M_x.  Anything else?

2. restoring cursor after each command
   hook in update_status - or maybe in set marker?

3. setting point each time dot changes
   we have to do this because any line may be shorter than point on prev line,
    which would crash with index out of range error.
   maybe put a hook in move_dot?
   or pmacs can compare prev_dot and dot for every command?
   or maybe put a hook in set marker?

Bah.   This is all a lot of work.  Easy to turn it into a big mess.

Do we really need all this?  It seems dmacs is a good compromise between
usable functionality and simple code.

No, we don't need it for editing but we do need it for Piety.  
For Piety, we need a non-blocking editor, but dmacs uses Python input()
which is blocking.  Our Piety editor must handle one character at a time,
so for that we have to complete editline and pmacs.


20 Aug 2023

I think the next step is to observe edsel/dmacs and review what happens
with the marker and the cursor after each command.

I think the first coding step is to code pm() and M_x just enough to 
put cursor at dot,point then return cursor to Python command line.
Then the test is to call pm(), then only edit inline in line at dot, then M_x
back to Python.  That should work without coding restoring cursor after
commands, and without coding restoring point after changing lines.
At the command line, we can confirm buffer got updated in the correct line.
Then pm() again should return to where we left off in same line at dot.  Etc.


21 Aug 2023

Try it.

Wrote pmacs.py, 128 lines
Reload module pmacs
>>> pm()
[]

Cursor appears on line below pn() - calling pm() did *not* move cursor
into window, even though:

+def pm(keycode):
     terminal.set_char_mode()
+    display.put_cursor(edsel.wline(ed.buffer[ed.dot]), editline.point)
     while True:
     ...

Oh, I forgot 'from pmacs import pm' - try that.

>>> from pmacs import pm
>>> pm()
Forgot arg keycode
>>> pm(keycode)

                                                      display.put_cursor(edsel.wline(ed.buffer[ed.dot]), editline.point)
                                          File "/Users/jon/Piety/editors/edsel.py", line 31, in wline
.py line 31 in wline
                         wiline = iline - buftop + 1
                                                    TypeError: unsupported operand type(s) for -: 'str' and 'int'
and type(s) for -: 'str' and 'int'
                                 >>> 

First, pm() should not require keycode arg.  Somehow a bunch of lines
in pmacs got () --> (keycode) probably through some erroneous global replace.

But how can wline be wrong?  Oh, arg should just be ed.dot on ed.buffer[ed.dot]
int not str.

>>> from pmacs import pm
>>> pm()

That worked!  Cursor moves to point in line where I just edited 
ed.buffer[ed.dot] -> ed.dot

I type X and it appears at cursor, where it should.

Then I type DEL (or was it C_d?) and it crashed:

File "<stdin>", line 1, in <module>r()
        k = keyseq.keyseq(c  File "/Users/jon/Piety/editors/pmacs.py", line 116, in pm  if k: # keyseq returns '' if key sequence is not complete
          pmcmd(k)= key.M_x:
                br  File "/Users/jon/Piety/editors/pmacs.py", line 99, in pmcmd
            elif k in keymap:                                                      fcn(keycode) pmcmd(k)
            eli  File "/Users/jon/Piety/editors/pmacs.py", line 40, in delete_backward_char     editline.elcmd_aref(k, ed.buffer, ed.dot)
               editline.elcmd_aref(keycode, editline.point, ed.buffer[ed.dot])
                dmacs.dmcmd(k)                                                  File "/Users/jon/Piety/editors/editline.py", line 221, in elcmd_aref            
                                                                        """
nd type(s) for -: 'str' and 'int'                                          TypeError: 'int' object is not subscriptable()
? line 129 out of range 1 .. 128       >>> 

Didn't I just get the order of args wrong?  point should come last,
like ed.dot.

Now pm() puts cursor in window.   Typing in window works.  C_b works in 
window.  C_f works just once.  M_b works, M_f doesn't.   Maybe confusion
about how long line is?

Also, after C_n, typing appears in Pythin command line, not in window.
We see C_n and C_p update status line with line number - so that's expected.

It seems we should fix editline commands first.

Okay, now typoing chars including space works, C_f C_b M_f M_b C_a C_e work.
M_d works, C_y crashes - that's because it's now coded to do yank_lines,
not inline yank.  So it crashes:

 "/Users/jon/Piety/editors/pmacs.py", line 73, in yank
>>>                                                                       if not iline: iline = dot
>>> pm()             File "/Users/jon/Piety/editors/sked.py", line 41, in line_validpm()
        if 0 < iline <= S():
                            TypeError: '<' not supported between instances of 'int' and 'str'

>>> sked.yank_lines
True

but then it says

    if ed.yank_lines:
        ed.y(keycode) # yank entire line(s)

Shouldn't that be ed.y() - ?  Yes.

Several more instances of (keycode) where should be (), grrr. fix now.

Enough for now.  Battery is low, 18%.  Close up.

Later - let's just keep slogging through all the functions in pmacs.py,
because they can likely be fixed within that module.   Then work on restoring
cursor and point, which probably require revising or at least reviewing
more than one module.

Try again.  Prining chars work.  C_f C_b C_a C_f M_f M_b work.
C_y inline works.  C_k then C_y works, but it grabs the terminal \n
then C_y prints it, putting cursor on the next line.
M_x then pm() restores cursor to correct line.
C_d and del work. - I didn't try joining lines.  I also didn't try open line.

After typing on line, the M_x >>> refresh(), new text appears on *next* line
in window.   Oh dear, fix this before going on.

It's notable that pm() puts the cursor at the expected location on the
screen - where the marker is - but refresh() shows the updates  
in the buffer go to the next line.
Could this be because ANSI screen addresses are 1-based but Python
indices to line and point in the buffer are 0-based?


23 Aug 2023

Review cursor placement and buffer update with edsel c() or dmacs M-% cmds.

Oh, but I think those commands do *not* place the cursor in the window at all.
c() leaves cursor at Python command line and M-% puts it in dmacs prompt line.
BUT isn't there a marker at this line?


25 Aug 2023

In dm(), cursor mostly stays at Python command line, but RET opens lines
to start append mode - opens line below mark - sked.dot shows the right
line number before and after entering append mode.  So that code is correct.

Then looking at edsel display_start_a and open_line it looks like 
open_line(ed.dot) which calls display.put_cursor(wline(iline+1),1)
to put cursor on open line after dot.

Test pm() again with editline.  Dot on line 140 in edsel >>> pm()
... to edit append mode ... -> ... to edit XYZ append mode...
                                              ^

Then M_x to get back to command line then pm() again - now 
cursor goes to right line, but goes to Z not space after Z.

Right below   XYZ
        ...reappears ...

>>> sked.dot
140

status line also says 140

>>> refresh()

It looks the same!

>>> sked.p()
of a line to exit XYZ append mode.  Then the line with '.' disappears, 

And this shows the buffer also contains the right thing!  Yay!

Try more inline editing, same line: ... the line with... -> the line ABC with

Then C_l to refresh - it looks the same, good.

>>> sked.dot
140
>>> sked.p()
of a line to exit XYZ append mode.  Then the line ABC with '.' disappears, 

That's right!

>>> editline.point
53
>>> pm()

Now cursor moves over C in ABC, not space after C where it was.

Move cursor down C_n several lines from 140 to 145.  But cursor
goes past end of line - C_a restores it.  Now C_e puts it in 
third space after end of line - C_b works to get it back to end of line.

C_l refresh puts cursor back at Python command line!

then M_x then pm() puts cursor back in line 145 in window but
in last F of DEF we just typed, not in space after.

It seems iline editing with elcmd_aref is working.   Try some of
the pmcmd.

Somehow I duplicated a line in test buffer.
Kill buffer.

Try C_d - works, delete under cusrsor.   Del, delete before cursor.
delete at start of line, see if it joins to prev line.
No, it doesn't, it just deletes first char in line, under cursor.
Oh, but I forgot to refresh with C_l - in fact we see it did join lines!

Yes, repeat that - DEL at start of line does join to prev line.  
And, C_d at end of line does join to next line.

RET in the middle of the line almost works.  It does open line
prefix is left on line but whole line not just suffix appaers on next line.
So we must fix that.

But of course the graphic updates don't work in any of these three cases.

C_k works, deletes just suffix of line.


26 Aug 2023

So it seems the basic scheme is sound, there are just a lot of little
additions and bug fixes needed.  Boring.  What's the best way to slog through?

Work on the most local, contained problems first.  Start with handling point
in editline.  Begin by testing with editline module main function, not pmacs.
When we exit editline to Python, then return, cursor does not go to exactly
the same place - it goes one space the left.   So put_cursor in editline 
caller does not put the cursor in the sampe place the display module ANSI
terminal functions do.

...$ python3 -i
...
>>> import editline
>>> editline.el()
abcde fghij klmno
      ^

after typing the line, then M-b twice to put
cursor at 'f'

>>> editline.buffer[0]
'abcde fghij klmno'
>>> editline.point
6
>>> len(editline.buffer[0])
17

>>> editline.el()
abcde fghij klmno
      ^

Invoking el() again prints the line again
and restores the cursor to the same location.

el() calls refresh(point, buffer[dot])  where

def refresh(point, line):
    'Display line and point - use after line has gotten scrambled or ...'
    display.move_to_column(start_col)
    util.putstr(line)
    display.kill_line() # remove any leftover text past line
    return move_to_point(point, line)

where

def move_to_point(point, line):
    # start_col accounts for prompt or other chars in left margin
    # move_to_column and start_col are 1-based but point is 0-based
    display.move_to_column(start_col + point + 1) # point is zero based
    return point, line

>>> editline.start_col
0

start_col is to allow for a prompt or margin in the line.

Now look at end of line

>>> editline.el()
abcde fghij klmno
                 ^

after C_e, cursor is at char following last char in line.

>>> editline.point
17
>>> len(editline.buffer[0])
17

The index of the last character in the line is 16, len()-1

Now let's try pm.

>>> sked.dot
155
>>> sked.p()
run the command in *sked* by prefixing the command name with the 
>>> editline.point
53

marker is at first character on line.

>>> pm()

Now window shows at that line:

run the command in *sked* by prefixing the command name with the 
                                                    ^

Cursor on 'a' in 'name'


M_x - cursor disappears from line, reappears in python REPL, 
marker remains in col 1.

>>> pm()

Cursor returns to a in name.

C_a cursor moves to first char in line, covering marker.

M_x, cursor moves to REPL, marker at first char restored.

>>> editline.point
0
>>> sked.buffer[sked.dot]
'run the command in *sked* by prefixing the command name with the \n'
>>> len(sked.buffer[sked.dot])
66
>>> pm()

Cursor returns to first column in line.

C_e

Cursor moves to *third* space after last character.

M_x, cursor returns to repl

>>> editline.point
66
>>> len(sked.buffer[sked.dot])
66

So why the two extra spaces?

>>> pm()

Now cursor returns to *second* blank space after end.

Now M_b six times

run the command in *sked* by prefixing the command name with the
                             ^

cursor at p starting prefixing

C_l, refresh - cursor returns to REPL.  Not what we inteded,
but I think it's coded so C_l invokes dmacs refresh() not editline refresh()

M_x, cursor remains at repl.

>>> editline.point
29
>>> editline.refresh()
... missing arguments point, line ....

>>> editline.refresh(sked.buffer[sked.dot], editline.point)
29Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "/Users/jon/Piety/editors/editline.py", line 171, in refresh
    'Display line and point - use after line has gotten scrambled or ...'
  File "/Users/jon/Piety/editors/editline.py", line 33, in move_to_point
    # move_to_column and start_col are 1-based but point is 0-based
TypeError: unsupported operand type(s) for +: 'int' and 'str'

But that's not what we want anyway.  Try this:

>>> editline.elcmd_aref(key.C_l)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: elcmd_aref() missing 2 required positional arguments: 'buffer' and 'dot'

>>> editline.elcmd_aref(key.C_l, sked.buffer, sked.dot)
run the command in *sked* by prefixing the command name with the 
                             >>> 
                                ^

Now cursor follows Python prompt so we don't see where it was in line.

>>> pm()

run the command in *sked* by prefixing the command name with the 

Now cursor is at space before prefixing

>>> editline.point
29

That's what it said before, but now it's show in a different location.

pm() calls 

    display.put_cursor(edsel.wline(ed.dot), editline.point)

where

def put_cursor(line, column):      # not in emacs or gnu readline
    putstr(cup % (line, column))

where

cup = csi+'%d;%dH' # cursor position %d line, %d column

while el() calls

def move_to_point(point, line):
    ...
    display.move_to_column(start_col + point + 1) # point is zero based
    ...

where

def move_to_column(column):
    putstr(cha % column)

where

cha = csi+'%dG'  # cursor horizontal absolute, column %d

Surely the discrepancy is explained by move_to_point has point+1
but move_to column just has column.

BUT move_to_point calls move_to_column(... point + 1)

move_to_point is used several times in editline: move_beginning, 
move_end, forward_word, backward_word, refresh

I think the discrepancy arises because pm() calls display.put_cursor(...point)
without the point+1

Let's change point to point+1 in pm() call to put_cursor.

-    display.put_cursor(edsel.wline(ed.dot), editline.point)
+    # point+1 to make put_cursor call consistent with editline move_to_column
+    display.put_cursor(edsel.wline(ed.dot), editline.point + 1)

C_x C_r

Wrote pmacs.py, 124 lines
Reload module pmacs

M_x

>>> pm()

run the command in *sked* by prefixing the command name with the 
                            ^

Still pointing at space before prefixing

C_e then several M_b to put cursor at start of prefixing, not in 
space before.

run the command in *sked* by prefixing the command name with the 
                             ^

>>> from pmacs import pm
>>> pm()

Now it puts cursor at start of prefixing, yay!

BUT shouldn't pm() just call an editline fcn so we eliminate the 
discrepancy instead of compensating for it?

The only other discrepancy is at end of line - extra spaces.


 1 Sep 2023

Try replacing display.put_cursor(... point + 1) with editline.move_to_point()

On second thought, no.  Stet.  move_to_point requires passing, returning
point, line which is more awkward.

Move on to fixing restoring to end of line.   Are we moving past final \n ?

Confirm with just editline.el() that after C_a or C_e puts cursor at first
char, or after last char, then M_x then .el() again returns the cursor
to the right place.   

Now try it in pm(). First use dm() to make line abcde ...
Then C_a to first char then M_x then pm().

When first pm(), cursor goes to last char in string (not after string).
Then C_a moves cursor to first char.  Then C_e puts cursor at second char
after last char.

abcde fghij klmno pqrst uvwxyz
                               ^

0123456789012345678901234567890123456789
>>> sked.buffer[sked.dot]
'abcde fghij klmno pqrst uvwxyz\n'
>>> len(sked.buffer[sked.dot])
31
>>> editline.point
31

31 is the index of \n.

So editline fcns in pmacs should act on line[:-1]

>>> sked.buffer[sked.dot][:-1]
'abcde fghij klmno pqrst uvwxyz'

BUT in pmacs we have:

           elif k in editline.printing_chars or k in editline.keymap:
                editline.elcmd_aref(k, ed.buffer, ed.dot)

So there is no easy way to pass in just the prefix of the line.
In editline.py we have:

def elcmd_aref(keycode, buffer, dot):
    """
    Invoke single editline command, update mutable buffer array parameter.
    """
    global point
    point, buffer[dot] = elcmd(keycode, point, buffer[dot]) # buffer is mutable

can we make a similar fcn in pmacs that uses buffer[dot][:-1] in both places?

The alternative is to redefine C_f and C_e in pmacs to deal with final \n.
Oh, but that's two editline fcns in pmacs instead of just one.


 2 Sep 2023

I think the least ugly way to fix this, is to revise C_f and C_e in 
editline.py to stop short of any terminal \n, if there is one.  Ditto C_k.
Also check M_d.  What about C_d?  In pmacs we *want* C_d at eol to delete
linebreak and join lines.

 def move_end(point, line):
-    point = len(line)
+    point = len(line.rstrip(chars='\n')) # stop short of any final \n

But then

TypeError: str.rstrip() takes no keyword arguments

I misinterpreted help(str).  Fix:

 def move_end(point, line):
-    point = len(line)
+    point = len(line.rstrip('\n')) # stop short of any final \n

Try again.  After C_e:

abcde fghij klmno pqrst uvwxyz
                              ^

>>> sked.buffer[sked.dot]
'abcde fghij klmno pqrst uvwxyz\n'
>>> editline.point
30
>>> sked.buffer[sked.dot][editline.point]
'\n'

That's what we want.   Now type more text at the end there.

abcde fghij klmno pqrst uvwxyzABC
                                 ^

>>> sked.buffer[sked.dot]
'abcde fghij klmno pqrst uvwxyzABC\n'
>>> editline.point
33
>>> sked.buffer[sked.dot][editline.point]
'\n'

That's also what we want.  And, when we M_x then pm(), cursor returns
to the end of the line where it should.


 3 Sep 2023

In pm, C_f to end of line stops at *second* space after last letter,
it must be stopping at \n.  Fix now.

 def forward_char(point, line):
-    if point < len(line):
+    if point < len(line) and line[point] != '\n':
         point += 1

after C_e to end of line, then it stops after last char:

abcde fghij klmno pqrst uvwxyzABCDExyzFlmn
                                          ^
>>> sked.buffer[sked.dot]
'abcde fghij klmno pqrst uvwxyzABCDExyzFlmn\n'
>>> sked.buffer[sked.dot][editline.point]
'\n'

That's just what we want.  Next, look at C_k.
Oh, does pm already have logic that forces us to use dmacs C_k not editline?
No, at this point pmacs kill_line is hard-coded to use editline kill_line.

Try it.  Starting from:

abcde fghij klmno pqrst uvwxyzABCDExyzFlmn
                        ^

>>> sked.buffer[sked.dot]
'abcde fghij klmno pqrst uvwxyzABCDExyzFlmn\n'
>>> sked.buffer[sked.dot][editline.point]
'u'

Now pm() C_k

abcde fghij klmno pqrst 
                        ^
Cursor is now pointing where u was.

Now M_x

>>> sked.buffer[sked.dot]
'abcde fghij klmno pqrst '

That's wrong - C_k cut off the final \n, it shouldn't have.

>>> sked.buffer[sked.dot][editline.point]
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
IndexError: string index out of range

Just what we expected - now the line is inconsistent 
because the expected \n is not there.   Must fix.

 4 Sep 2023

Then when you type, each character appears immediately
                                  ^
>>> sked.buffer[sked.dot]
'Then when you type, each character appears immediately\n'

Then type C_k

>>> sked.buffer[sked.dot]
'Then when you type, each character\n'
>>> sked.buffer[sked.dot][editline.point]
'\n'

Then type characters

Then when you type, each characterXYZ
                                     ^

>>> sked.buffer[sked.dot]
'Then when you type, each characterXYZ\n'
>>> sked.buffer[sked.dot][editline.point]
'\n'

So that's all working as it should.

Jonathans-MBP-5:editors jon$ git commit -am 'editline, pmacs: handle \n at end of line in move_end, forward_char, and kill_line.
> NOTES.txt: explain \n in editline etc., consider separating frame out of edsel'
[editline e0b4b62] editline, pmacs: handle \n at end of line in move_end, forward_char, and kill_line. NOTES.txt: explain \n in editline etc., consider separating frame out of edsel
 3 files changed, 38 insertions(+), 8 deletions(-)
Jonathans-MBP-5:editors jon$ git push
remote: Invalid username or password.
fatal: Authentication failed for 'https://github.com/jon-jacky/Piety/'

Right.  I got email on Sep 2, 

[GitHub] Your personal access token (classic) has expired

    If this token is still needed, visit
    https://github.com/settings/tokens/1088925367/regenerate to generate an
    equivalent.

6 Sep 2023

Go to link above.  Log in with jon-jacky 100153nbj.  It sends me this:

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

click [update token]

Now I guess I try to commit again and use this token as password?

Jonathans-MBP-5:editors jon$ git push
Username for 'https://github.com': jon-jacky
Password for 'https://jon-jacky@github.com': 
Counting objects: 6, done.
Delta compression using up to 4 threads.
Compressing objects: 100% (6/6), done.
Writing objects: 100% (6/6), 1.50 KiB | 0 bytes/s, done.
Total 6 (delta 5), reused 0 (delta 0)
remote: Resolving deltas: 100% (5/5), completed with 5 local objects.
remote: To https://github.com/jon-jacky/Piety
   e775ad4..e0b4b62  editline -> editline

Seems to have worked. Yes, recently commited files are now at github.

Next - restore dot and point to window after edsel commands.
We considered this before - I recall we concluded best way was
to patch into update_status.  

See L12680 and preceding.

Try this: update_status calls restore_cursor which in edsel is is
put_cursor(tlines, 1) but in pmacs is put_cursor(wline(ed.dot), editline.point)

     display.put_cursor(wlines, 1) # window status line
     display.render(ed.status().ljust(tcols)[:tcols],display.white_bg)  
-    display.put_cursor(tlines, 1) # return cursor to command line
+    restore_cursor() # defined above in this module

+def restore_cursor_to_cmdline():
+    display.put_cursor(tlines, 1)
+
+restore_cursor = restore_cursor_to_cmdline
+

Wrote edsel.py, 392 lines
Reload module edsel

Now edsel should work just as it always did. Just to be sure:

>>> from edsel import *
>>> dm()

I think that from edsel import * was probably unnecessary.
In dm(), we're not calling else fcns from REPL.

We still haven't tried using it.

A few things to try in dm:  1. M-% substitution
2. C_W then C_y

1. M_% substition

Cursor returns to Python command line.

2. C_w then C_y

After C_w cursor at Python command line, then after C_Y also.

Now try pm(), same commands.

M_% does put the cursor at the Python command line.  So does C_w.
But in pm(), C_y just does inline yank, not multiline yank.

Does put_cursor(tlines, 1) occur anywhere besides update_status?
The only other place is in edsel clr().

In pmacs, try defining and patching new restore_cursor_to_window


See defs in edsel.py above.  Diffs in pmacs:

 
+def restore_cursor_to_window():
+    # point+1 to make put_cursor call consistent with editline move_to_column
+    display.put_cursor(edsel.wline(ed.dot), editline.point + 1)


-    # point+1 to make put_cursor call consistent with editline move_to_column
-    display.put_cursor(edsel.wline(ed.dot), editline.point + 1)
+    edsel.restore_cursor = restore_cursor_to_window
+    edsel.restore_cursor()

-    display.put_cursor(edsel.tlines, 1) # return cursor to command line
+    edsel.restore_cursor = edsel.restore_cursor_to_cmdline
+    edsel.restore_cursor()

Wrote pmacs.py, 129 lines
Reload module pmacs

>>> from pmacs import pm
>>> pm()

After M_%, cursor styas on line we edit - but it doesn't move to 
end of substituted text - !?

After C_(space) to set mark, cursor moves to command line - !?

But no, when I cursor down to end of paragraph, cursor is in window.
after C_w, cursor stays in window in the right place.
After C_y cursor is still in the window.  I think our latest revs worked,
but there is more to be fixed in pmacs.

Jonathans-MBP-5:editors jon$ git commit -am 'edsel, pmacs: add, assign restore_cursor and variants.
> NOTES.txt: tweak editline explanation'
[editline b72cf8c] edsel, pmacs: add, assign restore_cursor and variants. NOTES.txt: tweak editline explanation
 3 files changed, 18 insertions(+), 4 deletions(-)
Jonathans-MBP-5:editors jon$ git push
...


 7 Sep 2023

Now if we exit pm with M_x then restart dm, does cursor return to 
Python REPL again?  Yes!

So patching restore_cursor seems to work.   What next?  Consider:

1.  Restore/manage editline.point

2.  Fix inline vs. multiline yank

3.  Fix other pmacs operations - join lines (both ends), open line

4.  Fix graphics for pmacs ops

Clearly 3 and 4 have to be in that order, should follow 1 and 2.
Which of 1 and 2 to do next?

Heuristic: do the easiest job first.  I hope they are both easy!
yank seems more localized/less pervasive, look at that first.

In pmacs, both kill_line and yank are hard-coded to do inline versions.

In v1 edsel, C_w turns on multiline yank, C_k turns it off (actually,
C_k, C_u, M_d toggle to inline yank mode, C_w toggles back to multiline).
So in V1 edsel we were happy using C_k just for inline yank.  BUT in dmacs
we use C_k for multiline yank also, because *real emacs does it that way!*

Didn't we have some scheme for using C_k for both multiline kill line
and inline kill line?

sked d() delete lines sets yank_lines = True.  skedinit initializes it True.

Then fcns in editlines set yank_lines = False: kill_line (C_k), 
kill_word (M_d), discard (C_u).  These are in editlines yank_fcns.

editline code tests if prev_fcn in yank_fcns to decide whether to 
append cut text into yank buffer, or to begin rewriting yank_buffer.

Naming is confusing - yank_fcns should be called cut_fcns or actually,
cut_cmds.

In dmacs C_k invokes edsel.d(), which in turn invokes sked.d() - 
which is the multiline version, that sets yank_lines = True.

In editline C_k invokes kill_line, which sets yank_lines = False.

Currently pmacs.py C_k kill_line is hard-coded to always use editline kill_line,
that is inline.

Currently pmacs.py yank is hard-coded to always use editline yank.

So we haven't solved the problem at all in pmacs.

Unlike version1, we want to be able to use C_k as a multiline yank.

The only hack I can think of is, if we invoke C_k when cursor is
in col 1, call dmacs kill_line -> edsel.d() -> sked.d() mulitline cut.

When cursor is not in col 1, C_k invokeds editline kill_line inline cut

Another hack is to have *two* yank buffers, one for multiine and one
for inline.  C_k puts the line, or part of the line, in *both* yank
buffers.   Oh, but then we still have to choose which yank to use.
So this doesn't solve that probem.  

Let's code the col 1 hack.

First, get yank_lines out of sked.py and skedinit.  It should be in pmacs.
Or, I guess it has to be in editline so inline editing can set it.
NO, we can put that assignment in the editline branch in pm()!

Also, don't call it yank_lines - call it inline_cut.

Start by deleting yank_lines from skedinit.py

Wrote skedinit.py, 31 lines

We have to remove yank_lines by hand because reloading will not
be effective for this.

>>> sked.yank_lines
True
>>> del(sked.yank_lines)
>>> sked.yank_lines
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
AttributeError: module 'sked' has no attribute 'yank_lines'

Now remove yank_lines from sked and anywhere else.

sked yank should be renamed yank_buffer to avoid confusing with yank cmds.

editline shouldn't use sked yank_buffer at all.  editline needs its own
yank buffer, call it 'cuts'.   In general editline should not import 
editor modules - only vt_terminal modules.

Oh, editline already has yank_buffer - different from ed yank.

In pmacs, change ed.yank_lines to just yank_lines in pmacs module.

Define/initialize pmacs yank_lines right above def yank.
Do we need to make pmacsinit.py - ?  No, okay if reload pmacs reinits yank_lines.
because using commands reassigns yank_line whenever it is needed.

C_k in col 1 or C_w anywhere sets yank_lines = True

Any editline fcn sets yank_lines = False.


 8 Sep 2023

An alternative way to switch to yank_lines mode is, C_k 
normally works in inline yank mode, 
kills line up to but not including final \n and puts
killed suffix in editline yank_buffer.  But C_k again
deletes final \n, enters yank_lines mode, copies editline yank_buffer
to sked yank_buffer.  But for now just use cursor at start of line
to put C_k in yank_lines mode.

We haven't yet fixed maintaining point.  So, we must explicitly
put cursor at start of line with C_a before trying C_k.

>>> editline.point
78
>>> pm()

We can see cursor near end of line.  Then type C_a

>>> editline.point
0
>>> pm()

Now we can see cursor at beginning of line.

Revise pmacs yank, kill_line, cut with module-level yank_lines.

Wrote pmacs.py, 144 lines
Reload module pmacs

>>> from pmacs import pm

And just to be sure:

>>> dm()
sked.py, at line 368 of 481, file sked.py, saved
Wrote sked.py, 481 lines
Reload module sked

>>> from sked import *
>>> dm()
edsel.py, at line 121 of 392, file edsel.py, saved
Wrote edsel.py, 392 lines
Reload module edsel
>>> from edsel import *

dmacs.py, at line 126 of 227, file dmacs.py, unsaved changes
Wrote dmacs.py, 227 lines
Reload module dmacs

>>> from dmacs import dm

So all the current code should be loaded.

>>> pm()

Now cursor jumps to position 8 in dot in pmacs.py

C_x b  README_2.md

README_2.md, at line 144 of 1111, file README_2.md, unsaved changes

Cursor jumps to point in dot

 he *c* (change) function to substitute text in that line.
       ^

>>> sked.buffer[sked.dot]
'\n'
>>> editline.point
7

>>> sked.dot
144


Status lines also says line 144 of 1111.

>>> edsel.refresh()  - draws the same page, with marker at that same line.

Try C_x b to switch back to dmacs.py

    # Tried to fix edsel.c arg list for in_region with lambda, didn't work so:
       ^

>>> sked.bufname
'dmacs.py'
>>> sked.dot
126
>>> sked.buffer[sked.dot]
"    # Tried to fix edsel.c arg list for in_region with lambda, didn't work so:\n"


>>> editline.point
7
>>> sked.buffer[sked.dot][editline.point]
'r'

So that's all correct.  Try C_x b to get back to README_2.md.

So it all looks the same, still at line 144 etc.

>>> sked.bufname
'README_2.md'
>>> sked.dot
144
>>> sked.buffer[sked.dot]
'\n'
>>> editline.point
7
>>> sked.buffer[sked.dot][editline.point]

Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
IndexError: string index out of range

That's consitent anyway.

Use C_p to move cursor up two lines - it keeps the same position in the column.

>>> sked.dot
142
>>> sked.buffer[sked.dot]
'the *c* (change) function to substitute text in that line.\n'
>>> sked.buffer[sked.dot][editline.point]
' '

So somehow window is out of sync with this buffer.

More experiments.  pm() is seriously messed up!  Lots of stuff doesn't work.

To debug this, we will have to run pm() but then M_x and mostly run edlse
at the command line, just pm() to try pmacs commands in isolation.

I think we should start a new Python session too, from a new pm.py

BUt meanwhile:

Jonathans-MBP-5:editors jon$ git commit -am 'pmacs: cut, kill_line, yank with yank_lines'
[editline eab3480] pmacs: cut, kill_line, yank with yank_lines
 4 files changed, 19 insertions(+), 10 deletions(-)
Jonathans-MBP-5:editors jon$ git push
...


10 Sep 2023

Systematically "test" (try out) current pmacs.   Try each branch in pm(),
starting with dmacs branch, then editline branch, then the implemented
branches in pmacs itself: kill_line, cut, and yank.

Oh dear, we've broken dmacs.  dm() immediately exits back to >>>  -- !?

Let's start over from dm.py.  Exit current session, then python3 -im dm

Now dm works.  So we somehow broke just that session, not the dm code.

Write pm.py and try starting from that: python3 -im pm

Jonathans-MBP-5:editors jon$ git commit -am 'pm.py: add, dm.py: fix, add comments'
[editline ce488ef] pm.py: add, dm.py: fix, add comments
 2 files changed, 14 insertions(+), 1 deletion(-)
 create mode 100644 editors/pm.py
Jonathans-MBP-5:editors jon$ git push
...

We can already see problems in pm

1. C_x b pmacs.py to switch buffer prints 'pmacs.py 144 lines' at top 
of window, not in Python REPL as it should, and does in dm.

2. C_x C_b prints list of buffers at top of window, not in Python REPL
as it should, and dose in dm.

Clearly, our restore_cursor() to put cursor back in window is too simple - 
we often don't want to put cursor back in window until it has printed messages.
Could this be some buffer-flushing problem?

I now suspect we need to back out restore_cursor.  We can't fix this 
by replacing something that was already there.   In many cases we have
to add something that was not already there - restore the cursor to the
window.   The best way to do that is not to modify or patch code in the
older modules - but to add new code in pmacs.  That should be the method
for everything new or modified in the pmacs project.   The way
we can handle this is to add code at the end of the dmacs branch in pm
that puts the cursor back in the window.

If some commands in dmacs should leave the cursor at the Python REPL,
then we should have a list of those commands in pmacs and that new code
at the end of the dmacs branch should say 'if cmd not in remain-in-repl-cmds:'

Go through edsel commands used by dmacs to see which should *not* return
cursor to window in pmacs.

First look at C_x b switch_buffer, edsel.b, and C_x C_b list buffers, edsel.n

ed.b() calls reload_buffer, edsel.py passes display_reload_buffer to ed.b
edsel display_reload_buffer which calls recenter which calls refresh
which calls update_status.

ed.restore_buffer calls print(status()) at the end.

edsel display_restore_buffer calls ed.restore_buffer the recenter.

So if dislay_restore_buffer calls ed.restore_buffer first, oh that
that prints msg in window.  Oh dear putting cursor in window at 
the end won't help - it's already there.   Oh dear, ed functinos that
call print - we have to put cursor at repl *before* calling them,
then restore cursor back to window *after* calling them.

Try the crudest thing that might work.  Back out the restore_cursor change.
Then, in pmacs pm, start the dmacs branch with restore_cursor_to_cmdline
and end it with restore_cursor_to_window.

Also, at entry start pm with restore_cursor_to_window and at exit from pm do
restore_cursor_to_cmdlime.

In edsel, define restore_cursor_to_cmdline and call it at end of
update_status instead of just restore_cursor.  Remove restore_cursor from edsel

Done.  Just changed a few lines.  Ready to test.

11 Sep 2023

Yes, now C_x b and C_x C_b work as they should - messages appear at
command line at bottom of term window, text window holds only buffer text
as it should.

Try cursor movement: M_lt M_gt work.  M_v C_v work.  In both cases, 
cursor in col 1.   C_n C_p work too, again cursor in col 1.   We never moved it.

C_s C_r work.   C_space and C_x C_x work - don't test C_k and C_w til later.

C_x b   C_x C_b   C_x C_f   C_x C_s   C_x C_w  all work.  Didn't try C_x C_r

Next test editline fcns.


13 Sep 2023

No, first test the dmacs formatting fcns.  Make sure the cursor returns
to window.

Done.  Cursor does remain in window.

Now test editline commands.  C_a C_e C_f C_b M_f M_b M_d repeated then C_y
works - repeated M_d then C_y pastes all the words into line.
C_k cuts to end of line and C_y pastes it back - but cursor ends up 
two lines below - !?

C_u also moves cursor several lines below, even without C_y.
Then C_y pastes at new cursor location.

C_d deletes under cursor, DEL deletes before cursor - I didn't try
at start or end of line.  Also, typing printing chars inserts in place.

C_l refresh puts cursor at command line.  C_p C_n brings it back to window.

C_n C_b moves cursor up and down vertically - even when line ends before
cursor column.   Also, marker is visible and moves up and down with cursor.

Mark should not be visible when cursor is in window.

But, pmacs mostly works!  

I think we need to work on C_n, C_p and cursor position next.

Then work on C_k and C_u.  Distinguish inline and multiline C_k and C_y.

Then join lines, open line.   


14 Sep 2023

Why does pmacs C_l not work?  It invokes edsel refresh, not editline refresh.

It does work, but it doesn't display cursor.   That's because it
doesn't go through pmacs' dmacs case, so it doesn't do restore_cursor_to_win.
Let's add that to pmacs refresh().  Done. Works.

What doesn't work in pmacs is RET after typing line of text using editline
commands.   Lines keep getting duplicated!

Let's work on restoring cursor after C_p, C_n.   Right now C_p and C_n
just move cursor direclty above (or below) position it had - even if
line doesn't go that far.  Then when we type, characters appear at that
positino on screen, but when we type C_l to refresh, they are at end
of that line - whereever it is.

(24 lines is just it is a good choice when the terminal
                                                       xyzZYXYZ

>>> sked.buffer[sked.dot]
'(24 lines is just it is a good choice when the terminal\nxyzZYXYZ'

Also, the xyz here was typed earlier, on a different line, so apparently
editline line is not getting reset - when should it be reset?

So where are C_n and C_p defined etc?
In dmacs: C_n: edsel.l  C_p: edsel.rl - which call ed.l,rl(display_p)

edsel.display_p calls edsel print_nothing and display_move_dot
which calls put_marker twice, to clear and write marker, then
ends with update_status.

I think the fix is to include at end of pmacs dmacs branch, before
restore_cursor_to_window(), call to new reset_point().  Be sure to 
reset point to the location *before* final \n.  Since this is defined 
in pmacs not editline, I think we can assume there will be a final \n.
BUT don't bake that in - test for it (?)

I coded reset_point and call from restore_cursor_to_window before put_cursor
but it doesn't seem to be effective - cursor doesn't move when dot is a 
shorter line.

I C_x C_r in pmacs then from pmacs import pm - now it seems to be working.
And, typing text in the line also seems to work right, as shown by C_l referesh

Oops, I typed RET - which has effect of duplicating line on the following
line, not opening a new line or just putting the suffix on the following line.
It does put the prefix on the original line.   Fix now.

Found and fixed a *howling* error in pmacs open_line (invoked by RET):

-    suffix = ed.buffer[ed.dot:] # including final \n
+    suffix = ed.buffer[ed.dot][editline.point:] # including final \n

The first erroneous version made suffix be all the *lines* following
dot!  In fact we saw that!  Typing RET duplicated the whole rest of the
file after dot!   The fixed version makes suffix all the *characters*
following point on that one line.

15 Sep 2023

Ha! Now RET open line prints the characters in the suffix one per line!

The erroneous line must be:

    ed.buffer[ed.dot+1:ed.dot+1] = suffix # insert new suffix line after dot

Shouldn't that be ... = [ suffix ] ?  Yes.   But now open_line leaves
cursor at status line.   Must call restore_cursor_to_window.

Now pmacs RET open_line works.  Like dmacs/edsel append mode, but now
we don't have to type . to exit mode and enable other commands - all
the other commands just work.

Jonathans-MBP-5:editors jon$ git commit -am 'pmacs, edsel: restore cursor to window in pmacs, to cmd line in edsel
> most pmacs commands from dmacs and editline working, pmacs RET open line works'
[editline 749290d] pmacs, edsel: restore cursor to window in pmacs, to cmd line in edsel most pmacs commands from dmacs and editline working, pmacs RET open line works
 3 files changed, 30 insertions(+), 22 deletions(-)
Jonathans-MBP-5:editors jon$ git push
...

Now try C_y in both inline and yank_lines mode.
First st mark, C_w, then C_y.

Oh dear, that doesn't work, cut with C_w works but then C_y has no effect.
BUT sked.yank does have the cut text!
And pmacs.yank_lines is True! 

Now pm() does not return cursor to window - !?

C_y does work in dm()

In pmacs, C_y when yank_lines calls ed.y() - no graphics!
shouldn't it call edsel.y like dmacs?
Yes! C_l refresh in pmacs after pmacs C_y does display the pasted text!
Fix now - change ed.y() to edsel.y()

Fixed - sort of.  Now pasted text appears but cursor stays at command line.
Fix with restore_cursor_to_window, just as we did with open_line.
That works.

Now try successive C_k.  Oh dear, C_y just pastes the last line.
That's the only thing in sked.yank.  Oh dear.

Try again.  Make sure we are in col 1.
When we start, confirm editline.point is 0.
Also confirm it's 0 after the end.  It is, but C_k still just saves
the last line, not all of them.
C_k and C_y do work in dmacs.

dmacs C_k calls dmacs kill_line which calls variants of edsel.d(), 
depending on value of prev_fcn.   Is pmacs assigning prev_fcn?

dmacs dmcmd() and dm() assign prev_fcn.

Revise pmacs pmcmd to assign dmacs.prev_fcn
Still doesn't fix problem - !?

Maybe the problem is because the C_k function in pmacs is pmacs kill_line,
in dmacs it's dmacs.kill_line - which is a different fcn!
Untangle this ... How to fix?

Then try inline M_d and C_y


16 Sep 2023

I think the right solution is to include both restore_cursor_to_window()
and prev_fcn = fcn into dmacs dmcmd.  Then from pmacs, just call dmacs dmcmd.
This would also avoid duplicating code in pmacs - in particular,
restore_cursor_to_window().

Doh, restore_cursor_to_window() can't be in dmacs dmcmd because it isn't
defined until pmacs.

BUT the main idea to put as much as possible into dmcmd, inluding
managing prev_fcn, then calling that from pmacs, is sound.  Do not
try to manage dmacs.prev_fcn from pmacs.

In pmacs cut we find: dmacs.in_region(edsel.d) - Can't we just call dmcmd?
Let's try that - change to just dmacs.dmcmd(keycode) # keycode is C_w here
Consecutive C_k still don't accumulate in sked.yank.

In pmacs, C_p to line, then C_k, then M_x 

>>> sked.yank
['The Python REPL continues to run and scroll up in the remaining lines\n']

>>> dmacs.prev_fcn
<function rl at 0x107730c10>

- !?   What is it when we do the same think in pmacs, which works?

I recall rl is invoked by C_p, right?  Yes.

Does consecutie C_k still work in dmacs?  Yes.
Try the same test: C_p to line, then C_k, then M_x.

>>> sked.yank
['at the bottom of the terminal. \n']
>>> dmacs.prev_fcn
>>> print(dmacs.prev_fcn)
None

Now do dm() C_k M_x 

>>> sked.yank
['Here you can type the same editing commands you used in *sked*,\n', 'but now the window updates to show the changes in the buffer as\n']


Both lines but

>>> print(dmacs.prev_fcn)
None
>>> print(edsel.prev_fcn)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
AttributeError: module 'edsel' has no attribute 'prev_fcn'

Oh dear, clearly I fail to understand something.
Oh, I forget that dmacs has:

if k == key.M_x:
                prev_fcn = None # there is no 'exit dmacs' fcn - just do it
                break

Comment out prev_fcn = None.  Now test again: C_p to line, C_k, M_x then:

>>> sked.yank
['You can make changes in any module effective immediately, without\n']
>>> dmacs.prev_fcn
<function kill_line at 0x1077a5ca0>

Yes, that's better.  Now dm(), then C_k again, then  M_x again

>>> sked.yank
['You can make changes in any module effective immediately, without\n', 'restarting the Python session or losing work in progress.  Just type\n']
>>> dmacs.prev_fcn
<function kill_line at 0x1077a5ca0>

That's working as expected.   So we can try this same test in pm().

We never tested pm C_w then C_y after C_w just calls dmacs.dmcmd - !

Yes, that all works.  Now edit pmacs kill_line to call dmcmd the same way.   
Now it works.

Next - replace calls to edsel.y and edsel.refresh with calls to dmcmd.
Also make sure every pmacs call to dmcmd is followed by restore_...to_window.

Also make sure we update dmacs.prev_fcn in pm commands that don't call dmcmd ?

Next test inline C_k.  Then test other editline fcns from pmacs - again.

Finally test the two join line fcns - DEL at start of line, C_d at end of line.
Do they need revs to call dmcmd, restore cursor, update prev_fcn ?

several M_d then C_y works as intended.

C_u then C_y puts cursor and pasted text on next line - but then C_l refresh
shows pasted text and cursor actually went to the intended location.  So
there is something wrong with the graphics here.

C_k from point > 0 then C_y pastes text where it should go - but cursor
goes to next line (but correct point).  C_l refresh returns cursor to 
correct line.

Cursor movement C_a C_e C_f C_b M_f M_b all work.

Insert printing characters works.

RET open line seems to work, but then when type chars at end of first line
(prefix) or beginning of next (suffix) line, then C_l refresh, they 
appear on next line.  I think they are getting inserted *after* \n not
before \n.

However when you open line from end of line, works as it should.
Ditto if you open line at start of line, point 0.   In both cases.
typing text at cursor (start of line, prfix or suffix) then C_l refresh
text appears where it should and stays there.   So problems appear
when you break a line in the middle.

What about join lines?

Join to prev line by DEL in col 0 only appears to delete char under cursor
at point 0, but C_l refresh shows it worked.  So it's the display that 
doesn't work.

However, join to next line by C_d at the end appears to have no effect
but C_l refersh shows it really did have no effect.   So it's the buffer
updating code that doesn't work here.


17 Sep 2023

Fix pmacs open_line.

>>> sked.dot
496
>>> sked.buffer[sked.dot]
'In append mode, you can edit the line you are entering. \n'
>>> editline.point
0
>>> sked.buffer[sked.dot][editline.point]
'I'

Then pm() RET - line moves down.  Then M_x.

>>> sked.dot
497
>>> sked.buffer[sked.dot]
'In append mode, you can edit the line you are entering. \n'
>>> sked.buffer[sked.dot][editline.point]
'I'
>>> editline.point
0

>>> sked.dot-1
496
>>> sked.buffer[sked.dot-1]
'\n'

That's right. Again pm(), then C_l refresh.  Window still looks right.
Start typing ABC then M_x again.

>>> sked.dot
497
>>> editline.point
3
>>> sked.buffer[sked.dot]
'ABCIn append mode, you can edit the line you are entering. \n'

>>> sked.buffer[sked.dot][editline.point]
'I'

Now C_e to move cursor to end of line. Then M_x.

>>> sked.dot
497
>>> sked.buffer[sked.dot]
'ABCIn append mode, you can edit the line you are entering. \n'
>>> editline.point
59
>>> sked.buffer[sked.dot][editline.point]
'\n'

This is wrong.  It should be the space before \n.  Didn't we fix this 
a while ago?  Let's try this on another line.

>>> sked.dot
498
>>> sked.buffer[sked.dot]
'Thanks to the Python *-i* (interactive) option, \n'

>>> editline.point
48
>>> sked.buffer[sked.dot][editline.point]
'\n'

pm() C_a C_e again

>>> editline.point
48
>>> sked.buffer[sked.dot][editline.point]
'\n'

But didn't we fix this before?  git log editline.py:

Date:   Mon Sep 4 21:19:30 2023 -0700

    editline, pmacs: handle \n at end of line in move_end, forward_char, and kill_line.


ABC\n
0123

len(s) = 4  s[len(s)-1] is the index of the last element, the \n

 def move_end(point, line):
-    point = len(line.rstrip('\n')) # stop short of any final \n
+    point = len(line.rstrip('\n')) - 1 # stop short of any final \n
     return move_to_point(point, line)

I also fixed C_f, fixed index arithemetic.

 def forward_char(point, line):
-    if point < len(line) and line[point] != '\n':
+    if point < len(line)-2 and line[point+1] != '\n':

I left C_k as it was:

   line = line[:point] + '\n' if killed_segment.endswith('\n') else ''


Reload module editline
Wrote editline.py, 244 lines

Now none of the editline fcns work!

Try M_x then pm().  editline fcns still don't work.

Try restart with python3 -im pm    Now editline fcns work again.
Now try C_e C_f C_k again.  First, C_e then M_x

>>> sked.dot
40
>>> sked.buffer[sked.dot]
'There is no main program.  Editor commands are just functions defined here,\n'
>>> editline.point
74
>>> sked.buffer[sked.dot][editline.point]
','

>>> len(sked.buffer[sked.dot])
76

Now pm() again, then two M_b, then C_f until it stops.  It stops at final ,
as it should.

>>> editline.point
74
>>> sked.buffer[sked.dot][editline.point]
','


Now pm(), then M_b M_b then M_x

>>> sked.buffer[sked.dot]
'There is no main program.  Editor commands are just functions defined here,\n'
>>> editline.point
52
>>> sked.buffer[sked.dot][editline.point]
'f'

Then pm() then C_k then M_x

>>> sked.buffer[sked.dot]
'There is no main program.  Editor commands are just \n'
>>> editline.point
52
>>> sked.buffer[sked.dot][editline.point]
'\n'

>>> len(sked.buffer[sked.dot])
53

No, that's not right, cursors should be at space character before \n.

Wrote editline.py, 245 lines
Reload module editline


-    line = line[:point] + '\n' if killed_segment.endswith('\n') else ''
+    line = line[:point]
     display.kill_line()
+    point = point - 1
+    if killed_segment.endswith('\n')
+        line = line + '\n'

Now test C_k again.  Then after that, test open_line.


18 Sep 2023

pm() C_a then M_x

>>> sked.buffer[sked.dot]
'The modules here comprise a minimal Python programming environment.\n'
>>> sked.buffer[sked.dot][editline.point]
'T'

Then pm() C_k then M_x

Oh, C_k in col 1 just deletes the line, C_y replaces it.

Then pm() C_e then M_x

>>> pm()
>>> sked.buffer[sked.dot][editline.point]
'.'
>>> sked.buffer[sked.dot]
'The modules here comprise a minimal Python programming environment.\n'

Oh, but this isn't right - when we type, chars appear before . not before \n.

So we should revert C_e C_f.  But keep C_k kill_line.

Wrote editline.py, 247 lines
Reload module editline
README_2.md, at line 29 of 263, file README_2.md, unsaved changes
>>> pm()

No 'from pmacs import pm' - we didn't change pm.

Now C_e M_x

>>> sked.buffer[sked.dot]
'The modules here comprise a minimal Python programming environment.\n'
>>> editline.point
67
>>> sked.buffer[sked.dot][editline.point]
'\n'
>>> len(sked.buffer[sked.dot])
68

repeated C_f stop at that point also.  Now pm() M_b M_b M_x

>>> pm()
>>> sked.buffer[sked.dot]
'The modules here comprise a minimal Python programming environment.\n'
>>> editline.point
43
>>> sked.buffer[sked.dot][editline.point]
'p'

Now pm() C_k Now end of line is gone, only
spaces after Python.  Blinking cursor is on space after space after n.

Now M_x

>>> sked.buffer[sked.dot]
'The modules here comprise a minimal Python \n'
>>> editline.point
42
>>> sked.buffer[sked.dot][editline.point]
' '
>>> len(sked.buffer[sked.dot])
44

Now pm().  Cursor returns to char immediately after n  M_x

>>> pm()
>>> sked.buffer[sked.dot]
'The modules here comprise a minimal Python \n'
>>> editline.point
42
>>> sked.buffer[sked.dot][editline.point]
' '
Now pm() then type XYZ then M_x

>>> sked.buffer[sked.dot]
'The modules here comprise a minimal PythonXYZ \n'
>>> editline.point
45
>>> sked.buffer[sked.dot][editline.point]
' '
>>> pm()

Now after pm cursor is blinking in space after Z.  Type ABC M_x

>>> sked.buffer[sked.dot]
'The modules here comprise a minimal PythonXYZABC \n'
>>> editline.point
48
>>> sked.buffer[sked.dot][editline.point]
' '
>>> pm()

Now cursor is blinking in space after C.  Type DEF it appears right there.
Cursor is blinking in space after F.   I think this is working as we want.

Now try open line.  pm() C_n C_a several M_f then M_x

>>> sked.buffer[sked.dot]
'We can have all of our source code, our editors, and the interactive Python\n'
>>> editline.point
34
>>> sked.buffer[sked.dot][editline.point]
','
>>> pm()

Now cursor is blinking on , at end of code,  Now RET.   We see lines

We can have all of our source code
, our editors, and the interactive Python

cursor is blinking on , at start of suffix line.  Marker is still
at start of previous prefix line.  C_l refresh moves marker to start of
suffix line, the rest stays the same.  C_p up to start of prefix line,
the C_e to end of prefix line.  Cursor blinks at space after code. M_x.

>>> sked.buffer[sked.dot]
'We can have all of our source code\n'
>>> editline.point
34
>>> len(sked.buffer[sked.dot])
35
>>> sked.buffer[sked.dot][editline.point]
'\n'

pm() cursor returns to space after point.  Type XYZ. cursor blinks
on space after Z.  M_x.

>>> sked.buffer[sked.dot]
'We can have all of our source codeXYZ\n'
>>> editline.point
37
>>> sked.buffer[sked.dot][editline.point]
'\n'

It did the right thing.   Now pm(), C_n to suffix line, C_e to end.
cursor is blinking in space after Python.  M_x

>>> sked.buffer[sked.dot]
', our editors, and the interactive Python\n'
>>> editline.point
41
>>> sked.buffer[sked.dot][editline.point]
'\n'



Now pm(), type ABC, M_x

Cursor was after C in ABC

>>> sked.buffer[sked.dot]
', our editors, and the interactive PythonABC\n'
>>> editline.point
44
>>> sked.buffer[sked.dot][editline.point]
'\n'
>>> pm()

That's right.  I think we have C_e C_f C_k and now RET open line working.

Jonathans-MBP-5:editors jon$ git commit -am 'dmacs, editline, pmacs: kill_line working, also cut, yank, refresh
> dmacs: retain prev_fcn across invocations of dm/pm'
[editline 44a0a4d] dmacs, editline, pmacs: kill_line working, also cut, yank, refresh dmacs: retain prev_fcn across invocations of dm/pm
 3 files changed, 14 insertions(+), 7 deletions(-)
Jonathans-MBP-5:editors jon$ git push
...

All that's left are the two join line operatins, DEL at start C_d at end line.

Oh, we still have to test kill line C_k then yank C_y in the same line.

Yeah, something's wrong there.  The line looks okay but it puts the
cursor in the correct column but on the *next* line.  Then C_l refresh
puts cursor back on the correct line but puts the preceding text
on the following line.   So, much to fix here after all.

ON a different note - here's how we could handle yank_lines.

Delete within a line copies to editline yank_buffer.
M_d C_u and C_k *except on empty line* set yank_lines = False.

C_w, and C_k on \n by itself - that is, an emtpy line - set yank_lines = True.


19 Sep 2023

Fix C_k -- again.  It looks like only the inline version is not right.
BUT first confirm yank_lines version works, C_k when cursor in column 1
editline.point == 0.  Yes, that works, including consecutive C_k.
followed by C_y yanks all the lines we killed.   Ditto, C_space then
move dot then C_w then C_y cuts then pastes all the lines from mark and dot.

Now look at C_k from within line, after col 1.  Alternativing pm() and M_x:

>>> sked.buffer[sked.dot]
'We can have all of our source codeXYZ\n'
>>> editline.point
22
>>> sked.buffer[sked.dot][editline.point]
' '

That's the space after 'our'.   Now C_k.  Cursor remains at same space,
rest of line disappears.

>>> sked.buffer[sked.dot]
'We can have all of our\n'
>>> sked.buffer[sked.dot][editline.point]
'r'

Then pm() puts cursor on the r not the space.

C_l refresh doesn't change appearance.

Now C_y to replace what was killed.  Oh dear, it looks like:

We can have all of ou source codeXYZ r

Now C_l refresh makes it look like this:

We can have all of ou source codeXYZ
                                    r

>>> sked.buffer[sked.dot]
'We can have all of ou source codeXYZ\nr\n'
>>> editline.point
37
>>> sked.buffer[sked.dot][editline.point]
'r'
>>> editline.yank_buffer
' source codeXYZ\n'

I think the problem is that final \n was included in killed text in yank buf.

Wrote editline.py, 249 lines
Reload module editline

     killed_segment = line[point:] # includes final \n, if any
+    killed_newline = True if killed_segment.endswith('\n') else False
+    killed_segment = killed_segment.rstrip('\n')
...
-    if killed_segment.endswith('\n'):
+    if killed_newline:
         line = line + '\n'
...

>>> sked.buffer[sked.dot]
'The first command here runs the *paths* script so you can run the editors\n'
>>> editline.point
46
>>> sked.buffer[sked.dot][editline.point]
' '

That's the space after 'script'

C_k, cursor remains in space after script, rest of line disappears.  M_x

>>> sked.buffer[sked.dot]
'The first command here runs the *paths* script\n'
>>> editline.point
45
>>> sked.buffer[sked.dot][editline.point]
't'

So it moved the cursor back on char

>>> editline.yank_buffer
' so you can run the editors'

That starts with the space where the cursor was before.
BUt now there is no \n in yank_buffer, good.

After pm() cursor is on final t.  Type C_y to paste killed text back.

Oops, now that t is at the end of the line.  C_l refresh confirms it.

>>> sked.buffer[sked.dot]
'The first command here runs the *paths* scrip so you can run the editorst\n'
>>> editline.point
72
>>> sked.buffer[sked.dot][editline.point]
't'

So it's doing the wrong thing at the final char, grrr.

Just get rid of point -= 1.

Wrote editline.py, 248 lines
Reload module editline


20 Sep 2023

First try just C_k then C_y to confirm we can undo.

before C_k:


>>> sked.buffer[sked.dot]
'all the data in the session remains intact, so you can simply resume working.\n'
>>> sked.buffer[sked.dot][editline.point]
's'

that's the s at start of 'so'

After C_k

>>> sked.buffer[sked.dot]
'all the data in the session remains intact, \n'
>>> sked.buffer[sked.dot][editline.point]
'\n'

After C_y

>>> sked.buffer[sked.dot]
'all the data in the session remains intact, so you can simply resume working.\n'
>>> sked.buffer[sked.dot][editline.point]
'\n'

Note point is at the end of the line.  Now type XYZ.

>>> sked.buffer[sked.dot]
'all the data in the session remains intact, so you can simply resume working.XYZ\n'
>>> sked.buffer[sked.dot][editline.point]
'\n'

It's doing the right thing.

Confirm C_k starting at col1, repeated, works - next C_y replaces all killed
lines.  Yes.

Now try inserting suffix deleted by C_k further forward in line.  Yes,
that works.  Now try consecutive M_d then C_k followed by C_y.  That works too.

Jonathans-MBP-5:editors jon$ git commit -am 'editline: C_k inline works, also works in pmacs
> C_k whole lines repeated in pmacs still works, C_y works inline or yank lines.'
[editline 33bc338] editline: C_k inline works, also works in pmacs C_k whole lines repeated in pmacs still works, C_y works inline or yank lines.
 1 file changed, 3 insertions(+), 2 deletions(-)
Jonathans-MBP-5:editors jon$ git push
...

Now I think just join lines at start of line with DEL and at eol with C_d 
are the only remaining functionality.

Oh, there is the marker.   And then the style changes.
And dmacs.prev_cmd as needed in pmacs fcns.  Distinguish editline from dmacs
prev_cmd.

And then, if we're ambitious, fix C_k to work like emacs - so C_k in col 1
leaves cursor on line, leaves blank line, then second C_k deletes line
BUT subsequent C_y just yanks deleted text, doesn't yank an extra \n.


BUT first, get the pmacs join line fcns working.  Change ed.j to edsel.j

C_d at the end - I have to type it *twice* to join the lines - I think
it must have to do with \n at the end.

Where do C_k and C_e put the cursor?  I fear one puts it on the \n
and other puts it before the \n.   Does it matter?
Yes, because our editline inserts char before the cursor.

Our editline inserts chars before the cursor.  So does emacs.  So that's right.

After C_e, then C_k shouldn't change anything.

C_k, C_e, and repeated C_f should put the cursor in the same place - on
the \n at the end of the line, so typing more chars puts them before
the \n.   When cursor is on final \n, C_k should change nothing - cursor
should remain on final \n.


21 Sep 2023

So, what do C_e C_k and C_f do at end of line?  I think we have examples
above but we've been making changes, so repeat.

After C_e:

- !? Session is messed up - C_e puts cursor at location in middle of line!
Then C_b and C_k don't quite work...   Exit and restart with pm().
Now C_e puts cursor at end again.

After C_e.   Cursor appears in space after period, the last character.

>>> sked.buffer[sked.dot]
'You can load several (or many) files, each into its own buffer.\n'
>>> editline.point
63
>>> sked.buffer[sked.dot][editline.point]
'\n'

That's what we want.   Now type pm() and type XYZ.  'XYZ' appears at 
end of line after period, cursor is in space after Z.

>>> sked.buffer[sked.dot]
'You can load several (or many) files, each into its own buffer.XYZ\n'
>>> editline.point
66
>>> sked.buffer[sked.dot][editline.point]
'\n'
>>> 

Good, it inserted new characters after the previous text but before the \n.
That's just what we want.   C_k and repeated C_e should do the same thing.

Now try C_k.

Do some M_b.  Now cursor is on initial 'e' in 'each'.

>>> sked.buffer[sked.dot]
'You can load several (or many) files, each into its own buffer.XYZ\n'
>>> editline.point
38
>>> sked.buffer[sked.dot][editline.point]
'e'

Now pm() and C_k.  Now cursor is in space *after* space after 'files, '  
and the rest of the line is empty.  So it looks right.  Now M_x:

>>> sked.buffer[sked.dot]
'You can load several (or many) files, \n'
>>> editline.point
38
>>> sked.buffer[sked.dot][editline.point]
'\n'

That's just what we want. Point where cursor was before C_k is now \n.
pm() then type ABC to make sure that gets added where it should.

ABC appears after 'files, ' and cursor is in space after C.  M_x

>>> sked.buffer[sked.dot]
'You can load several (or many) files, ABC\n'
>>> editline.point
41
>>> sked.buffer[sked.dot][editline.point]
'\n'

This is just right.  Now try C_e to the end.  C_a to start of
line and C_e all the way to the end until it stops.

Now cursor is at the space after C.  Looks right so far.

>>> sked.buffer[sked.dot]
'You can load several (or many) files, ABC\n'
>>> editline.point
41
>>> sked.buffer[sked.dot][editline.point]
'\n'

That's good, cursor is again over \n.   Now type DEF.  Now cursor is on 
space after F, looks right.

>>> sked.buffer[sked.dot]
'You can load several (or many) files, ABCDEF\n'
>>> editline.point
44
>>> sked.buffer[sked.dot][editline.point]
'\n'

So C_e, C_k, repeated C_f all do the right thing.  Now test RET open 
line again.  First use C_n to line, then repeated M_f then one M_b
to position cursor over J in Just here:

>>> sked.buffer[sked.dot]
'The *a* (append) command adds text to the buffer.  Just type lines of \n'
>>> editline.point
51
>>> sked.buffer[sked.dot][editline.point]
'J'

Now type RET.

 
The *a* (append) command adds text to the buffer.  
Just type lines of 

Now cursor is still blinking on J but it's on the next line.
marker is still on T in The at start of previous line.
C_p to previous line.  Cursor blinking on col 1.  C_e to end.
Cursor is blinking on space *two* spaces after 'buffer.'

>>> sked.buffer[sked.dot]
'The *a* (append) command adds text to the buffer.  \n'
>>> editline.point
51
>>> sked.buffer[sked.dot][editline.point]
'\n'

It's almost right but open_line inserted an extra space at the 
end of the line.  This is *not* innocuous because Github markdown
renders two spaces at the end of the line as a hard line break.
So we must fix this.  But first, type XYZ at the present cursor position.
It appears end then cursor is in space after Z.

>>> sked.buffer[sked.dot]
'The *a* (append) command adds text to the buffer.  XYZ\n'
>>> editline.point
54
>>> sked.buffer[sked.dot][editline.point]
'\n'

So that's still right.  Only problem is the extra space.  Now C_p to 
next line, the suffix line.  Cursor appears after space at end of line.

>>> sked.buffer[sked.dot]
'Just type lines of \n'
>>> editline.point
19
>>> sked.buffer[sked.dot][editline.point]
'\n'

Line after that begins with 'text on' with no space, so space at end of prefix
is ok, it was there in original line (see above).  Now type ABC.

>>> sked.buffer[sked.dot]
'Just type lines of ABC\n'
>>> sked.buffer[sked.dot][editline.point]
'\n'
>>> editline.point
22

So that's good too.  So the only problem with RET open_line is extra 
space added at end of prefix line.  Can we see that in the code?


def open_line(keycode):
    ...
    suffix = ed.buffer[ed.dot][editline.point:] # including final \n
    # Calls editline.kill_line, thanks to key.C_k, not keycode
    editline.elcmd_aref(key.C_k, ed.buffer, ed.dot) # just leave prefix on dot
    ed.buffer[ed.dot+1:ed.dot+1] = [ suffix ] # insert suffix line after dot
    ...

No!  We don't see how code adds extra space - it just calls editline on C_k,
which does the right thing when we call it interactively.  So let's defer
this for now, and go on and fix the two join-line operations.

It appears DEL at start of line already does the right thing.  After 
we do that, we get this.  Cursor is blinking in space after XYZ:

>>> sked.buffer[sked.dot]
'The *a* (append) command adds text to the buffer.  XYZ Just type lines of ABC\n'
>>> editline.point
54
>>> sked.buffer[sked.dot][editline.point]
' '
Now type ABC at cursor

>>> sked.buffer[sked.dot]
'The *a* (append) command adds text to the buffer.  XYZABC Just type lines of ABC\n'
>>> editline.point
57
>>> sked.buffer[sked.dot][editline.point]
' '

Now cursor is blinking at space after XYZABC.  So that's just what we want.
So DEL key.bs delete_backward_char with join_prev is working.
Hmn, it might add extra space at join point, or maybe it was already there.

BUT for now go on to C_d delete_char join_next.

Yes, I have to C_d *twice* to join the next line.  Then:

>>> sked.buffer[sked.dot]
'The name *edsel* is from the [Edsel](https://en.wikipedia.org/wiki/Edsel) automobile:\n'
>>> editline.point
73
>>> sked.buffer[sked.dot][editline.point]
' '

Here cursor is at space before 'automobile'.  Then \n is after automobile.
I suspect first C_d deletes \n at end of line, second C_d actually joins line.

In the code, change if editline.point < len(ed.buffer[ed.dot]): ...
to ... < len(ed.buffer[ed.dot].rstrip('\n'))

Seems to work - only requires one C_d at line end now.  After C_d at end:

>>> sked.buffer[sked.dot]
"The name *dmacs* means 'dumb emacs' or maybe 'grade D emacs', barely above F (fail).\n"
>>> editline.point
74
>>> sked.buffer[sked.dot][editline.point]
' '

This is the space between 'above' and 'F'.  It's right.  The \n is now in 
the right place.  Typing XYZ appears in right place.  BUT cursor
doesn't appear until C_l refresh or pm() again.
Yes, cursor goes to command line - fix now with restore_cursor_to_window.
Haven't tested yet.  Also, assign prev_fcn where needed in pmacs.

Later - now restore_cursor... works.   Also, assigned dmacs.prev_fcn
in delete_backward_char - it works.    BUT it seems this prev_fcn = ...
isn't working consistently - after C_n it was rl not l.  Also, none of
the editline fcns gets assigned to dmacs.prev_fcn - it has its own
editline.prev_fnc.  Not sure what to do about prev_fcn.  But in any case ---

Jonathans-MBP-5:editors jon$ git commit -am 'pmacs: join line at start or end of line with key.bs or key.C_d
> Now all pmacs commands are working.  But many loose ends remain.
> '
[editline cdaac00] pmacs: join line at start or end of line with key.bs or key.C_d Now all pmacs commands are working.  But many loose ends remain.
 1 file changed, 7 insertions(+), 5 deletions(-)
Jonathans-MBP-5:editors jon$ git push
...

We can begin using pmacs as our primary editor from now on.
Including for these notes, starting now.

Here we are, editing  in pmacs
Bah, join lines is inserting an extra space - two spaces before 'in' above.


22 Sep 2023

Now using pmacs to edit other.txt, our log/notes on findings in HN etc.
Seeing both marker and point on screen at same time is distracting.

How to fix?  In pmacs, we really only want to see marker when cursor
is *not* in window: when we are using command line (that is, exited from pmacs)
and (later) when cursor is in other window.

(A bug - page doesn't scroll up when we type to bottom of window -- !?)

put_marker is *pervasive* in edsel.

Then in dmacs we have mark, used to mark the region used by C_w etc.
This is quite differnt from the marker.

put_marker is so pervasive in edsel I think the only way to turn it off
during pmacs is to *patch* it with a no-op function - then restore it 
when exiting pmacs.   A hack!  But I think that's all we can do.

Let's start hacking.  BUT FIRST a test in the Python REPL.

Oh man, there's definitely a bug where we don't scroll when we
reach the bottom of the window.  We just keep going past status 
line and into scrolling command region.  Show stopper!  I had to
revert to dmacs to write this.

In dmacs append mode we do scroll when we reach the end of the window.
How could this be so wrong in pmacs?  

edsel recenter is the function that should get called when we reach
the bottom of the window.  It's called by display_move_dot and several
other functions - looks like display_move_dot is the pertinent one here.

display_move_dot is called by edsel.p() which calls ed.p()

What does edsel/dmacs append mode do that pmacs doesn't do?  
How does ed/edsel/dmacs append a line to the end of the buffer?

In sked a(), we find, in effect:

  line = input_line()
  ...
  buffer[dot+1,dot+1] = [line + '\n' ] # sic, append line after dot 
  move_dot_a(dot+1)

move_dot_a is just move_dot here.

In pmacs editline case, it uses elcmd_aref(k, ed.buffer, ed.dot) - 
but where does dot get incremented?  Wouldn't it have to be in pmacs open_line?
Yes, open_line has ed.dot = ed.dot + 1 but it doesn't call move_dot.

edsel display_a calls open_line(ed.dot) - but where does move_dot_a get called?

Try this:

...
     editline.elcmd_aref(key.C_k, ed.buffer, ed.dot) # just leave prefix on dot
-    ed.buffer[ed.dot+1:ed.dot+1] = [ suffix ] # insert suffix line after dot
-    ed.dot = ed.dot + 1
+    ed.buffer[ed.dot+1:ed.dot+1] = [ suffix ] # insert suffix line after dot 
+    edsel.display_move_dot(ed.dot+1) # scroll window if needed
     editline.point = 0 # start of new suffix line
-    edsel.update_below(ed.dot) # update display
     restore_cursor_to_window()

Doesn't work.  Doesn't render suffix line - starts rendering line *below*
suffix line -- !?  Seems that should work.  But try edsel.open_line instead.

-    ed.buffer[ed.dot+1:ed.dot+1] = [ suffix ] # insert suffix line after dot
+    ed.buffer[ed.dot+1:ed.dot+1] = [ suffix ] # insert suffix line after dot 
     ed.dot = ed.dot + 1
+    edsel.open_line(ed.dot) # scroll window if needed
+    # FIXME display suffix in opened line
     editline.point = 0 # start of new suffix line
-    edsel.update_below(ed.dot) # update display
     restore_cursor_to_window()

First try it after RET at end of line so there is no suffix to display.
BUT this doesn't work - it's opening the line below.  Try open_line before
advance dot.

     editline.elcmd_aref(key.C_k, ed.buffer, ed.dot) # just leave prefix on dot
-    ed.buffer[ed.dot+1:ed.dot+1] = [ suffix ] # insert suffix line after dot
+    ed.buffer[ed.dot+1:ed.dot+1] = [ suffix ] # insert suffix line after dot 
+    edsel.open_line(ed.dot) # scroll window if needed
     ed.dot = ed.dot + 1
+    # FIXME display suffix in opened line
     editline.point = 0 # start of new suffix line
-    edsel.update_below(ed.dot) # update display
     restore_cursor_to_window()

This opens *two* blank lines after dot.  BUT if we RET in the middle
of the line it works as intended - except suffix doesn't appear, of course.

Let's go back to original and just hard code calle to recenter.  
Never mind trying to re-use earlier stuff.

Aside - another bug while adding content to the end of other.txt:

File "/Users/jon/Piety/editors/pmacs.py", line 15, in reset_point
                                                                               linelen = len(ed.buffer[ed.dot])
                               IndexError: list index out of range
                                                                  >>> dm()
Back to pmacs. Try this, just make it obvious and explicit,
instead of tryng to use one not-quite-right do-it-all edsel fcn. 

     editline.elcmd_aref(key.C_k, ed.buffer, ed.dot) # just leave prefix on dot
     ed.buffer[ed.dot+1:ed.dot+1] = [ suffix ] # insert suffix line after dot
     ed.dot = ed.dot + 1
+    if in_window(ed.dot):
+        edsel.update_below(ed.dot)
+    else:
+        edsel.recenter()
     editline.point = 0 # start of new suffix line
-    edsel.update_below(ed.dot) # update display
     restore_cursor_to_window()


Crash!  That should be edsel.in_window.  Fix. 

Now RET at end of line opens a new empty line below, just as intended.

RET at start of line opens new empty line above, just as intended.

RET in middle of line breaks where it should puts suffix on next line
and makes it dot.

And, the cursors and both \n - includeing the new one at end of prefix - 
are in the right places.  

Now see what happens at bottom of window.  Yes, now it scrolls like it should.

Now see what happens when we add a line at the end of the buffer.  
Didn't other.txt just crash when we tried that?

It works fine!

Jonathans-MBP-5:editors jon$ git commit -am 'pmacs: RET open_line now works at bottom of window and end of buffer'
[editline 618dff5] pmacs: RET open_line now works at bottom of window and end of buffer
 1 file changed, 4 insertions(+), 1 deletion(-)
Jonathans-MBP-5:editors jon$ git push
...

Next, deal with marker.


23 Sep 2023

Experiment with the marker at the command line.

Weird bug - Now typing C_p echoes ^P in the window - ditto ^L refresh
and ^[x exit - so how do we get out of this?  

C_c echoes ^ but also types traceback and KeyboardInterrupt and returns
to Python REPL:

^P^L^[x^CTraceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "/Users/jon/Piety/editors/pmacs.py", line 145, in pm
    c = terminal.getchar()
  File "/Users/jon/Piety/unix/terminal.py", line 50, in getchar
    return sys.stdin.read(1)()
KeyboardInterrupt
>>> 

Now type 

>>> refresh()

Now screen redraws and >>> appears at bottom of term window.

>>> pm()

Now it works - control characters are interpreted by the editor, not echoed.

Use M_f to move cursor to middle of text line - now C_p and C_n move
both cursor and marker.

>>> edsel.put_marker(sked.dot, display.clear)

Now marker disappears but >>> appears in editor window. 
Type >>> refresh() - but now marker is back!

>>> def clear_marker():
...     edsel.put_marker(sked.dot, display.clear)
...     display.put_cursor(tlines, 1)
... 
>>> clear_marker()

That sort of works, but puts cursor and >>> at status line not bottom line.

>>> def clear_marker():
...     edsel.put_marker(sked.dot, display.clear)
...     display.put_cursor(edsel.tlines, 1)
... 
>>> clear_marker()

That works.

>>> save_put_marker = edsel.put_marker
>>> saved_put_marker = edsel.put_marker
>>> del save_put_marker
>>> saved_put_marker
<function put_marker at 0x10ecaae50>
>>> put_marker
<function put_marker at 0x10ecaae50>

>>> def put_no_marker(bufline, attribs): pass
... 
>>> put_no_marker()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: put_no_marker() missing 2 required positional arguments: 'bufline' and 'attribs'
>>> put_no_marker(0, 0)

>>> edsel.put_marker = put_no_marker
>>> put_no_marker
<function put_no_marker at 0x10ed11f70>
>>> edsel.put_marker
<function put_no_marker at 0x10ed11f70>

Now see if the marker still appears when we move the cursor around.
No, it doesn't!   Success!   Can we restore it?

>>> edsel.put_marker = saved_put_marker

Yes, now it's back!  Success!  So we can just code this into pm().

BUT now we get this crash again when we edit at the end of the buffer:

File "/Users/jon/Piety/editors/pmacs.py", line 20, in restore_cursor_to_window
                                                                                   reset_point()
                  File "/Users/jon/Piety/editors/pmacs.py", line 15, in reset_point
       linelen = len(ed.buffer[ed.dot])
                                       IndexError: list index out of range
                                                                          >>> 
  Try to reproduce - now I can't reproduce it.

Traceback suggests ed.dot exceeds length of buffer.  Or maybe it is 
length of buffer, which exceeds largest buffer index by one.
Look at code that does dot = dot + 1.

For now, back to marker:

...$ git diff
...
+def put_no_marker(bufline, attribs): 
+    'Assign to edsel.put_marker to suppress marker while running pmacs'
+    pass
+
+saved_put_marker = edsel.put_marker  # So we can restore put_marker after put_no
+
...
def pm():
    ...
     terminal.set_char_mode()
+    clear_marker()
+    edsel.put_marker = put_no_marker
     restore_cursor_to_window()
...
...
     dmacs.close_promptline()
+    edsel.put_marker = saved_put_marker
+    edsel.put_marker(ed.dot, display.white_bg)
     edsel.restore_cursor_to_cmdline()
     terminal.set_line_mode()

When we start pm(), markder no longer appears.  BUT when we exit pm with M_x
and start dm(), marker does not reappear.

Is it possible we reloaded pmacs and assigned saved_put_marker to put_no...?
Yes, that would happen if we C_x C_r reload while running pm().  That's the
typical case, isn't it?  Can we prevent this by initializing saved_put_marker
in pmacsinit?   Yes.

There is no pmacsinit.py!   Create it now. 


24 Sep 2023

Restart pmacs with new pmacsinit and try again.

...$ python3 -im pm
...  M-x
>>> pmacs.saved_put_marker
<function put_marker at 0x108204dc0>
>>> edsel.put_marker
<function put_marker at 0x108204dc0>
>>> pmacs.put_no_marker
<function put_no_marker at 0x10829a160> 
>>> pm()
...

Now we don't see marker when C_p, C_n with cursor in middle of line.
So that part is working.  Can we revert to see marker again?

... M_x
x>>> pmacs.saved_put_marker
<function put_marker at 0x108204dc0>
>>> edsel.put_marker
<function put_marker at 0x108204dc0>
>>> pmacs.put_no_marker
<function put_no_marker at 0x10829a160>

We're back to the initial state.  

>>> dm()

Cursor is now at command line, marker is at dot in window.
C_n and C_p move marker in window in col 1.  Enter append mode
with RET, we don't see marker but cursor moves with text entry.
Then exit from append mode with .  Cursor reappears at REPL and
markder reappears in in window.   

Now exit dm with M_x

>>> pm()

Yes, now cursor goes to where marker was in window and now moving
cursor wherever, we don't see marker.

There is still pmacs weirdness, crash in notes.txt when editing at 
end of buffer - stil haven't reproduced.  Also cursor does not always
return to window, sometimes stays at REPL, return to window with C_l refresh.

Ah, reproduced crash by repeating C_k at bottom of buffer:

Then, we try to restart by >>> pm(), it crashes again this way:

 File "/Users/jon/Piety/editors/pmacs.py", line 30, in restore_cursor_to_window

       linelen = len(ed.buffer[ed.dot])
                                       IndexError: list index out of range
                                                                          >>> ed.dot
15267
>>> len(ed.buffer)
15267
                                                                                   reset_point()
pmacs open_line says ed.dot = ed.dot + 1 with no check on len(buffer)

edsel display_a also has ed.dot = ed.dot + 1 with no check, but that's been
there for months and this recent crash happens when we are *not* in 
edsel append mode.

BUT precedning line in pmacs open line has ed.buffer[ed.dot+1:ed.dot+1] = ...
So it *creates* the line at that index.  So that can't be it.  

It happens after C_k right?  Are we removing line without decr ed.dot?

For now, just a hack.  Try this:

def reset_point():
    'Possibly move editline.point if needed when dot moves to another line'
    linelen = len(ed.buffer[ed.dot]) if ed.dot < len(ed.buffer) else 0
    ...

Well, that didn't help.  Editing at end of notes.txt:

e "/Users/jon/Piety/editors/pmacs.py", line 176, in pm
                                                          editline.elcmd_aref(k, ed.buffer, ed.dot)
Wrote notes.txt, 15  File "/Users/jon/Piety/editors/editline.py", line 225, in elcmd_arefes.txt, 15294 lines
>>> ^D       point, buffer[dot] = elcmd(keycode, point, buffer[dot]) # buffer is mutables-MBP-5:piety jon$ python3 -im pm
notes.txIndexError: list index out of range

Back out that change.

Jonathans-MBP-5:editors jon$ git commit -am 'pmacs: suppress marker when cursor is in text window'
[editline dd05fa4] pmacs: suppress marker when cursor is in text window
 2 files changed, 35 insertions(+)
 create mode 100644 editors/pmacsinit.py
Jonathans-MBP-5:editors jon$ git push
...

In dmacs, after several C_k at the end, then RET to enter append mode we see:

? line 15310 out of range 1 .. 15309
>>> len(sked.buffer)
15310
>>> sked.dot
15310

When C_k or C_n we get that ? line... out of range... msg.

? line 15320 out of range 1 .. 15319
? line 15321 out of range 1 .. 15319
>>> sked.dot
15320
>>> len(sked.buffer)
15320

line 15320 out of range ..15319 when we try do C_k
line 15321 out of range ..15321 when we try C_n

So dot gets advanced past end of buffer but ed checks it.
Why does this not protect pmacs?

 File "/Users/jon/Piety/editors/pmacs.py", line 30, in restore_cursor_to_window
                                                                                   reset_point()
                  File "/Users/jon/Piety/editors/pmacs.py", line 25, in reset_point
       linelen = len(ed.buffer[ed.dot])
                                       IndexError: list index out of range
                                                                          >>> 

This happens after we delete last line with C_k, then delete with C_k again.
Can't we guard pmacs C_k with buffer length check?  But sked already does this
why is that not effective?

If we delete last line in dm(), then pm() crashes immediately at that
point at startup.

It seems we shouldn't be able to move dot past end of buffer at all.
How does that happen?  Shouldn't delete at end of buffer move dot back?
Look at sked d().

     buffer[start:end+1] = [] 
+    if dot >= len(buffer):
+        dot = len(buffer) - 1 # fix dot if we deleted lines from end of buffer
     saved = False # put this before move_dot for display

Add that fix at end of sked d.

Wait.  Doesn't sked d() call move_dot?  Isn't that the right place for it?
Yes! and the last line of the function, is this, with this comment:

    buffer[start:end+1] = [] 
    saved = False # put this before move_dot for display
    move_dot(start) # FIXME what if we delete last line in buffer?

Cancel the above change and do this instead:

     buffer[start:end+1] = [] 
     saved = False # put this before move_dot for display
-    move_dot(start) # FIXME what if we delete last line in buffer?
+    # We might have deleted the last line in the buffer.
+    new_dot = start if start < len(buffer) else len(buffer)-1
+    move_dot(new_dot)

Restart pm on notes.txt.  Now repeated C_k at the end doesn't crash - it
just keeps deleting the previous line!   Then C_y pastes them in reverse
order!

Jonathans-MBP-5:editors jon$ git commit -am 'sked: d(elete) - correctly update dot after delete at end of buffer'
[editline 69430dc] sked: d(elete) - correctly update dot after delete at end of buffer
 1 file changed, 3 insertions(+), 1 deletion(-)
Jonathans-MBP-5:editors jon$ git push
...


25 Sep 2023

Another weird bug.

In ~/notes/macs, . ...paths then python3 -im pm - then C_x C_f disk.txt - 
then M_> doesn't reach last line - stops 2 lines before the end.
C_n gets ? line 7013 out of range 1 .. 7012.   M_x then dm() behaves the same.
C_l refresh doesn't fix it.  wc disk.txt says 7012 lines.  Open in
emacs, can reach end of file..

>>> len(ed.buffer)
7013
>>> ed.buffer[-2:]
['Jonathans-MBP-5:Camera jon$  cp -a 2023-05-21 /Volumes/WD2TB/A20s/Camera/\n', 'Jonathans-MBP-5:Camera jon$  cp -a 2023-08-17 /Volumes/WD2TB/A20s/Camera/\n']

Those are the last two lines that cursor can't reach.  So display in window
doesn't match buffer contents.   There is ls listing above with broken lines,
maybe wrapped lines.  I think that might be confusing it. 

M_v to scroll up, then C_v to scroll back down - now cursor is 4 lines 
from the end.  But:

>>> sked.p()
Jonathans-MBP-5:Camera jon$  cp -a 2023-08-17 /Volumes/WD2TB/A20s/Camera/

That's the last line in the file.  So display in text window does 't match
buffer or dot.

Abandon pmacs for this, just use emacs.  

I think the problem arises because edsel etc. assume that 1 line in buffer 
corresponds to 1 line in display - we can't have any wrapping etc. which
makes 2 or more lines on display for 1 line in buffer.

edsel tries to enforce that by clipping each line to window width - but
maybe doesn't always work.  Try it again, check/adjust window width

The window width is right but I can see there are ls directory listings
that are wrapped - maybe they contain tab characters so character count
is < 80 but spaces on screen is > 80 - ?

Right, fix is to make window shorter with win(12) so wrapped lines disappear
off the top of the window and no longer appear.  Now we can get cursor 
to bottom line.  

No fix needed for this - it's an edge case we can work around.  

Now return to pmacs for editing notes/mac/disk.txt


27 Sep 2023

We notice a bug where cursor does not always return to text window.
Can always recover with C_l refresh.  BUT try to fix this.

Hey - it just happened again - I did a couple of RET at the end
of the buffer.  But now I can't reproduce it.

Aside from that, pmacs is working.  Before we merge this editline branch,
a few minor tweaks to functionality:

- Get keyboard arrow keys working in addition to C_f C_b C_n C_p

- Call dmacs.prev_cmd consistently in pmacs.

A few cosmetic style tweaks:

- rename prev_fcn -> prev_cmd throughout - just dmacs and pmacs,
also there is another one in editline

- rename dmacs.dmcmd -> dmacs.cmd like pm.cmd

- In pmacs, import editline as el then rename editline.elcmd_aref -> el.cmd

- In sked, rename yank, the yank buffer, to yank_buffer like in editline.
  yank is a verb, shouldn't be the name of a buffer.

A major revision would be to make C_k work like in emacs - so 
C_k at start of line leaves empty line with just \n - works like editline C_k -
in effect opens that line in place - but then C_k on empty line of just \n
switches to yank_lines mode and puts previously yanked whole line into 
multiline yank_buffer.

So this leads us to rethink yank_buffer.  Can editline just use sked/pmacs
yank_buffer?  So that becomes a third param to all the editline fcns?
Or does pmacs copy editline yank_buffer to sked yank_buffer every time
we type C_k in an empty line?  I think the latter is better, keeps editline
simpler and more modular.  Put all the complications into pmacs.


28 Sep 2023

Jonathans-MacBook-Pro-5:vt_terminal jon$ git commit -am 'editline: handle key.left, key.right arrow keys send ANSI escape sequences
> dmacs: handle key.up, key.down array keys send ANSI escape sequences
> pmacs: tweak header comment, fix typo'
[editline d84c828] editline: handle key.left, key.right arrow keys send ANSI escape sequences dmacs: handle key.up, key.down array keys send ANSI escape sequences pmacs: tweak header comment, fix typo
 3 files changed, 7 insertions(+), 1 deletion(-)

But no git push because I'm not on the net now.

Next change prev_fcn to prev_cmd in dmacs dmacs_init editline editine_init 
pmacs.   Also change fcn to cmd in dmacs and editline.  Oh, but will
that conflict with fcn named cmd?  Maybe call those fcns command.

After change prev_fcn -> prev_cmd in editline init:   

>>> del(dmacs.prev_fcn)
>>> dmacs.prev_cmd = None

Now do a global search/replace

>>> b('dmacs.py')
dmacs.py, at line 184 of 231, file dmacs.py, saved
>>> grep('prev_fcn')
 61     if not prev_fcn in (fwd_search, bkwd_search):
133     if prev_fcn != kill_line: # first kill_line:, rewrite yank buffer
205     global prev_fcn
208     prev_fcn = fcn
216     global prev_fcn
224                 # preserve prev_fcn after dm exit for debugging and resuming
225                 # prev_fcn = None # there is no 'exit dmacs' fcn - just do it

>>> c('prev_fcn','prev_cmd',1,sked.S())
>>>             # prev_cmd = None # there is no 'exit dmacs' fcn - just do it

>>> grep('prev_fcn')
? 'prev_fcn' not found
>>> grep('prev_cmd')
 61     if not prev_cmd in (fwd_search, bkwd_search):
133     if prev_cmd != kill_line: # first kill_line:, rewrite yank buffer
205     global prev_cmd
208     prev_cmd = fcn
216     global prev_cmd
224                 # preserve prev_cmd after dm exit for debugging and resuming
225                 # prev_cmd = None # there is no 'exit dmacs' fcn - just do it

>>> grep('fcn')
206     fcn = keymap.get(...) 
207     fcn()
208     prev_cmd = fcn
213     Supported keys and the fcns they invoke are expressed in keymap table.
>>> c('fcn','cmd',1,sked.S())
>>> grep('fcn')
? 'fcn' not found
>>> grep('cmd')
... several lines we changed above, also ...
206     cmd = keymap.get(k, lambda: util.putstr(key.bel))
207     cmd()
208     prev_cmd = cmd

In editline.py:

>>> grep('prev_fcn')
108         yank_buffer = (yank_buffer + cut_word if prev_fcn in yank_fcns
124         yank_buffer = (yank_buffer + killed_segment if prev_fcn in yank_fcns
140         yank_buffer = (yank_buffer + killed_segment if prev_fcn in yank_fcns
204     global prev_fcn
207         prev_fcn = insert_char
211         prev_fcn = fcn # must assign *after* calling fcn!
236     global point, line,  prev_fcn
>>> c('prev_fcn','prev_cmd',1,sked.S())
>>> global point, line,  prev_cmd
>>> grep('prev_fcn')
? 'prev_fcn' not found

>>> grep('prev_cmd')
108         yank_buffer = (yank_buffer + cut_word if prev_cmd in yank_fcns
124         yank_buffer = (yank_buffer + killed_segment if prev_cmd in yank_fcns
140         yank_buffer = (yank_buffer + killed_segment if prev_cmd in yank_fcns
204     global prev_cmd
207         prev_cmd = insert_char
211         prev_cmd = fcn # must assign *after* calling fcn!
236     global point, line,  prev_cmd

>>> grep('fcn')
...
209         fcn = keymap[keycode]
210         point, line = fcn(point, line) # local point, line here
211         prev_cmd = fcn # must assign *after* calling fcn!
>>> p(209)
>>> c('fcn','cmd',sked.o(),sked.o()+2)
... we see those 3 lines update in window ...

Now in editlineinit.py change prev_fcn to prev_cmd then

>>> del(editline.prev_fcn)
>>> editline.prev_cmd = None

We spotted more to correct in editline

>>> grep('yank_fcns')
108         yank_buffer = (yank_buffer + cut_word if prev_cmd in yank_fcns
124         yank_buffer = (yank_buffer + killed_segment if prev_cmd in yank_fcns
140         yank_buffer = (yank_buffer + killed_segment if prev_cmd in yank_fcns
 148 # yank_fcns can't be defined until after we define kill_word etc.

Now let's fix sked yank -> yank_buffer.  First, 'yank buffer' -> 'yank_buffer'
But now we have pervasive 'yank_buffer' so we can't c('yank','yank_buffer')
just fix them one by one, check with grep() as above
.
Also change yank -> yank_buffer in skedinit.py

>>> del(sked.yank)
>>> sked.yank_buffer = []

elsewhere:

Jonathans-MacBook-Pro-5:editors jon$ grep ed.yank *.py
edsel.py:        update_below(ed.dot - len(ed.yank)) # first yanked line
pmacs_aref.py:    if ed.yank_lines:

 We only have to change that one line in edsel.  Done.

Let's restart these notes to see if we can load all the revised files.
Yes, it loads but crashed when we tried a yank because 'no ed.yank_buffer' - 
did we forget to write out /reload skedinit.py?  Do it now.
did we forget to write out /reload skedinit.py?  Do it now.


Let's restart these notes to see if we can load all the revised files.
Yes, it loads but crashed when we tried a yank because 'no ed.yank_buffer' - 
did we forget to write out /reload skedinit.py?  Do it now.
did we forget to write out /reload skedinit.py?  Do it now.

Now C_y doesn't crash but yanked lines do not appear on screen until
we type C_l refresh - !?   What would cause that?  git diff doesn't show
any incriminating lines - oh, but we did a commit with no push earlier today.
Oh, but that was just the arrow keys.  Is it possible we munged somthing?
Do the push now and look at the commit diff at github.

Jonathans-MacBook-Pro-5:editors jon$ git push
...

Then looking at diffs in the changed files shows nothing incriminating.

This diff in edsel.py is the only one related to graphics:

     if in_window(ed.dot):
-        update_below(ed.dot - len(ed.yank)) # first yanked line
+        update_below(ed.dot - len(ed.yank_buffer)) # first yanked line

BUT - what's the content of yank_buffer?

Try del/yank inline.

abcde fghijfghij klmno pqrst uvwxyz  

del and kill/yank inline works.  BUT kill/yank whole line does *not* work.
We find kill in col 1 doesn't copy killed line to sked.yank_buffer

See if C_k in col 1 goes into editline.yank_buffer.

>>> editline.yank_buffer
'bcde fghijfghij klmno pqrst uvwxyz  '

No, it doesn't - that stars with b not ab.

Is the logic right?

>>> pmacs.yank_lines
True

abcde fghij klmno pqrst uvwxyz

>>> sked.yank_buffer
[]

BUT - When I C_y nothing appears in window but when I C_l refresh, it does!

>>> sked.yank
['abcde fghij klmno pqrst uvwxyz\n']

I thought I got rid of all the references to sked.yank.

BUt it must be in the source code somewhere.

(BUG - when I move to end of buffer than back up to preceding line with
DEL, cursor disappears - actually it appears in the REPL below.
It's reproducible.)

We find in sked.py we still have yank not yank_buffer.  Look in 
editor session.   Unsaved changes!  Write it out and grep yank sked.py
Restart this session with python3 -im pm

We're back.  It seems we fixed C_k and C_y with yank_lines.  C_w C_y still work
too.

Restart term sessino where we edit source code also.

Enough for tonight.  Tomorrow fix but about refresh after DEL at
end of buffer.  Does it apply to any DEL to join lines?

Jonathans-MacBook-Pro-5:editors jon$ git commit -am 'style, change some names: prev_fcn -> prev_cmd (etc.), yank -> yank_buffer, yank_fcns -> kill_cmds'
[editline 189c388] style, change some names: prev_fcn -> prev_cmd (etc.), yank -> yank_buffer, yank_fcns -> kill_cmds
 8 files changed, 36 insertions(+), 37 deletions(-)
Jonathans-MacBook-Pro-5:editors jon$ git push
...


29 Sep 2023

Yes, in delete_backward_char, we found restore_cursor... was missing.
Add it, like already in delete_char.   That fixed it.

Next, renames in editline and pmacs.   editline.elcmd_aref -> el.runcmd
Also dmacs.dmcmd -> dmacs.runcmd. Also, pm cmd -> runcmd, and in it fcn -> cmd

Restart this very editing session - try it out.
The el.runcmd commands work.  The pmacs runcmd commands work.  The dm.runcmd
commands work.   I think it's all fine.

BUG: We see C_u discard doesn't update screen correctly - but C_l refresh
fixes it.  I think this is unrelated to recent changes.  I don't see 
any obvious errors in the code.  Ugh, let's defer this.

We've done most of the revisions proposed at  L15444  except:

- assign dmacs.prev_cmd consistently in pmacs

Also the comment in pmacs suggesting we define a command to enter dmacs 
append mode.   I think I like C_x + a or maybe + C_a for that.  What does 
that mean in emacs?  Get the manual...

Old manual says C-x C-a defines an abbreviation.  On my Mac, C-h k then
C-x C-a says it's undefined.  Let's use it!  Done, works.

Now assign dmacs.prev_cmd consistently in pmacs.  There is no mention
of prev_cmd in pmacs.

Commands which call el.runcomd or dmacs.runcmd should *not* assign prev_cmd.
There aren't many pmacs commands where we have to assign dmacs.prev_cmd.
BUT in main lop el case we assign dmacs.prev_cmd = el.prev_cmd.
So that's done.  

I think that's everything, except making C_k work like in emacs.
Maybe that's not too hard.

Restart this editor session again.

Jonathans-MBP-5:editors jon$ git commit -am 'pmacs: add dmacs append with C_x C_a
> pmacs: assign dmacs.prev_cmd consistently in every command
> pmacs, dmacs, editline: use runcmd name in all.  
> pmacs: import editline as el to shorten many statments
> pmacs: bug fix delete_backward_char, add restore_cursor_to_window'
[editline 746747d] pmacs: add dmacs append with C_x C_a pmacs: assign dmacs.prev_cmd consistently in every command pmacs, dmacs, editline: use runcmd name in all. pmacs: import editline as el to shorten many statments pmacs: bug fix delete_backward_char, add restore_cursor_to_window
 3 files changed, 51 insertions(+), 42 deletions(-)
Jonathans-MBP-5:editors jon$ git push
...

Next: fix C_u, discard.  Make sure it works for typical case where you
type C_u at the end of the line to discard the whole line, leaving
line open and putting cursor back in col. 1 -- so we could type a 
new line in place.   Make sure this works in single-line editline
before fixing it in pmacs.

After that, work on making C_k work like in emacs.  In particular,
C_k at start of line should kill the whole line, leaving the line
open and leaving cursor in col 1 - so we could type a new line in 
place.  Make sure this works in single line editline first - I think
it already does.

Review how C_k actually works in emacs: 

On any line, C_k in col 1 kills the rest of the line, line remains open -
just like in our present editline C_k.

Then next C_k kills the newline and line below moves up -- just like
in our present pmacs/dmacs C_k.

If you kill after col 1, so text remains on line before cursor,
more C_k has no effect - it does not join line below like C_d

If you C_k on an empty line preceding a text line, line below
moves up immediately, like in our presetn pmacs/dmacs C_k

When you C_y to paste cut lines, consecutive nonblank lines appear without
blank lines between - they look just like they did before they were cut -
but also a blank line between nonblank lines appears as it did before cut.

How can we implement this in our new pmacs?

When yank_lines == False,
C_k anywhere in *nonempty* line including col 1 just invokes editline C_k,
stores killed line in editline.yank_buffer, leaves \n at the end of the line,
leaves yank_lines == False.  Then C_y just pastes from editline.yank_buffer
back into editline line. 

When yank_lines == False, 
C_k on empty line - that only has a single \n - 
then bring line below up, like present dmacs C_k
set yank_lines = True, 
and (only *if prev_cmd was kill_line* ?) copy editline.yank_buffer to 
first line in sked.yank_buffer.

After that - , when yank_line == True ... ?

Aside - I think margin for M_q fill command should be different than
indent for C_c > and < indent/outdent commmands.   So we can fill 
to col 1 left margin but still indent.


30 Sep 2023

Yes, lets fix C_u discard and M_q fill/wrap before going back to C_k and C_y.

Really the 'best' solution for C_k C_y is to just use one yank buffer
-- the same yank buffer -- for both inline and multiline yanks.  
If there is (no more than) one line in yank buffer, use editline inline yank,
of there is more than one line, use sked multiline y().  That way we don't
need any yank_lines flag.   The only logic needed is to decide when to add more
lines to yank buffer, and when to rewrite yank buffer starting from first line.

We currently use yank_lines to decide *which* yank buffer to use for C_k,
as well as which yank buffer to use for C_y.

Using just one one yank buffer means we have to make the yank buffer a third
arg to all the editline fcns.   It's verbose but not much worse than two args.

We should implement this in two steps: First, just add third arg to editline
fcns and use a single yank buffer, but otherwise keep all the existing logic
for C_k - maybe even yank_lines.  Then, change C_k logic and behavior to
work like emacs.

Consider re-implementing editline in not-a-class style used for buffer,
window etc.   Change el.runcmd  arguments sked.buffer sked.dot to globals in
editlineinit.py.  Then save/restore globals in dictionary of tuples to edit in
different lines.  Real test of this comes when we edit other lines: for responses
to prompts, for Python command line.
 
No, that won't work.  We can have the buffer itself be a global
variable in editline:  buffer = ed.buffer then reassign to 
buffer = pysh.command then reassign back.  This works because 
ed.buffer is a *reference* to a mutable container data structure - a list -
and those can be shared.  So all clients that read or write buffer *contents*
etc. stay up-to-date when any client reads or writes contents - the
container's contents change but the reference to the container does
not change.  

BUT  index = ed.dot just assigns an immutable value to index, index does
*not* stay up to date when other code changes the value of ed.dot.  That's
why we need ed.dot either to be a passed parameter, or (trivially) to be a
global  variable that is always used and is never replaced by a different
global variable.


 1 Oct 2023

Heyyy ... maybe we could use a *thunk* !

   buffer = ed.buffer  # buffer is a ref to a container, contents always current 

   index = (lambda: ed.dot) # Thunk! index() returns current value when needed

I used thunk in version1.  See notes/piety/notes.version1.txt
Then use buffer, index() in the calls.    

Oh, we also want this, which
is the motivation for this whole experiment: make editline args into globals
so we don't have to keep expanding arg list:

   yank_buffer = ed.yank_buffer # another reference to a different container


 3 Oct 2023

BUG: M-q fill/wrap doesn't update window - must C_l refresh to see effect.

This appeared after >>> sked.lmargin=2   Before that it was 4.

Editing commonplace.txt later I don't see this problem - ?

Later - Reading O'Reilly *Fluent Python* by Luciano Ramalho - chapter
on async.   Very complicated and confusing.   Seems to confirm that
to use async, everything must be declared async def ...    Also seems
to say asyncio *only* works with network sockets - !?

Also says there is an async REPL you can start up.  I suppose it only 
works with def asynch everything....


 5 Oct 2023 
 
We have about 30 min, do something simple: separate lmargin from indent.indent/outdent already have arg and local variable nspaces, used
to update global lmargin.  Add new global variable in skedinit.py
nindent, update that in indent/outdent.  In skedinit.py:

-lmargin = 4           # N of spaces to indent or outdent, left margin for wrap.
+lmargin = 0           # left margin for wrap
 rmargin = 78          # right margin for wrap
+nindent = 4           # N of spaces to indent or outdent

In sked.py:

-    Indent by nspaces spaces, default lmargin, assign given nspaces to lmargin.
+    Indent by nspaces spaces, default nindent, assign given nspaces to nindent.
     If outdent, move text to left by removing characters from left margin.
     """
-    global lmargin
+    global nindent
     ...
-    if not nspaces: nspaces = lmargin
-    lmargin = nspaces # int
+    if not nspaces: nspaces = nindent
+    nindent = nspaces # int

prepare to test:

>>> sked.nindent
4
>>> sked.lmargin
4
>>> sked.lmargin = 0
>>> sked.lmargin
0

Try a fill/wrap - should use lmargin 0.  Works.

Try indent/outdent - should use 4 spaces.  Works.

BUT - some oddities.   Indent 4 spaces with C_c >, works, then
fill to col 1 wih M_q - It fills, but there are all these ugly 4-space-wide
gaps in the filled text - it doesn't nicely reformat.    

Also, if you outdent C_c > text that is already on col 1, it shifts the 
text 4 spaces left and irrecoverably clips away the initial 4 characters!

Let's defer both of these for now.  In these tests, fill M_q does update
on the screen correctly, we don't have to C_l refresh to see the filled text.

Next - fix C_u discard so it updates in the window correctly without
requiring C_l refresh.  First test the typical use case: type C_u at the
end of a line in progress to discard it and start over.

That doesn't work.  The line does not update.  Instead, cursor moves
to start of next line.   Only at C_l refresh does cursor move back to start
of same line, and text on line disappears.  So data is updated correctly
but window does not update.  Maybe we just never got around to it?

It would be nice if C_x f find file would just load buffer if it is already
stored.   Now it just prints:

? file editline.py is already in the saved buffer editline.py

Maybe it should just go ahead and do C_x b and print:

editline.py, at line 236 of 251, file editline.py, saved

I think emacs works that way.

Back to C_u discard - most editline fcns call display.(something), 
but discard() only calls display.kill_line at the end to clear the 
rest of the line.  Look in display module to see if there is something
suitable.  In a pinch we could just use display.putstr.

Nothing in display module, but maybe there is some ANSI code that does this?
BUT I'm not on the net now so I can't check.

Instead, work on C_x b vs C_x f.  Yes, I confirmed emacs just switches to
buffer without re-reading file if it is already in a stored buffer.  This
is good because updates made in buffer since file was last written are not
overwritten by reloading stale file.

If you C_x b filename which is not already in a stored buffer, emacs
creates a new empty buffer with that name!  Even if there is a file with
that name in the current directory!   I don't like this, it threatens
to overwrite the existing file, doesn't it?

So how do you create a new empty buffer in our sked etc?

If you C_b <name> where name is not already a stored buffer, it 
says ? no buffer <name>.   You have to C_x f which creates a new
empty file buffer, but doesn't write it out.  So you could kill it.

Let's make 'C_f calls C_b if file already in buffer' a change in dmacs
not sked.  Let's just leave sked alone.

Later - never mind.  sked e() and b() both do checks and write messages
which makes them difficult to re-use in dmacs for this.  It would take some
not-too-difficult reorganization of sked e() and b() to make this work,
but it's not worth the effort now.

Back to C_u discard -- look for an ANSI code that does the work for us.   

In  http://www.inwap.com/pdp10/ansicode.txt  we find:

Minimum requirements for VT100 emulation:

  ...
  [0J     Erase from current position to bottom of screen inclusive
  [1J     Erase from top of screen to current position inclusive
  [2J     Erase entire screen (without moving the cursor)
  [0K     Erase from current position to end of line inclusive
  [1K     Erase from beginning of line to current position inclusive
  [2K     Erase entire line (without moving cursor)
  ...

In our display.py we find:

el  = csi+'%dK'  # erase in line, %d is 0 start, 1 end, or 2 all
el_end = el % 0  # 0: erase from cursor to end of line
el_all = el % 2  # 2: erase entire line

I think el % 1 isn't useful if it leaves the remaining text where it is.

I think something like erase entire line then pustr(suffix) is 
probably what we want - be sure to preserve \n at end, even if line is now
empty.

BUT let's try el % 1.  First:

Jonathans-MacBook-Pro-5:editors jon$ git commit -am 'sked: distinguish nindent for indent/outdent from lmargin for wrap'
[editline e975588] sked: distinguish nindent for indent/outdent from lmargin for wrap
 2 files changed, 6 insertions(+), 5 deletions(-)
Jonathans-MacBook-Pro-5:editors jon$ git push
...

Why does editline use util.putstr not display.putstr?  What's the difference?
Comment in display.py explains: util.putstr writes to stdout, can be redirected.
I think editline should use display.putstr.   Try changing in just one 
place first, and test that.

It might seem display is redudant with key, couldn't editline just use
key.<whatever> directly, instead of display?  But no, recall we use
display so we  we could replace vt_terminal with framebuffer or something
else that doesn't use ASCII codes/ANSI escape sequences.


 6 Oct 2023

Compare util.putstr to display.putstr.  Confirmed that the onl difference
is display.putstr call to print() includes file=tty kwarg.   

We see dmacs and edsel use display.putstr, only editline uses util.putstr.
Looks like an oversight.  Change to display.putstr in editline now.
dmacs calls it in one place, to ring bel (which doesn't work, I recall).
Fix that also.  Now we can remove import util from both modules.
Now the util module isn't used anywhere in editors - we do use terminal_util.

putstr is only fcn in util module.  Do we use it anywhere?
unix/terminal.py uses it.  vt_terminal/keyseq uses it.
BUT keyseq also imports terminal.   What about defining it in
unix/terminal.py?  Then we could eliminate util dir and util module.
Do we get into any circular dependencies?   Could we define display.putstr
in terminal instead?  No, display only import os.

Let's move util.putstr def to terminal.py then keyseq can use that one.
Then eliminate util/ and util.py.

Jonathans-MacBook-Pro-5:Piety jon$ git rm -r util
rm 'util/README.md'
rm 'util/util.py'

Now restart this editor session to make sure it all still works.

We're back.  We are using editline here, changed from util.putstr to 
display.putstr.  Seems to work.

Jonathans-MacBook-Pro-5:Piety jon$ git commit -am 'editors modules: use display.putstr not util.putstr
> move util.putstr to terminal module
> remove util module, util/ directory'
[editline d30d299] editors modules: use display.putstr not util.putstr move util.putstr to terminal module remove util module, util/ directory
 6 files changed, 19 insertions(+), 35 deletions(-)
 delete mode 100644 util/README.md
 delete mode 100644 util/util.py
Jonathans-MacBook-Pro-5:Piety jon$ git push
...

Back to C_u discard.  In display py define el_begin el % 1 and discard()
putstr(el_begin).  Now editline discard calls display.discard.

Try it.  Crashes:

editline.py, at line 143 of 252, file editlin    point, line = cmd(point, line) # local point, line hereines
 TypeError: cannot unpack non-iterable NoneType object

I forgot return point, line.  Try again.   It works - almost.  C_e to 
end of line C_u discard, line vanishes but cursor stays at end of line.
Then C_l refresh - cursor moves to beginning of line.  Do we still have
\n at end of empty line?

>>> sked.buffer[sked.dot]
'\n'

Yes we do.  So everything works except the display.
Then type on the line aaa bbb ccc.   What's in the buffer?

>>> sked.buffer[sked.dot]
'aaa bbb ccc\n'

So the 'discard whole line from the end, then enter a revised line' use case
works, except for the display.

Now try C_u from middle of a line.  Text vanishes from col 1 to cursor.
C_l refresh shows buffer is as we want - suffix is moved to beginning of
line. Then adding text at the cursor works as we want.  Again, editing
works but display isn't right.

Hey, could we use editline.refresh instead of display... fcns?
It looks like it contains just the display fcns we deleted from discard.

BUG - ctrl chars echo in window instead of causing commands.  
Then it somehow resolves itself - not sure what cleared it.
   
Back to C_u.  editline refresh() does not work - the cursor moves down
one line and *that* line disappears.  The line that was discarded remains
on screen until C_l refresh - then the other line reappears.  

refresh() must be wrong.  Maybe the only error is that it moves down a line.

Try testing refresh in editline el().   Does it work then?  Yes, just
as it should.  So is pmacs somehow printing a newline?   Aha, I think it
might be putstr(line) in refresh(), in this case line includes final \n,
and in el() it does not.   

Try changing to putstr(line.rstrip('\n').  That works, both at
end of line and in the middle.  

Are we done with editline and pmacs?  Are we ready to merge this branch?
The only thing left would be to make C_k work just like in emacs, but
doing that neatly requires revising editline yank_buffer etc. as discussed
above.  Maybe just defer all that.   Merge this branch and go on
to multiple windows.

We shouldn't merge before revising editors/README.md.  We can think about
C_k while we work on that.

Jonathans-MacBook-Pro-5:editors jon$ git commit -am 'editline: fix refresh and C_u discard
> display: add el_begin and discard but theyre not useful for editline C_u discard anyway.'
[editline 914dd72] editline: fix refresh and C_u discard display: add el_begin and discard but theyre not useful for editline C_u discard anyway.
 2 files changed, 10 insertions(+), 7 deletions(-)
Jonathans-MacBook-Pro-5:editors jon$ git push
...

 7 Oct 2023

Jonathans-MacBook-Pro-5:editors jon$ git commit -am 'README.md: add material on pmacs and editline, add new Quick Start section, table of contents'
[editline b4244dd] README.md: add material on pmacs and editline, add new Quick Start section, table of contents
 1 file changed, 72 insertions(+), 16 deletions(-)
Jonathans-MacBook-Pro-5:editors jon$ git push
...


 8 Oct 2023

Jonathans-MacBook-Pro-5:editors jon$ git commit -am 'README.md: more about pmacs'
[editline 0c3db14] README.md: more about pmacs
 1 file changed, 45 insertions(+), 21 deletions(-)
Jonathans-MacBook-Pro-5:editors jon$ git push
...

BUGs, noted while editing and viewing editors/README.md.  GitHub sometimes
wraps lines so no space appears between the last word on one
line in the source file and the first word on the next line.
Sometimes paragraph breaks
in .md files do not appear when displayed at GitHub.  So GitHub is 
handling line breaks strangely.  Look at .md buffer contents in pmacs
and written out .md files using cat.

Jonathans-MacBook-Pro-5:editors jon$ git commit -am 'README.md: tweak formatting and some wording'
[editline c479770] README.md: tweak formatting and some wording
 1 file changed, 17 insertions(+), 15 deletions(-)
Jonathans-MacBook-Pro-5:editors jon$ git push
...

BUG - M_q sometimes wraps all the text far above when we just try to wrap 
one (overlong) line.    If we don't set mark, it is just supposed to 
wrap that single line.   Maybe mark isn't getting cleared ... ?

Now we see wrapped text in next-to-last paragraph starting "pmacs is still..."
joins words from consecutive lines and is missing line break before
last paragraph "The name pmacs ..."

What's in the buffer?

>>> sked.buffer[-8:] 
['at a time.  You cannot cut and paste beginning in the
middle of one', 'line and ending in the middle of another line.  We have not',
'found this to be a serious limitation and we have no plans to change this.',
'', "Then name *pmacs* might mean 'Python emacs' but actually means 'poor
emacs'\n", "or 'pathetic emacs'.\n", '\n', 'Revised Oct 2023\n']

Ah, The problem is, the wrapped lines do not end with '\n'.  Is that generally
true of text we wrap with M_q?   Try it in test buffer.

Here is some text from README_2.md before wrapping.  Each line ends with \n
The break between paragraphs is just a \n on  a line by itself.

>>> sked.buffer[o():o()+6] 
['Here *from sked import \\** imports the\n',
'command names from *sked* into the REPL so they can be used without\n',
'qualification:\n', '*e(...)* instead of *sked.e(...)*.\n', '\n', 'The *e*
(edit) command loads a file into a buffer in the editor.\n']

After M_q wrap:

>>> sked.buffer[o():o()+4] 
['Here *from sked import \\** imports the command
names from *sked* into the REPL\n', 'so they can be used without
qualification: *e(...)* instead of *sked.e(...)*.\n', '\n', 'The *e* (edit)
command loads a file into a buffer in the editor.\n']

Here there are \n at the end of the wrapped lines.  It's not clear why
the last paragraph in editors/README.md doesn't have \n at the end.

How can we get the \n at the end?   Does wrapping with M_q add the \n?
Yes!  But the wrapped lines run words together.  BUT we can just edit in 
the space between those words - there aren't many.

Jonathans-MacBook-Pro-5:editors jon$ git commit -am 'README.md: fix typos, tweak formatting'
[editline a9c6eb2] README.md: fix typos, tweak formatting
 1 file changed, 13 insertions(+), 4 deletions(-)
Jonathans-MacBook-Pro-5:editors jon$ git push
...

Jonathans-MacBook-Pro-5:editors jon$ git commit -am 'pm.py, dm.py: win(22) not (24) to fit in standard 24 line terminal window.
> README.md: in pmacs section, explain win(12)'
[editline 9804ac3] pm.py, dm.py: win(22) not (24) to fit in standard 24 line terminal window. README.md: in pmacs section, explain win(12)
 3 files changed, 6 insertions(+), 4 deletions(-)
Jonathans-MacBook-Pro-5:editors jon$ git push
...

README.md is done for now - and dm.py and pm.py work with default term window.
We might be done with this branch - but take another look at editline 
and editline.runcmd.


 9 Oct 2023

Should say a bit more in README about inline C_k C_u C_y vs 
multiline C_space C_w C_k C_y.

Should remove 'Emacs-like' from README - it just uses emacs control keys.
It is emacs-inspired, not emacs-like.

Revew editline. Consider args vs. globals. Why do all the fcns take 
point, line args and return point, line?  So they can all be called
easily by the same elcmd and runcmd fcns.  But is that necessary?

Jonathans-MacBook-Pro-5:editors jon$ git commit -am 'README: more about pmacs'
[editline 9d508a2] README: more about pmacs
 1 file changed, 52 insertions(+), 27 deletions(-)
Jonathans-MacBook-Pro-5:editors jon$ git push
...


10 Oct 2023

Reviewing last commit/push at github.  In dmacs section, new '\\\'
appears as '\' - it's an escape char.  ALSO, immediately following
paragraph break is gone.  What's in the .md file?

>>> sked.buffer[o():o()+4]
['To indicate that the string argument should be the empty string,\n', "type
three backslashes, '\\\\\\'.\n", '', 'Some keys invoke functions that can
optionally act on a range of\n']

So the three backslashes got turned to six?   Or is that how Python REPL
shows them?   Also, where did the "..." come from?

Let's just delete these lines and rewrite them.

>>> sked.buffer[o():o()+4]
['To indicate that the string argument should be the empty string,\n', 'type
three backslashes.\n', '\n', 'Some keys invoke functions that can optionally
act on a range of \n']

No more weirdness. That should look okay at github.  

Jonathans-MacBook-Pro-5:editors jon$ git commit -am 'README: more pmacs, add Recovering from errors'
[editline 7272787] README: more pmacs, add Recovering from errors
 1 file changed, 45 insertions(+), 13 deletions(-)
Jonathans-MacBook-Pro-5:editors jon$ git push
...

Now we are ready to look again at editline and consider whether we 
are done with this branch.

Oh, but we should also review How We Program.

Jonathans-MacBook-Pro-5:editors jon$ git commit -am 'HOW.md: big rewrite, README.md: tweak wording'
[editline 9355cae] HOW.md: big rewrite, README.md: tweak wording
 2 files changed, 70 insertions(+), 35 deletions(-)
Jonathans-MacBook-Pro-5:editors jon$ git push
...

In HOW.md, do we want to add a section on Global variables and default 
argument values?  Maybe not until we settle editline.  Review editline again.


13 Oct 2023

Let's defer/leave editline.  Just tweak HOW.md - no new section on globals.

no changes added to commit (use "git add" and/or "git commit -a")
Jonathans-MBP-5:editors jon$ git commit -am 'HOW.md: tweak wording, formatting'
[editline 89bfc42] HOW.md: tweak wording, formatting
 1 file changed, 31 insertions(+), 27 deletions(-)
Jonathans-MBP-5:editors jon$ git push
... 

Here's what we were considering doing with editline etc:

Make yank_buffer a function arg to all the edting methods, returned by
all the editing methods, also make it an arg to editline.runcmd.
Yes, that makes editline more verbose and boilerplated but making
editine update global variables does not work well with updating sked.buffer
etc.  
 
Then pmacs passes sked.yank_buffer to editline.runcmd.   So editline C_k, C_u,
M_d update first line in sked.yank_buffer, not one-line editline.yank_buffer.
C_w and cascaded C_k update lines after first line in sked.yank_buffer.
Then C_y calls editline.yank if sked.yank_buffer has only one line,
calls sked.y if it has more than one line.  We no longer need separate
yank_lines control variable.  

Repeated C_k - first C_k, line up to \n goes into yank buffer, cursor
remains on same line.  Next C_k, delete \n at end of line but don't save
it in yank buffer, then advance to next line.  Next C_k deletes that line
up to \n etc.

Some complications - what about \n in first line that might be
yanked into an existing line by editline.yank, vs. following lines
that all go on a line by themselves.    Also, what about C_w cutting
just one line?

All these complications arise from trying to imitate emacs-style cascaded
C_k in pmacs.

I think the scheme above is too complicated.  Just keep separate 
editline.yank_buffer and sked.yank_buffer.  Handle cascaded C_k this
way: first C_k always goes to editline.yank_buffer, even if started in col 1.
After second C_k on remaining lone \n on line, set yank_lines = True and copy
editline.yank_buffer to first line of sked.yank_buffer.  After that, more
C_k add lines to sked.yank_buffer.   That makes minimal changes to
existing code.    We might try that.

Later - I decided to rewrite editline after all!  Simplify it, no args,
just update module global vars for line, point, killed (the yank buffer,
 one line).   move runcmd that updates text buffer to pmacs.

Fixed editline.py, el() test works.  This is so much cleaner and nicer! 
On to pmacs.  Just assign ed.buffer[ed.dot] = el.line after each call to 
el.runcmd.  Done.

BUT it doesn't work - we type a line and it gets duplicated in the
buffer.   Experiment with typing, then refresh, then M_x, then
sked.buffer[sked.dot] etc.   

We see the new line doesn't have \n at the end.  BUT maybe with M_x 
before typing RET?

When we type RET at end of line, cursor moves to next line but 
*following* line appears in newly opened line.  Then C_l shows
it's also at the end of the line we typed -- !?

Don't I also have to type ed.buffer[ed.dot] = el.line after each
call to el.runcmd() in all the fcns called by pmacs runcmd also?

Aside, BUG - We're in mode where control keys echo instead of being interpreted
Immediately before that, we killed a buffer with C_k.

How did we get out of this in the past?
Type RET - that escapes.

Now it seems to be working BUT when we RET at end of new line, that
new line doesn't have \n at the end - because editline doesn't put 
one there.  So add that in open_line.   BUT we should not add \n after
most editline fcns.  It looks like kill_line handles \n already.

After those fixes, it's still not working.  Let's take a rest.

Later - why should we need + \n in open_line - old el.runcmd did not need it.

>>> sked.buffer[o():o()+4]
['any work in progress. See [how we program](HOW.md).\n', '\n', '### sked
###\n', '\n']

Now none of the editline fcns work!  Can't move cursor from col 0 -- !?
It seems to be getting worse and worse.

Does editline test el() still work?  Yes.

It echoes the editline printing characters also.  But not the editing cmds.

Weird!  How did I break it so thoroughly?   It seems display should
update even if the buffer doesn't.

The problem with the editline control keys is that the editline line
is empty!  We need to load it from the current buffer line.  Oh dear,
this is the flaw.  Can we just pass it ed.buffer[ed.dot], and it returns line?
Do we need to return anything?

>>> pm()
>>> s = 'abcd'
>>> def f(s): s = s + 'XYZ'
... 
>>> f(s)
>>> s
'abcd'
>>> def f(s):
...     s = s + 'XYZ'
...     return s
... 
>>> f(s)
'abcdXYZ'
>>> s
'abcd'

So it doesn't update the string parameter. 

So pass line to every editline fcn, return updated line from every el fcn.
Now el() works.   Fix pmacs.

Now pmacs editline fcns work.  Now try open_line, adding lines etc.

>>> sked.buffer[o():o()+4]
['- **skedinit.py**: Define and initialize global variables used by
*sked*.\n', '\n', '\n', '### Introduction ###\n']

Now C_e.  Cursor is after final .

>>> sked.buffer[o()]
'- **skedinit.py**: Define and initialize global variables used by *sked*.\n'
>>> editline.point
73
>>> sked.buffer[o()][editline.point]
'\n'
 
Now type RET.  Another blank line appears.

>>> sked.buffer[o()-1:o()+4]
['- **skedinit.py**: Define and initialize global variables used by
*sked*.\n', '\n', '\n', '\n', '### Introduction ###\n']

That's exactly right, we have new '\n'.  Now type 'New line one' but don't
type RET yet.

>>> sked.buffer[o()-1:o()+4]
['- **skedinit.py**: Define and initialize global variables used by
*sked*.\n', 'New line one\n', '\n', '\n', '### Introduction ###\n']

The text appears on the blank line and pushes \n to the end.
Now two M_b to back up two words.

>>> sked.buffer[o()]
'New line one\n'
>>> editline.point
4
>>> sked.buffer[o()][editline.point]
'l'

Right, that's where cursor is.  Now type RET.  window shows

... *sked*.
New
line one

as it should

>>> sked.buffer[o()-2:o()+4]
['- **skedinit.py**: Define and initialize global variables used by
*sked*.\n', 'New \n', 'line one\n', '\n', '\n', '### Introduction ###\n']

The line break and the \n appear in the right places.  pmacs open_line works.

Put cursor at 1 and type some DEL until lines jon.  We see

New   one

>>> sked.buffer[o()-1:o()+3]
['- **skedinit.py**: Define and initialize global variables used by
*sked*.\n', 'New   one\n', '\n', '\n']

That's right.  Now before joining lines with C_d at end of line.

>>> sked.buffer[o()-1:o()+3]
['command names from *sked* into the REPL so they can be used without\n',
'qualification: \n', '*e(...)* instead of *sked.e(...)*.\n', '\n']

Now C_d at end of line

>>> sked.buffer[o()-1:o()+3]
['command names from *sked* into the REPL so they can be used without\n',
'qualification:  *e(...)* instead of *sked.e(...)*.\n', '\n', 'The *e* (edit)
command loads a file into a buffer in the editor.\n']

Yes, that's right.  Confirm C_d works in line too.

Still to test in pmacs: C_k (both kinds), done.
 C_w, done  C_y (both kinds), done  C_l refresh, done.  C_x + C_a append, done.

Jonathans-MBP-5:editors jon$ git commit -am 'editline: simplify args etc, pmacs: simpler el.runcmd calls'
[editline e8e336a] editline: simplify args etc, pmacs: simpler el.runcmd calls
 3 files changed, 91 insertions(+), 95 deletions(-)
Jonathans-MBP-5:editors jon$ git push
...

Next, make C_k work like in Emacs, see notes above.
Then we will be ready to merge this branch.

Aside, bug - just typing RET does get out of that uninterpreted control
keys situation.  But what gets into it?

(note on 15 Oct) Oh dear, RET doesn't always work - what then?
Type an edsel command  - I tried refresh() - maybe session is back 
in Python REPL but cursor is in text window.

15 Oct 2023

It would be nice if we could use the same C_k code for dmacs and pmacs - but
it might not be possible because in pmacs the first C_k line is handled by
editline -- which isn't available in dmacs.

Maybe we can write pmacs C_k using editline C_k, then if second C_k to 
delete end of line, we can copy first line to sked.yank_buffer then
switch to dmacs C_k?  Here is dmacs kill_line:

def kill_line():
    'Delete single line, accumulate consecutive deleted lines in yank buffer'
    if prev_cmd != kill_line: # first kill_line:, rewrite yank buffer
        edsel.d()
    else: 
        edsel.d(None,None,True) # consecutive C_k, append line to yank buffer

Maybe we can just use edsel.d(None,None,True) in pmacs kill_line too.
Here is pmacs kill_line:

def kill_line(keycode):
    """
    Kill entire line(s) or kill the rest of line at dot
    """
    global yank_lines
    if el.point == 0:  # cursor at beginning of line, kill whole line
        yank_lines = True
        dmacs.runcmd(keycode) # keycode is C_k here
        restore_cursor_to_window()
    else:
        yank_lines = False # cursor within line, only kill from cursor to end
        # Calls editline kill_line, thanks to keycode C_k
        ed.buffer[ed.dot] = el.runcmd(keycode, ed.buffer[ed.dot])

Rename yank_lines -> inline, invert the logic.  In pmacsinit:

inline = True # cut and paste occur within a single line

>>> pmacs.yank_lines
False
>>> del(pmacs.yank_lines)
>>> pmacs.yank_lines
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
AttributeError: module 'pmacs' has no attribute 'yank_lines'
>>> pmacs.inline = True

>>> grep('global yank_lines')
 96     global yank_lines
107     global yank_lines
168     global yank_lines
>>> c('global yank_lines','global inline',1,S())
>>> grep('global yank_lines')
? 'global yank_lines' not found
>>> grep('global inline')
 96     global inline
107     global inline
168     global inline

>>> c('yank_lines = True','inline = False',1,S())

>>> c('yank_lines = False','inline = True',1,S())

Maybe rename pmacs cut to kill_region, to be like emacs?  Done.
Also in editline kill_word, cut_word -> killed_word 

Shouldn't we rename discard to discard_line, analogous to kill_line?   Done.

Now all that's left is to change inline = False logic in pmacs for C_k,
including copying editline.killed to sked.yank_buffer.
Also checking when to rewrite (re-initialize) yank_buffer vs. append to it.


16 Oct 2023

A few more renames. sked.yank_buffer -> sked.killed like editline.killed. Done.

We have kill_region.  Rename all the commands that act on region.

Jonathans-MBP-5:editors jon$ grep region *.py
...
dmacs.py:    key.C_w: (lambda: in_region(edsel.d)), # cut, use C_y (yank above) to paste
dmacs.py:    key.M_q: (lambda: in_region(edsel.wrap)),
dmacs.py:    key.M_carat: (lambda: in_region(edsel.j)), # join lines
dmacs.py:    key.C_c + '>': (lambda: in_region(edsel.indent)), # like emacs Python mode
dmacs.py:    key.C_c + '<': (lambda: in_region(edsel.outdent)),

We already renamed C_w to kill_region.  BUT that's in pmacs, we have
pmacs kill_region because we have to assign inline = False there.  The other
region commands are built from one-line commands wrap, j, indent, outdent.
Don't rename those one-line commands.

onathans-MBP-5:editors jon$ git commit -am 'name changes: yank_lines -> inline, yank_buffer -> killed, discard -> discard_line, cut -> kill_region, others?'
[editline c937036] name changes: yank_lines -> inline, yank_buffer -> killed, discard -> discard_line, cut -> kill_region, others?
 4 files changed, 29 insertions(+), 32 deletions(-)
Jonathans-MBP-5:editors jon$ git push
...

Back to C_k logic.  No changes to dmacs kill_line, but use this line from it
for lines after first line.

        edsel.d(None,None,True) # consecutive C_k, append line to yank buffer


def kill_line(keycode):
    # Lone kill line or first kill line in a series is always inline
    if prev_cmd != kill_line:
        inline = True
    # Exit inline mode and begin multiline mode in this condition:
    # Previous kill line has emptied line except for final \n
    # Then this repeated kill line removes final \n and begins multline mode
    if inline and prev_cmd == kill_line and ed.buffer[ed.dot] = '\n':
        inline = False
        # Enter multiline mode, copy killed line from inline buf to multiline
        sked.killed = [ el.killed ] # cp el.killed to first line of sked.killed
        # Delete the empty killed line from the buffer
        edsel.d(None,None,True) # consecutive C_k, append line to killed buffer
        # FIXME: Now buffer and display should be right, but what about killed?
    # inline kill line:
    elif inline: # weaker condition, must follow previous stronger if...
        ed.buffer[ed.dot] = el.runcmd(keycode, ed.buffer[ed.dot]) # C_k
    # kill line that is part of a multiline sequence:
    elif not inline:
        edsel.d(None,None,True) # consecutive C_k, append line to killed buffer

Something like that ...  

When does inline = True?  Any C_k where prev_cmd is not C_k.   C_k always
starts over in inline mode.


17 Oct 2023

Crash pasting into recently restrted other.txt

File "/Users/jon/Piety/editors/editline.py", line 172, in tab_n
                             line = line[:point] + spaces + line[point:]
>>> pm()                                                                UnboundL

I forgot to put line in  def tab_n  args and in call to tab_n in def tab.
Fixed.


18 Oct 2023

Consider defining dmacs fill_region, indent_region etc. fcns  similar to
pmacs kill_region.  That would implement the philosophy that every
control key corresponds to just a function that we can type at
the REPL instead of an unobvious expression - a lambda expression in the
case of these region commands.

Also, could we have simpler versions of the editline fcns so we 
could more easily edit inline from the REPL?   Or have we gone as
far as we can with that?  We already have el.runcmd(key.<whatever>) or
el.move_end(ed.buffer[ed.dot]).  I guess el.move_end() would be a bit easier.

Later: nah, reject both of those ideas.  They both add code to provide
something we will probably never use.


19 Oct 2023

Paste the above kill_line code into pmacs and try it.   We expect/hope
it will work in text buffer but we also expect killed buffer will have
extra unwanted \n line. 
  
First, test inline C_k.   Crashes because prev_cmd needs to be dmacs.prev_cmd
Oh, but does dmacs.prev_cmd get updated with el.prev_cmd?  Yes, in el case
in pm().   Then we must assign dmacs.prev_cmd in this code too.

Whoa, should we have if dmacs.prev_cmd != kill_line or el.kill_line or ... ?

Now inline C_k works within line or at start of line.   Then second C_k
crashes because we had sked.killed not ed.killed.  Fix.

Now second C_k does the right thing in window - lines below move up -
but cursor remains at REPL.  Add call to restore_cursor_to_window 
in that branch right after call to edsel.d

Now Initial inline C_k and following multiline C_k do the right thing
in the text buffer and the window but C_y shows the killed buffer 
has wrong, old contents - as if it was not rewritten after second C_k.

But now we find:

>>> sked.killed
['up from the Python REPL to the text insertion point in the window,']
>>> editline.killed
'up from the Python REPL to the text insertion point in the window,'

as if subsequent multiline C_k which call edsel.d did not append line 
to sked.killed.

Right, repeat test with second C_k, window and buffer update and
el.killed is copied to beginning of sked.killed.  After next C_k
window and text buffer update but that second killed line does not
appear in sked.killed.

Looking in sked.py we see it refers to yank_buffer many times throughout and
never refers to killed!  I thought we fixed that days ago - did we 
miss sked.py or somehow overwrite it?

REPL shows there is both sked.killed and sked.yank_buffer.  
skedinit.py has killed but not yank_buffer.  Fix now:

>>> del(sked.yank_buffer)
>>> sked.yank_buffer
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
AttributeError: module 'sked' has no attribute 'yank_buffer'

then c('yank_buffer','killed',1,S()) to change them all - confirm it works.

Now crash due to yank_buffer in edsel - just one.  Fix.

Almost working - but we have that expected extra \n after the first line

>>> sked.killed
['Here *from sked import \\** copies the commands in *sked* back into
the REPL.', '\n', 'To resume display editing, repeat *from edsel import
\\** and\n', '*win()* (*win* without an argument restores the previous
window size).\n']

>>> editline.killed
'Here *from sked import \\** copies the commands in *sked* back into the REPL.'

Fix now.

Almost there.  Seems to work, but some weirdness - can't kill successive 
blank lines - !?

Also C_y pasted the wrong thing ... 

Test more tomorrow.   But commit now, this is close.

Jonathans-MBP-6:editors jon$ git commit -am 'pmacs: kill_line behaves more like emacs
> sked, edsel: rename yank_buffer -> killed
> editline: bug fix, add line arg to tab_n'
[editline bd6f551] pmacs: kill_line behaves more like emacs sked, edsel: rename yank_buffer -> killed editline: bug fix, add line arg to tab_n
 4 files changed, 36 insertions(+), 22 deletions(-)
Jonathans-MBP-6:editors jon$ git push
...

Still needs more testing and also style tweaks.


21 Oct 2023

Style tweaks.  Still seems to work.  Revise README.md for new C_k behavior.

Jonathans-MBP-6:editors jon$ git commit -am 'pmacs: style tweaks, README: explain new C_k behavior'
[editline 511759157b] pmacs: style tweaks, README: explain new C_k behavior
 2 files changed, 9 insertions(+), 10 deletions(-)
Jonathans-MBP-6:editors jon$ git push
...

That's all the planned work in this editline branch.  We should be readyto merge it back into ed.   BUT we should get a little more experience to
see if we stumble over any bugs.

Restart this editor session to start fresh with all the new code. ...

We're back.  There is a bug - we don't always rewrite editline.killed when
we C_k - so junk accumulates there.

In editline kill_line (also kill_word and discard) we have this code:

    if killed_segment: # Do not overwrite killed buffer with empty segment
        killed = (killed + killed_segment if prev_cmd in kill_cmds
                       else killed_segment)

This is editline.prev_cmd not dmacs.prev_cmd.  Is there confusion here
about pmacs.kill_line vs editline.kill_line?  

Maybe what we need is, when we switch C_k out of inline mode to multiline
mode we should clear editline.killed?  Let's try that.  Done. Seems to have
worked.

Before merge - try using pmacs for our diary.txt.  It's fine, but not
much of a workout - just several very short paragraphs of a sentence or
two.

The only known persistent bug is this echo-control-chars-as-^A-etc. problem.
The remedy is to type RET.   Maybe we inadvertantly type some control
sequence that is caught/interpreted by the OS and goes into some wierd mode?
Then RET escapes that mode.   But that doesn't ring a bell - neither
the Python REPL nor Python input() nor the shell echoes control characters
that way.  No code I wrote does that.  Where are these echoed control
characters coming from?  Have we seen it anywhere?

This bug isn't enough to hold up the merge.

Jonathans-MBP-6:editors jon$ git commit -am 'pmacs: bug fix, clear editline.killed after copy it to sked.killed'
[editline c09d5c4] pmacs: bug fix, clear editline.killed after copy it to sked.killed
 1 file changed, 1 insertion(+)
Jonathans-MBP-6:editors jon$ git push
...

Jonathans-MBP-6:editors jon$ git checkout ed
Switched to branch 'ed'
Your branch is up-to-date with 'origin/ed'.
Jonathans-MBP-6:editors jon$ git merge editline
Updating 12a1fd8..c09d5c4
Fast-forward
 BRANCH.md               |  11 ++-
 doc/precursors.md       |   1 +
 editors/HOW.md          | 111 ++++++++++++++-------
 editors/NOTES.txt       |  37 ++++++-
 editors/README.md       | 185 +++++++++++++++++++++++++++++++----
 editors/dm.py           |  10 ++
 editors/dmacs.py        |  36 ++++---
 editors/dmacsinit.py    |   3 +-
 editors/editline.py     | 250 ++++++++++++++++++++++++++++++++++++++++++++++++
 editors/editlineinit.py |  19 ++++
 editors/edsel.py        |   7 +-
 editors/pm.py           |  13 +++
 editors/pmacs.py        | 207 +++++++++++++++++++++++++++++++++++++++
 editors/pmacsinit.py    |  12 +++
 editors/sked.py         |  34 +++----
 editors/skedinit.py     |   5 +-
 unix/terminal.py        |  10 +-
 util/README.md          |  10 --
 util/util.py            |  15 ---
 vt_terminal/display.py  |   7 +-
 vt_terminal/keyseq.py   |   6 +-
 21 files changed, 867 insertions(+), 122 deletions(-)
 create mode 100644 editors/dm.py
 create mode 100644 editors/editline.py
 create mode 100644 editors/editlineinit.py
 create mode 100644 editors/pm.py
 create mode 100644 editors/pmacs.py
 create mode 100644 editors/pmacsinit.py
 delete mode 100644 util/README.md
 delete mode 100644 util/util.py

Jonathans-MBP-6:editors jon$ git commit -am 'ed branch: merge in editline branch including new pmacs emacs-like editor'
On branch ed
Your branch is ahead of 'origin/ed' by 51 commits.
  (use "git push" to publish your local commits)

Jonathans-MBP-6:editors jon$ git push
Total 0 (delta 0), reused 0 (delta 0)
remote: To https://github.com/jon-jacky/Piety
   12a1fd8..c09d5c4  ed -> ed

Now look at github web pages for ed branch.  Yes, new code is in ed branch.

We're on the ed branch, revise BRANCH.md commit and push.

Jonathans-MBP-6:Piety jon$ git commit -am 'BRANCH.md: merge editline branch back into ed branch'
[ed 58c2d7d] BRANCH.md: merge editline branch back into ed branch
 1 file changed, 5 insertions(+), 3 deletions(-)
Jonathans-MBP-6:Piety jon$ git push
...

Jonathans-MBP-6:Piety jon$ git checkout rewrite
Switched to branch 'rewrite'
Your branch is up-to-date with 'origin/rewrite'.

onathans-MBP-6:Piety jon$ git merge ed
Removing util/util.py
Removing util/README.md
Auto-merging BRANCH.md
CONFLICT (content): Merge conflict in BRANCH.md
Automatic merge failed; fix conflicts and then commit the result.

edit BRANCH.md

Jonathans-MBP-6:Piety jon$ git status
On branch rewrite
Your branch is up-to-date with 'origin/rewrite'.
You have unmerged paths.
  (fix conflicts and run "git commit")

Changes to be committed:

    modified:   doc/precursors.md
    modified:   editors/HOW.md
    modified:   editors/NOTES.txt
    modified:   editors/README.md
    new file:   editors/dm.py
    ... many more ..

Unmerged paths:
  (use "git add <file>..." to mark resolution)

    both modified:   BRANCH.md

Jonathans-MBP-6:Piety jon$ git add BRANCH.md
Jonathans-MBP-6:Piety jon$ git status
On branch rewrite
Your branch is up-to-date with 'origin/rewrite'.
All conflicts fixed but you are still merging.
  (use "git commit" to conclude merge)

Jonathans-MBP-6:Piety jon$ git merge ed
fatal: You have not concluded your merge (MERGE_HEAD exists).
Please, commit your changes before you merge.
Jonathans-MBP-6:Piety jon$ git commit -am 'git add BRANCH.md to resolve conflict'
[rewrite a9bd8eb] git add BRANCH.md to resolve conflict
Jonathans-MBP-6:Piety jon$ git push
...
 remote: To https://github.com/jon-jacky/Piety
   6fa4525..a9bd8eb  rewrite -> rewrite

Jonathans-MBP-6:Piety jon$ git status
On branch rewrite
Your branch is up-to-date with 'origin/rewrite'.

Jonathans-MBP-6:Piety jon$ git merge ed
Already up-to-date.

Jonathans-MBP-6:Piety jon$ git commit -am 'BRANCH.md: merge ed branch back into rewrite branch'
[rewrite e4b0c47] BRANCH.md: merge ed branch back into rewrite branch
 1 file changed, 4 insertions(+), 1 deletion(-)

Jonathans-MBP-6:Piety jon$ git push
...
remote: To https://github.com/jon-jacky/Piety
   a9bd8eb..e4b0c47  rewrite -> rewrite


Jonathans-MBP-6:Piety jon$ git commit -am 'BRANCH.md - merge ed branch into rewrite branch'
[ed 7b09229] BRANCH.md - merge ed branch into rewrite branch
 1 file changed, 3 insertions(+)
Jonathans-MBP-6:Piety jon$ git push
...

Jonathans-MBP-6:Piety jon$ git commit -am 'make window branch from ed branch'
[window 1499e8d] make window branch from ed branch
 1 file changed, 5 insertions(+), 1 deletion(-)
Jonathans-MBP-6:Piety jon$ git push
Everything up-to-date

But I edited BRANCH.md to say its window branch.   

window branch is not at github.   I think I have to use different push command. 

Jonathans-MBP-6:Piety jon$ git push origin window
Counting objects: 3, done.
Delta compression using up to 4 threads.
Compressing objects: 100% (3/3), done.
Writing objects: 100% (3/3), 399 bytes | 0 bytes/s, done.
Total 3 (delta 2), reused 0 (delta 0)
remote: Resolving deltas: 100% (2/2), completed with 2 local objects.
remote: 
remote: Create a pull request for 'window' on GitHub by visiting:
remote:      https://github.com/jon-jacky/Piety/pull/new/window
remote: 
To https://github.com/jon-jacky/Piety
 * [new branch]      window -> window

Now the window branch is at github with the current BRANCH.md


22 Oct 2022

Review window code in edsel.   I recall we thought it shouldn't be too
hard to adapt it to updating just part of frame by just making a few
constants (actually parameters of term window size) into variables.

Some design issues:

1. Limit two windows or any number?   Two is a practical limit in Mac term
window.   In any case, we should have save_window restore_window fcns so it
is easy to generalize.  How do we index windows - there is no obvious key
as there is with buffer names.

2. Separate frame module from edsel module?  frame would depend only on
 display but not sked, edsel would depend only on frame (and sked) but not
display.   Is it possible to make that clean separation?  If so, is it 
worth the extra verbosity of having 'fr.' prefix all over edsel?

Oops, edsel display_d calls display.kill_whole_line and display.next_line,
so edsel would still have to import display.  It's pervasive: display_c
display_j display_start_a display_input_line all use display module fcns.

Also, use of ed. data structures is pervasive in even the generic edsel
fcns - it seems unecessary.  Instead of global ed.buffer and ed.dot
we could pass lines and iline args.

Give some thought to how to switch ed.buffer and ed.dot when we 
switch windows.  

It looks like the case for separating frame out of edsel is not strong.
Get the whole window scheme working in edsel only then review to see
if splitting it makes sense.

Reviewing edselinit and edsel, it looks like these fcns would continue
to work in multi-window.   From edselinit:

tlines = 24 # N of lines in terminal window, later update with actual number
...
flines = 20 # N of lines in frame, including all windows.
...
wintop = 1 # index of first line of window in frame
wlines = flines # N of lines in current window, including status line.

It looks like all we need to do is reassign wintop and wlines when we 
make/switch windows - then all the existing fcns would update just that window.

edsel win() actually defines the frame, the whole stack of windows.
Should rename win -> frm.  We already have open_frame, called by present win.
Use frm so we could still use frame for module name.

Add fcns to edsel: o2() split window  o1() return to single window
ow() other window (or maybe wo() or sw() switch window) - we already use o()
for dot.

Easiest to implenent o2 first - it doesn't involve changing buffer or
window, just the window dimensions.  Then o1 to reverse it - again,
same buffer and window, just different dimensions.  ow is harder because
it means changing window and possibly buffer, not just dimensions.

We simplify by only ever updating the focus window, even when other window
shows same buffer which might change.    To begin with, even refresh() only
works on the focus window.  After we add machinery for ow(), then refresh()
will update both windows.

Start hacking - add edsel o2(), try it out.

First, how does emacs do it?  After o2, does focus go to upper half or 
lower half?

In emacs after C-x 2, focus stays in upper half.   If cursor was
low in window when split, upper half window is refreshed to center 
cursor.

Also, in emacs, lower half is refreshed so it shows same as upper half - the
cursor appears in the same place in the lower half as it does in upper half.
We won't do  that initially - we'll just not refresh lower half at all.

Aside, BUG - looks like M-q fill at end of buffer leaves extra line at the endd.
Refresh repairs it.

Another BUG - Can't use C_k to delete line that has just \n.

More BUGS - some lines without \n at the end.  Look okay on the screen but
when you write out the file Python reports syntax errors.  I think I
created them using DEL at start of line with just \n to get rid of that line - 
see previous bug.

I think prev bug might be due to this in pmacs.py def kill_line:

    # Exit inline mode and begin multiline mode in this condition:
    # Previous kill line has emptied line except for final \n
    # Then this repeated kill line removes final \n and begins multline mode
    if inline and dmacs.prev_cmd == kill_line and ed.buffer[ed.dot] == '\n':
        inline = False

I think the problem is ..and dmacs.prev_cmd == kill_line ...
If there is only just \n on line already there won't be previous kill_line.
I think we can just omit that conjunct.

No! Leave that branch as-is - it deals with editline.killed.  Have
a new branch with just \n on line.

After C-x k to kill buffer, then ^X^F echoes in text window.  then type RET
and see Find file: prompt, type filename and it goes to file and after that
session behaves normally. This is repeatable.   What's going on?

Do we get stuck in this mode if we respond to File file: with ???

Now I can't repeat it - also typing text doesn't changed saved -> unsaved

BUG? Is that because I am using editline?  Does editline set unsaved?

Back to kill_line - after delete \n by itself, then another
line: ### Introduction - it appends ### Introduction to sked.killed,
does not start sked.killed over.   

When do we rewrite sked.killed?  Shouldn't it be when we make transition
to inline = False?   Yes, but two cases dmacs.prev_cmd == kill_line yes or no.

Jonathans-MBP-6:editors jon$ git commit -am 'pmacs: revise kill_line, edsel: add split window o2 one window o1
> skedinit: rmargin = 72 not 78'
[window 5330db2] pmacs: revise kill_line, edsel: add split window o2 one window o1 skedinit: rmargin = 72 not 78
 3 files changed, 32 insertions(+), 13 deletions(-)
Jonathans-MBP-6:editors jon$ git push
...


24 Oct 2023

Jonathans-MBP-6:editors jon$ git commit -am 'pmacs: expand comment header for kill_line function
> NOTES.txt: add section on pmacs, inline/multiline modes for kill_line, yank'
[window a700e9b] pmacs: expand comment header for kill_line function NOTES.txt: add section on pmacs, inline/multiline modes for kill_line, yank
 2 files changed, 45 insertions(+), 2 deletions(-)
Jonathans-MBP-6:editors jon$ git push
...

26 Oct 2023

I guess we've decided code will support indefinitely large number of 
windows, restricted only by maxwindows.  Of course it's easier if you
just limit it to one other window.

Working on edsel window fcns o2 o1 ow

In ow (other window) how do we find other window in windows dict?
Saved window needs to include window key so it can be found.

Can we assume we always move to next higher key, wrapping around
to 0 after maxwindows - 1 ?
 
How do find/calc nwindows?  Is it the size of saved windows dict + 1
or just saved windows dict?

Does the saved windows dict also include the focus window?

For now this code only has to deal with one saved window,
but let's make it more general.

Let's have wkeys, list of window keys of all visible windows
including focus window in order from top to bottom.


27 Oct 2023

Macbook charger broke - cable twisted off - found old one still barely
works.  Rush to save what we have before total breakdown:

Jonathans-MBP-6:editors jon$ git commit -am 'edsel, edselinit: add support for windows, not yet tested'
[window d91889d] edsel, edselinit: add support for windows, not yet tested
 2 files changed, 58 insertions(+), 6 deletions(-)
Jonathans-MBP-6:editors jon$ git push
...

Later - Got a power brick at the Apple store in Bellevue Square - it's the
same model, 60 W MagSafe model no. A1344.   So we're back in business
for ... another 5 years?

Back to edsel windows.   In on() next window, I don't have any code yet
to put cursor in new window at its dot, and leave a marker in the other window.
I think saved window has to include that window's dot as well as the buffer -
both windows can show same buffer but with different dot.

Later ... It seems we only need to do save_window in on() next window right
before we switch.  BUT we do save_window as soon as we get new window also - 
that's for crash protection - so we can always recover the windows we 
see onscreen, or that were there before crash.


28 Oct 2023

o2() o1() seem to work.  on() does not - cursor does not move to next
window and C-v M-v still scroll the top window.  After o1() again:

>>> o1()
>>> edsel.wkeys
[1]
>>> edsel.windows
{1: {'wintop': 1, 'wlines': 22, 'bufname': 'edsel.py', 'dot': 438}}
>>> edsel.focus
1

This is what we see - but focus has changed from 0 to 1 - I think on()
did that.  Then o2()

>>> edsel.wkeys
[1, 2]
>>> edsel.windows

{1: {'wintop': 1, 'wlines': 11, 'bufname': 'edsel.py', 'dot': 438}, 2:
{'wintop': 12, 'wlines': 11, 'bufname': 'edsel.py', 'dot': 438}}

>>> edsel.focus
1

That second wkey shouldn't be 2, should be 0.   Then on()

>>> edsel.wkeys
[1, 2]
>>> edsel.focus
1
>>> edsel.windows
{1: {'wintop': 1, 'wlines': 11, 'bufname': 'edsel.py', 'dot': 412},
2: {'wintop': 12, 'wlines': 11, 'bufname': 'edsel.py', 'dot': 438}}

So it looks like on() did nothing -- !?  Oh, I had wkey = max(wkeys) + 1
I forgot the ... % maxwindows

>>> wkeys = [1]
>>> maxwindows = 2
>>> max(wkeys)
1
>>> max(wkeys) + 1
2
>>> (max(wkeys) + 1) % maxwindows
0

>>> edsel.focus
1
>>> edsel.wkeys
[1]
>>> edsel.windows
{1: {'wintop': 1, 'wlines': 22, 'bufname': 'edsel.py', 'dot': 412}}

>>> o2()
>>> edsel.focus
1
>>> edsel.wkeys
[1, 0]
>>> edsel.windows
{1: {'wintop': 1, 'wlines': 11, 'bufname': 'edsel.py', 'dot': 448}, 0:
{'wintop': 12, 'wlines': 11, 'bufname': 'edsel.py', 'dot': 448}}

>>> pm()

Some C-v M-v

>>> on()
>>> edsel.focus
0
>>> edsel.windows
{1: {'wintop': 1, 'wlines': 11, 'bufname': 'edsel.py', 'dot': 398}, 0:
{'wintop': 12, 'wlines': 11, 'bufname': 'edsel.py', 'dot': 448}}
>>> edsel.wkeys
[1, 0]

So we did update wkeys ikey and focus correctly.  BUT cursor and 
C-v M-v still work in top window like before.

Run the test again and look at dot on screen and in windows dict.

>>> o1()
>>> edsel.focus
0
>>> edsel.wkeys
[0]
>>> edsel.windows
{0: {'wintop': 1, 'wlines': 22, 'bufname': 'edsel.py', 'dot': 407}}


>>> edsel.focus
0
>>> edsel.wkeys
[0, 1]
>>> edsel.windows
{0: {'wintop': 1, 'wlines': 11, 'bufname': 'edsel.py', 'dot': 407}, 1:
{'wintop': 12, 'wlines': 11, 'bufname': 'edsel.py', 'dot': 407}}

>>> pm() 

cursor appears in top window.  Now do some M-v to make dot different from
lower window.  Top window scrolls, it must be wkey 0.  Now status lines show dot is 299 in top window
and 407 in bottom window.

>>> edsel.focus
1
>>> edsel.windows
{0: {'wintop': 1, 'wlines': 11, 'bufname': 'edsel.py', 'dot': 299}, 1:
{'wintop': 12, 'wlines': 11, 'bufname': 'edsel.py', 'dot': 407}}
>>> edsel.wkeys
[0, 1]


Now focus is 1 not 0  and windows[1]['dot'] is 407 not 299 - so the data
shows focus has changed.  

Now C-v still makes top window scroll.  dot changes from 299 to 431

>>> ed.dot
431
>>> edsel.focus
1
>>> edsel.windows[edsel.focus]['dot']
407
>>> edsel.windows[0]['dot']
299

What if we refresh the screen?

>>> refresh()

We see the top window, with 

>>> edsel.wintop
12 
>>> edsel.focus
1
  
>>> edsel.windows[1]['wintop']
12

So how come it's still scrolling the top window with wintop 1?
It says edsel.wintop 12

>>> edsel.wintop
12
>>> wintop
1

There shouldn't be any wintop, should there?  Oh, yes it exists because
we did from edsel import *

>>> wintop is edsel.wintop
False

>>> from edsel import *
>>> wintop
12
>>> wintop is edsel.wintop
True
 
So that's a source of confusion!  But just look at edsel.<whatever>
because it updates when o?() runs.  Without edsel. qualification,
immutable variables won't update when o?() runs.

BUT how can we have edsel.wintop 12 and top window updates?

The simplest explanation is, there is some window update code
that does not use edsel.wintop but uses hardcoded 1.   Review that code.


29 Oct 2023

Right, edsel update_window has hardcoded 1 passed to update_lines wstart arg.
Change to wintop now.  refresh and recenter both call update_window.
recenter called by o2 o1 on.  So that could explain what we saw.

That's the only place I found hardcoded 1 instead of wintop.

Do we really have to do 'from edsel import *', 'from pmacs import pm' etc.
after C-x C-r reload?

>>> pm()
Wrote edsel.py, 464 lines
Wrote edsel.py, 464 lines
Reload module edsel

>>> id(o2)
4463171616
>>> id(edsel.o2)
4463168240
>>> o2 is edsel.o2
False

Yes, we definitely do.

>>> from edsel import *
>>> id(o2)
4463168240
>>> o2 is edsel.o2
True

That fixed it.

Can't we fold this into C-x C-r command, save_reload?
Might be hard to ensure the symbols are imported into REPL - 
the __main__ module I guess - instead of dmacs module where
save_reload is defined.

If we can't fix this we have to explain in README that you must 'from ...'

But first get windows working.

Now on() makes top window go blank!  C-n C-p C-v M-v update status line
for top window but window itself remains blank!  refresh() - it remains blank!
o1() restores text in single window.
 

30 Oct 2023

Why does on() now blank the top window?   I am suspicious of these
lines in update_window:

    nlines = min(nlines, wlines-wstart+1) # n of lines at end of window    nlines = min(nlines, len(ed.buffer)-bstart+1) # n of lines at e.o. buffer

Up till now we've only been using wstart 1 so this is just wlines.
Are we updating wlines in the o?() - ?  We do in o1, o2, and in on
via save_window and restore_window.

But does that line make sense?  Here wstart is wintop, so
wlines-wstart+1 = 11-12+1 = 0 !   That can't be right?  What was
I getting at here?

>>> edsel.focus
0
>>> edsel.wkeys
[0]
>>> edsel.windows
{0: {'wintop': 1, 'wlines': 22, 'bufname': 'dmacs.py', 'dot': 28}}

>>> o2()
>>> edsel.focus
0
>>> edsel.windows
{0: {'wintop': 1, 'wlines': 11, 'bufname': 'edsel.py', 'dot': 397}, 1:
{'wintop': 12, 'wlines': 11, 'bufname': 'edsel.py', 'dot': 397}}
>>> edsel.wkeys
[0, 1]

That is consistent with what we see in windows and the two status lines.     

>>> on()

Top window goes blank!

>>> edsel.focus
1
>>> edsel.wkeys
[0, 1]
>>> edsel.windows
{0: {'wintop': 1, 'wlines': 11, 'bufname': 'edsel.py', 'dot': 397}, 1:
{'wintop': 12, 'wlines': 11, 'bufname': 'edsel.py', 'dot': 397}}

Those all look right.  But did we actually restore windows[1] ?

>>> edsel.wintop
12
>>> edsel.wlines
11
>>> sked.dot
397

Hey - isn't buftop relevant?  Where is it used in edsel?  Maybe
we should save that instead of ed.dot?


31 Oct 23

The purpose of those two lines at start of update_window ...

def update_lines(bstart, wstart, nlines):
    """
    Display consecutive lines (a 'segment') from the buffer in the window.
    Display nlines, starting at bstart in buffer, starting at wstart in window.
    Clip nlines if needed, to fit in window, and not run past end of buffer.
    Leave cursor after the last line displayed.
    """
    nlines = min(nlines, wlines-wstart+1) # n of lines at end of window    nlines = min(nlines, len(ed.buffer)-bstart+1) # n of lines at e.o. buffer
    ...

No, that first ilne is not wrong, the wstart arg is the line number in the
window whhere the first line from the buffer goes.   So when we update
the whole window as in recenter or refresh, wintop is the correct item
to pass.   BUT I think the code is wrong.   Here are two examples:

In the first column, wintop is 1, wlines is 5, wstart is 3,
final nlines is also 3.

In the second column, wintop is 12, wlines is again 5, wstart is 14,
final nlines is again 3.

1  12   wintop                 - line number of first line in window
2  133  14   wstart                 - line number of first line to update
4  15 5  16   wintop + wlines - 1    - line number of last line in window

 4 Nov 2023
What we want is the number fo lines from wstart to the end, inclusive.
That would be (wintop + wlines - 1) - wstart + 1 or wintop + wlines - wstart
Note that this is the same as old wlines - wstart + 1 if we replace 1 by
wintop.  So it used to be correct, and new formula is clearly correct.
 
We could find out if those nlines = min(...) are the problem by simply
commenting them out.  And, doesn't the caller calculate the correct number
of lines, so they should have no effect anyway?

Still, next window on() causes current (top) window to go blank,
and refresh() doesn't fix it - just gets other wierdness.  o1()
does restore single window though.

on() shouldn't change appearance of current (top) window at all.
The blanking must be in recenter because it's the only display
code in on().

Or is that implicit in recenter?   
Do we have to do anything to explicitly move cursor to new window?

def refresh():
    '(Re)Display buffer segment, marker, status without moving segment'
    display.put_cursor(wlines, 1) # window status line
    display.erase_above() # erase entire window contents above status line
    ...

That's why the top window is blanked.   I think this erase_above() won't
work with multiple windows, we have to replace it with something else.


 5 Nov 2023

Apparently there isn't any ANSI code to erase a range of lines.  We either
have to code it ourselves from separate erase line commands.  Or maybe we
don't need to do this at all -- don't the other update_... commands 
clear out the end of the line or the remaining lines?

erase_above appears in open_line, refresh, open_frame, win.   We can
keep it in open_frame and win - we only have to fix open_line and refresh.

In open_line we have

    if not in_window(iline+1):
        display.put_cursor(wlines, 1) # window status line
        display.erase_above() # erase entire window contents above status line
        buftop = locate_segment(iline)
        update_window()

In refresh we have:

def refresh():
    '(Re)Display buffer segment, marker, status without moving segment'
    display.put_cursor(wlines, 1) # window status line
    display.erase_above() # erase entire window contents above status line
    update_window()
    ...
Does update_window here have the effect of erase_above?

def update_window():
    'Update entire window up to status line, starting at line buftop in buffer'
    update_lines(buftop, wintop, wlines-1)

So it updates all the lines in the window

def update_lines(bstart, wstart, nlines):
    ...

The code just writes nlines lines - it clears the end of each 
of those lines, but doesn't clear any extra lines after that. 
AND it clips at the end of the buffer, so if there are lines
in the window after the end of the buffer, they *don't* get cleared.

Don't we have code elsewhere that clears the window after the end of the
buffer?  Yes, in these lines at the end of display_d:

def update_below(bstart, offset=0):
    wstart = wline(bstart) + offset
    nlines = wlines - wstart
    update_lines(bstart, wstart, nlines)

def display_d(iline):
    ...
    if in_window(ed.dot):
        update_below(ed.dot)
        nlines = wlines - wline(ed.dot) # n of lines to end of window
        nblines = ed.S() - (ed.dot + 1) # n of lines to end of buffer
        nelines = nlines - nblines # n of empty lines at end of window
        for iline in range(nelines+1): # make empty lines at end of window
            display.kill_whole_line()
            display.next_line()

Maybe all that code after update_below can be put in a fcn clear_below(iline)

display_d is the only place that update_below is followed by clear_below code.


 6 Nov 2023

update_lines, update_window, update_below leave the cursor after the last
line written.

In open_line and refresh, replace put_cursor(wlines, 1); erase_above()
with put_cursor(wintop, 1); erase_nlines(... window size ...)

Oh for pity's sake, why does display_d calculate nelines then says
for iline in range range(nelines + 1) - ?  Is this a mistake? 
It doesn't actually use iline

Make changes - define erase_lines, use in open_line, refresh, and display_d
Try those three functions - do they still work?  Then try o2() and on().


 7 Nov 2023

C-l refresh, and >>> refresh() still seem to work.

C-x C-a still works - opens line, enters append mode, then type  .
to exit append mode.

C-w calls edsel display_d, it works.   

So it appears we haven't broken anything with our new erase_lines().

Try o2(), on().   on() switches focus to other window - after pm(),
C-v and M-v operate on othe window - on() switches back, then o1()
returns to single window.

BUT cursor does not move to other window on on().


 9 Nov 2023

Add keycodes to dmacs: C-x 2 for o2, C-x 1 for o1, C-x n for on.
Just C-x C-r reload and from dmacs import dm, from pmacs import pm.

Almost works, but cursor does not move to other window when C-x o.
Must fix edsel on().   

I thought recenter moved cursor - ?  Yes, it calls refresh which
calls update_window, put_marker, update_status.  update_status
calls return_cursor_to_cmdline.

edsel defines restore_cursor_to_cmdline.  But restore_cursor_to_window
isn't defined until pmacs, because it uses editline.point.  Right, edsel
and dmacs don't have the cursor in the window at all - it's always in the REPL.
So we have to define pmacs.on that is like edsel.on but at the end calls
restore_cursor_to_window().  

o2 doesn't really handle other window correctly - cursor might not be
in window, mark isn't shown.

>>> edsel.on()
>>> edsel.focus
1
>>> edsel.wkeys
[0, 1]
>>> edsel.windows[1]
{'wintop': 12, 'wlines': 11, 'bufname': 'pmacs.py', 'dot': 166}

>>> edsel.on()
>>> edsel.focus
0
>>> edsel.windows[0]
{'wintop': 1, 'wlines': 11, 'bufname': 'pmacs.py', 'dot': 166}

This was after o2 so the two windows show the same thing.

Now scrolling with v() and rv() scrolls top window - marker moves 
as it should.

>>> on()

marker remains in top window

>>> edsel.focus
1
>>> edsel.windows[1]
{'wintop': 12, 'wlines': 11, 'bufname': 'pmacs.py', 'dot': 166}

but focus is in bottom window.  v() and rv() scroll bottom window
but no marker in bottom window and status line in *upper* window updates!

Does on() restore the window vars from saved windows?

>>> edsel.focus
1
>>> edsel.windows[edsel.focus]
{'wintop': 12, 'wlines': 11, 'bufname': 'pmacs.py', 'dot': 166}
>>> edsel.windows[1]
{'wintop': 12, 'wlines': 11, 'bufname': 'pmacs.py', 'dot': 166}
>>> edsel.wintop, edsel.wlines, sked.bufname, sked.dot
(12, 11, 'pmacs.py', 197)

we've moved dot since last save_window.  Everything else looks good.

Then when I change buffer, the lower window updates with new buffer contents
BUT again upper window status line updates, and still no cursor in lower
focus window.

edsel update_status contains this line, which is now wrong.

    display.put_cursor(wlines, 1) # window status line

Change wlines to wintop+wlines-1.


10 Nov 2023

That fixed the status line.  But the cursor still doesn't go to the new
window.

After C-v and M-v, don't we call restore_cursor_to_window?
In pmacs pm(), that runs after *every* dmacs command.  So we should
back out C-x o special case in pmacs.py.

restore_cursor_to_window has line:

    display.put_cursor(edsel.wline(ed.dot), el.point + 1)

It's the same error as we fixed in update_status.  Change wlline(ed.dot)
to wintop+...wline(...)-1.  Done.  That seems to work.
 
Are we finished with windows?  Any other loose ends?  Let's just try it
for a while.

Don't we have to fix refresh so it refreshes all windows?  Or maybe just
leave it how it is?   Other window never updates anyway.

An experiment: split window so same buffer at same location appears
in both windows.  Edit in one window.  Predict edits will not appear
in other window.  Then when we go to other window, it should refresh
with new contents.

Oh, but bottom window does not show same as top window after split - because
we don't refresh it.  Have to adjust top window so it shows same loc
as bottom.  Well, OK.


11 Nov 2023

Hey, shouldn't that correction be made within the body of wline()?
Look for all calls of wline().   Confusing naming, we also have wlines.

wline() calls are pervasive in edsel!  How could windows work at all 
if it's wrong?  Code:

def wline(iline):
    'Return index of line in window that displays iline from buffer.'
    wiline = iline - buftop + 1
    return wiline if wiline >=1 else 1

Comment is ambiguous.  'line in window' - does that mean line in frame,
that is in (enclosing) *terminal* window, or (contained) *display* window 
within frame (terminal window)?   Which is it?  Of course, with a single
window in a frame they are the same.


15 Nov 2023

It occurs to me we don't have to say, for example, 

EDPATH = '/Users/jon/Piety/editors/' # FIXME? assign via env var or cmd line?
try:
    _ = flines # if flines is already defined, then edselinit was already exec'
except:
    exec(open(EDPATH + 'edselinit.py').read())

We could just have 

try:
    _ = flines # if flines is already defined, then edselinit was already exec'
except:
    from edselinit import *

This will import the identifiers and initial values of the variables from
edselinit into edsel.  Subsequent updates to those variables made by fcns
in edsel will appear in edsel, not edselinit.   That's just what we want!
This eliminates the complicated exec(open(...).read()) and also eliminates
need for EDPATH because from ... import uses PYTHONPATH.


16 Nov 2023

Write to JC (email today):

--------

Subject: Python exec vs import

I've had second thoughts about this.  I realized I could use import
instead of exec and I think it's better.

Recently I showed you this code in my edsel module, which creates and
initializes the variables in the edselinit.py file into the edsel
module:

EDPATH = '/Users/jon/Piety/editors/' # FIXME? assign via env var or cmd line?
try:
    _ = flines # if flines is already defined, then edselinit was already exec'
except:
    exec(open(EDPATH + 'edselinit.py').read())

The try ... except ... ensures the variables are initialized only
once, the first time the edsel module is imported - but *not* when it is
reloaded.

The exec(...) executes the code in edselinit.py *without* importing
edselinit as a module, so the variables defined in edselinit end up  in
the edsel module, not in a separate edselinit module.   In general, this
is the idiom for executing code from a file in the context of the
current module without importing the file and creating a new module.

I have decided that this exec(...) idiom is too complicated, too limited,
and not necessary for my edsel editor or elsewhere in Piety.  I replaced
the above code with:

try:
    _ = flines # if flines is already defined, edselinit was already imported
except:
    from edselinit import *

This keeps the same try ... except ... structure so the variables are 
only initialized once.  It replaces exec(...) with from ... import *.
This has the same effect of copying the variables and their initial values
from edselinit.py into the edsel module.   

This might seem to be a small revision, but the
from ... import .. statement really is better here than the exec(...)
statement.  It is better style (shorter and clearer) to use the built-in
import machinery, than to resort to some un-obvious home-made
alternative.  But it is  not just a matter of style.  The revised code
behaves differently (and better) because it does not require the module
to be located at the hard-coded EDPATH.   Instead, import implicitly
uses PYTHONPATH, which allows the module to be located anywhere.


PS. This code also has the effect of importing the edselinit module into
the session, but it has a sort of phantom existence.  There is no
edselinit module name, that module can only be reached through
sys.modules:

>>> edsel
<module 'edsel' from '/Users/jon/Piety/editors/edsel.py'>

>>> edselinit
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
NameError: name 'edselinit' is not defined

>>> sys.modules['edselinit']
<module 'edselinit' from '/Users/jon/Piety/editors/edselinit.py'>

This is good because it prevents confusion.  There is no possibilty of
accessing the variables in edselinit by mistake.   After the initial
from ... import ... the variables in edselinit and the corresponding
imported variables in edsel diverge; they can have different values.

-------

Back to edsel wline, see 11 Nov above.  I think 'window' in the comment
means the (software generated) display window, not the terminal window.

IF buftop is maintained correctly, and refers to the top of the 
software generatdd display window, then wline is correct as is.

buftop is returned by locate_segment.  It is called by recenter.

wintop is assigned by restore_window, o1 (sets it to 1).  o2 does not
reassign wintop because focus remains in same (top) window. BUT 
o2 calls save_window(wkey, wintop + wlines, ...) so the saved wintop
is different.  Then the subsequent restore_window in on() changes wintop.
That's the only place that wintop changes!

So it looks like the management of the window vars is correct and up-to-date.
Maybe could improve explanations in comments.

I realized I could get rid of all the *init.py files - just put the 
all the variable initializations in the except... branch in each module.
See emails to JC.

We have five *init.py files with 9 to 32 lines.  But the comment header
at the top can be omitted.

I recall refresh() has not been adapted to multiple windows.

First let's tweak the comments.  Commit.
Then deal with refresh. Commit.
Then deal with marker. Commit.  (I believe we have already dealt with cursor)
The get rid of the *init.py files, and revise .txt and .md files. Commit.

Then consider separating frame out of edsel.

Only then will we be done with the ed branch.


17 Nov 2023

Present refresh only refreshes the focus window, not the whole frame.

It's not hard to make a refresh that refreshes whole frame, but there
are other problems.

o2() split can leave other window at segment with no dot in it - so after
the split the two windows show different segments.   Then, after on() next
window, next window refreshes to put dot in the window - this should happen
when split is made.

So revise o2() to work that way - parameterize refresh() and recenter()
to work in any window by passing wintop, wlines, iline.  Call
those refresh_window, recenter_window, then define refresh, recenter that
work on focus window - no args.   

No, that's not convenient, because we would also have to give
update_window and update_lines and update_status the same treatment.
Better to just save and restore windows as needed.

Maybe it's better to write refresh_all that restores each window
and calls refresh - but no, that's not right because we want recenter
in both windows at o2.  So just code it all inline in o2.

Maybe we don't need a refresh_all?  We can manually refresh each window.

Later - test.  revs in o2 are not effective aftr C-x C-r in edsel then
from edsel import * - also have to C-x C-r in dmacs then from dmacs import dm
and C-x C-r in pmacs then from pmacs import pm.

Now other window recenters to show dot.  Dot is at top of both windows
and C-n and C-v both get error message in both windows: 

 ? line 0 out of range 1 .. 216    

escape by C-x o to other window then again to go back.  

We still don't see mark in other window when o2 or on.

Somehow we got into echo ^N etc. mode - !?   RET executes command but
does not get out of it.  M-x gets back to >>> then pm() gets ito proper
functioning.  

Cursor goes to correct window and remembers position in other window
so C-x o restores cursor to correct position there.

BUT we don't see marker.

Also, it looks like dot is not saved at C-x o - if we C-x o, then move
dot, then C-x o to former window and C-x o back to same window, cursor
jumps back to former position.

edsel on() looks correct, though, with save_window and restore_window
both apparently in the right places.

Oh, but look at restore_window - it's a little tricky, windows in same
buffer or different buffer are handled differently, is it right?
Oh, restore_window calls restore_buffer if other window is different buffer.
Does save_window call save_buffer in that case?

It does work correctly when both windows are in same buffer.

BUT save_window does save buffer and dot - so what's the problem?

So the first problem to solve is restoring dot in next window.

Next problem is placing marker.

When looking at two windows in the same buffer, switching to other
window recenters that window on the dot in that window.   

on() next window should not recenter the window.   Should only 
recenter window when we create new window.

That's fixed - but alternating windows by repeating on() - sometimes
cursor doesn't appear in new window, it appears at REPL command
line insted, then C-n or C-p to move it, 
it returns to window but window recenters.  This happens just sometimes - !?

Something is not right about restoring dot.  Investigage by looking
at saved windows.

It looks like edsel.buftop is not getting recalculated correctly.
recenter() is the only code that reassigns buftop = locate_segment
BUT don't we need to recalculate buftop each time we change window, 
even if we don't recenter?   Shouldn't buftop be part of saved window?

Amazing - save,restore_window don't use buftop!  They just save dot, 
and then we were depending on recenter to position buffer in window.

Fix now.  Tweak save_window.   Good, now two windows into same buffer work.

Now try loading a different file and buffer into top window with C-x f
Then saved window for that window does not change, but after C-x o it should 
change.  It does.

Then when I try to C-x o back to first window with new file in it,
it crashes because restore buffer doesn't find it in saved buffers.
Indeed, save_window should conditionally call save_buffer analogous
to how restore_window calls restore_buffer.

BUG
I've noticed after C-k... or C-w then C-y doesn't always restore cut lines - !?


19 Nov 2023

save_window now calls save_buffer.  Just C-x C-r then from edsel import *
then pm().  Now it works.   I didn't have to from dmacs ... or from pmacs ...

Are we going to worry about marker and cursor?


22 Nov 2023

How does the marker work in plain edsel?

BUG - after o2() then o1() then o2() again it says 'No more windows'
but we still have

>>> edsel.focus
0
>>> edsel.wkeys
[0, 1]
>>> edsel.windows
{0: {'wintop': 1, 'wlines': 24, 'buftop': 412, 'bufname': 'edsel.py', 'dot': 424}}

two problems here - edsel.windows should be just [0] and it should not
responde to o2() with 'No more windows'.   These are the same problem:

    if len(wkeys) >= maxwindows:
        print('? no more windows\r\n', end='')
        return

So why didn't it remove 1 from wkeys?   Oops, we're missing some
lines from o1() due to editing BUG earlier (C-w then C-y didn't 
restore the lines).  Fix that and reload and fix focus and wkeys by hand.
Now o2 works but but on still doesn't work:

>>> edsel.wkeys = [ focus ]
>>> o2()
>>> on()
? only one window
>>> edsel.wkeys
[1]
>>> edsel.focus
0
>>> edsel.windows
{0: {'wintop': 13, 'wlines': 12, 'buftop': 448, 'bufname': 'edsel.py', 'dot': 454}}

How can edsel.wkeys say [1] when the focus and the only window is 0?
Also, o2 should have created another window - !?  It looks like o2 is
not updating windows or wkeys, although two windows did appear on screen
in the right places.  Also, note wlines of window 0 is only 12 not 24. 
Then o2 again splits another window - but o1() still says only one window.

Then clr() win(24) refresh() just makes a mess.  Reset everything by hand:

>>> edsel.wintop = 1
>>> edsel.wlines = 22
>>> edsel.buftop = 1
>>> edsel.bufname = 'edsel.py'
>>> edsel.dot = 1
>>> edsel.windows.clear()
>>> edsel.save_window(edsel.focus)
>>> edsel.windows
{0: {'wintop': 1, 'wlines': 22, 'buftop': 1, 'bufname': 'edsel.py', 'dot': 454}}

>>> win(24)

single window appears with edsel.py dot at 454 - because save_window gets
it from sked. not edsel.

I can't find anything wrong with o2.  Try again.  Before o2():

>>> focus
1
>>> edsel.wkeys
[0]
>>> edsel.windows
{0: {'wintop': 1, 'wlines': 22, 'buftop': 1, 'bufname': 'edsel.py', 'dot': 454}}

This is already wrong.   Should be focus 0

>>> edsel.focus = 0
>>> edsel.focus
0

It was probably alright all along.  I said >> focus above not edsel.focus.
Get rid of garbage, confirm we have good data:

>>> del(focus)
>>> del(edsel.dot)
>>> sked.dot
444
>>> edsel.focus
0

>>> edsel.o2()

It looks right - top and bottom window have same contents, same status line,
marker in upper window.

>>> edsel.focus
0
>>> edsel.wkeys
[0, 1]
>>> edsel.windows
{0: {'wintop': 1, 'wlines': 12, 'buftop': 438, 'bufname': 'edsel.py', 'dot': 444}, 1: {'wintop': 13, 'wlines': 12, 'buftop': 438, 'bufname': 'edsel.py', 'dot': 444}}

>>> edsel.on()

>>> edsel.focus
1
>>> edsel.wkeys
[0, 1]
>>> edsel.windows
{0: {'wintop': 1, 'wlines': 12, 'buftop': 438, 'bufname': 'edsel.py', 'dot': 444}, 1: {'wintop': 13, 'wlines': 12, 'buftop': 438, 'bufname': 'edsel.py', 'dot': 444}}
}, 1: {'wintop': 13, 'wlines': 12, 'buftop': 438, 'bufname': 'edsel.py', 'dot': 444}}

>>> l()
>>> l()
>>> l()

Now marker moves in upper window but status line updates in lower window!

>>> l()
>>> l()

Now lower window recenters but marker remains in upper window.

>>> edsel.focus
1
>>> edsel.wkeys
[0, 1]
>>> edsel.windows
{0: {'wintop': 1, 'wlines': 12, 'buftop': 438, 'bufname': 'edsel.py', 'dot': 444}, 1: {'wintop': 13, 'wlines': 12, 'buftop': 438, 'bufname': 'edsel.py', 'dot': 444}}
... I forgot to copy 1: {...}


dot in lower window status line is 449 but saved window has not been updated.

>>> edsel.o1()
>>> edsel.focus
1
>>> edsel.wkeys
[0]
>>> edsel.windows
{0: {'wintop': 1, 'wlines': 24, 'buftop': 437, 'bufname': 'edsel.py', 'dot': 449}}

Wrong! it did not update focus.  BUT o1() code is current.  I think it didn't
run new version. Try again.

>>> pm()
Wrote edsel.py, 486 lines
Reload module edsel
>>> from edsel import *

>>> edsel o2()
>>> edsel.focus
0
>>> edsel.wkeys
[0, 1]
>>> edsel.windows
{0: {'wintop': 1, 'wlines': 12, 'buftop': 443, 'bufname': 'edsel.py',
'dot': 449}, 1: {'wintop': 13, 'wlines': 12, 'buftop': 443, 'bufname':
'edsel.py', 'dot': 449}}

Had to type M-q to wrap edsel.windows.

>>> edsel.o1()
>>> edsel.focus
0
>>> edsel.wkeys
[0]
>>> edsel.windows
{0: {'wintop': 1, 'wlines': 24, 'buftop': 437, 'bufname': 'edsel.py',
'dot': 449}}

That's all correct.  Now split again and next window before o1.

>>> edsel.o2()
>>> edsel.focus
0
>>> edsel.wkeys
[0, 1]
>>> edsel.windows
{0: {'wintop': 1, 'wlines': 12, 'buftop': 443, 'bufname': 'edsel.py',
'dot': 449}, 1: {'wintop': 13, 'wlines': 12, 'buftop': 443, 'bufname':
'edsel.py', 'dot': 449}}

>>> edsel.on()
>>> edsel.focus
1
>>> edsel.wkeys
[0, 1]
>>> edsel.windows
{0: {'wintop': 1, 'wlines': 12, 'buftop': 443, 'bufname': 'edsel.py',
'dot': 449}, 1: {'wintop': 13, 'wlines': 12, 'buftop': 443, 'bufname':
'edsel.py', 'dot': 449}}

That's correct.  It looks correct on screen too.

Let's try to leave a stationary marker in the other window, but move the 
marker to the new window.

edsel put_marker uses wline(bufline) - don't we have to adjust that?
wline already includes buftop.  But wline is *index of line in window*
not in frame.   In put_marker we have put_cursor(wline(iline), 1)
In update_status we have put_cursor(wintop+wlines-1, 1)
In display_d we have

nlines = wlines - wline(ed.dot) # n of lines to end of window

Ot appears wline(...) is line in window, not frame

Lots of uses of wline(...) in edsel but they may be in code that's
not tested in multiple windows.   In pmacs we have:

def restore_cursor_to_window():
    reset_point()
    # point+1 to make put_cursor call consistent with editline move_to_column
    display.put_cursor(edsel.wintop+edsel.wline(ed.dot)-1, el.point + 1)

I think that's right.  I think many of the uses in edsel may be wrong.
It might be best to change wline to compute line *in frame* not *in window*.

For now just change put_marker.  If that works, consider changing wline().

Wow, put_marker is *pervasive* in edsel!

Fix edsel put_marker, C-x r , from edsel import * , pm()

Then C-x 2 

>>> edsel.focus
1
>>> edsel.wkeys
[0]
>>> edsel.windows
{0: {'wintop': 1, 'wlines': 24, 'buftop': 437, 'bufname': 'edsel.py',
'dot': 449}, 1: {'wintop': 13, 'wlines': 12, 'buftop': 97, 'bufname':
'edsel.py', 'dot': 103}}

No , edsel.wkeys is still wrong, should be [0,1]  Grrr...

>>> edsel.wkeys = [0,1]
>>> o1()

Looks right.

>>> edsel.focus
1
>>> edsel.wkeys
[0]
>>> edsel.windows
{0: {'wintop': 1, 'wlines': 24, 'buftop': 91, 'bufname': 'edsel.py', 'dot': 103}}

BUT edsel.focus is wrong.   Let's restart Python session.

>>> edsel.focus
0
>>> edsel.wkeys
[0]
>>> edsel.windows
{0: {'wintop': 1, 'wlines': 20, 'bufname': 'scratch.txt'}}

Why are we still using the old defn of saved windows -- !?
Because initialization in edselinit.py is wrong.  save_window is right.

>>> edsel.save_window(focus)
>>> edsel.windows
{0: {'wintop': 1, 'wlines': 22, 'buftop': 390, 'bufname': 'edsel.py',
'dot': 402}}

That's better.  Now fix edselinit.py and restart Python.

Jonathans-MBP-6:editors jon$ python3 -im pm
edsel.py, 486 lines
>>> edsel.focus
0
>>> edsel.wkeys
[0]
>>> edsel.windows
{0: {'wintop': 1, 'wlines': 20, 'buftop': 1, 'bufname': 'scratch.txt',
'dot': 0}}

>>> edsel.o2()
>>> edsel.focus
0
>>> edsel.wkeys
[0, 1]
>>> edsel.windows
{0: {'wintop': 1, 'wlines': 11, 'buftop': 1, 'bufname': 'edsel.py',
'dot': 1}, 1: {'wintop': 12, 'wlines': 11, 'buftop': 1, 'bufname':
'edsel.py', 'dot': 1}}

Good.

>>> edsel.o1()
>>> edsel.focus
0
>>> edsel.wkeys
[0]
>>> edsel.windows
{0: {'wintop': 1, 'wlines': 22, 'buftop': 1, 'bufname': 'edsel.py', 'dot': 1}}

Ok so far.

>>> edsel.o2()
>>> edsel.focus
0
>>> edsel.wkeys
[0, 1]
>>> edsel.windows
{0: {'wintop': 1, 'wlines': 11, 'buftop': 1, 'bufname': 'edsel.py',
'dot': 1}, 1: {'wintop': 12, 'wlines': 11, 'buftop': 1, 'bufname':
'edsel.py', 'dot': 1}}

Ok - there are markers at first line in both windows.

>>> l()
>>> l()
>>> l()

marker moves in top window, remains same place in bottom window.
Of course - we are only updating one window.

>>> on()
>>> l()
>>> l()
>>> l()
>>> l()
>>> l()
>>> l()

Now marker moves in bottom window.

>>> edsel.focus
1
>>> edsel.wkeys
[0, 1]
>>> edsel.windows
{0: {'wintop': 1, 'wlines': 11, 'buftop': 1, 'bufname': 'edsel.py',
'dot': 4}, 1: {'wintop': 12, 'wlines': 11, 'buftop': 1, 'bufname':
'edsel.py', 'dot': 1}}

dot has updated in windows[1], not yet in windows[2].  But status line
in window 1 says dot is at line 7.

>>> o1()
>>> edsel.focus
1
>>> edsel.wkeys
[0]
>>> edsel.windows
{0: {'wintop': 1, 'wlines': 22, 'buftop': 1, 'bufname': 'edsel.py',
'dot': 7}}

It looks like focus isn't right - but wkeys windows are still the ones
last saved - they are not updated by o1(), isn't that right?
Oh, but wkeys is back down to one element.

>>> sked.dot
7

like in saved window.  Marker is also at line 7 in the one window.

We see edsel o1 sets focus = 0 but focus was not in globals list.
fix now.  BUT we don't need windows in globals list - we call
windows.clear() and save_window.  

Check globals lists in o2 and on also.  In o2, we insert into wkeys
but its mutable, we're not reassigning it.

>>> pm()
Wrote edsel.py, 486 lines
Wrote edsel.py, 486 lines
Reload module edsel
>>> from edsel import *
>>> pm()

Is this sufficient?  Will focus update to 0 after o1() now?

Then C-x 2 C-x 0 C-x 1

? only one window

There are still two windows on the screen

M-x

>>> edsel.focus
1
>>> edsel.wkeys
[0]
>>> edsel.windows
{0: {'wintop': 1, 'wlines': 22, 'buftop': 1, 'bufname': 'edsel.py',
'dot': 7}, 1: {'wintop': 12, 'wlines': 11, 'buftop': 455, 'bufname':
'edsel.py', 'dot': 460}}

So wkeys didn't update.  Maybe

>>> edsel.wkeys = [0, 1]
>>> o1()
>>> edsel.focus
0
>>> edsel.wkeys 
[0]
>>> edsel.windows
{0: {'wintop': 1, 'wlines': 22, 'buftop': 449, 'bufname': 'edsel.py',
'dot': 460}}
            

Maybe o2 does need to say global wkeys.  replace it then

Wrote edsel.py, 486 lines
Reload module edsel
>>> from edsel import *

>>> o2()
>>> edsel.focus
0
>>> edsel.wkeys
[0, 1]
>>> edsel.windows
{0: {'wintop': 1, 'wlines': 11, 'buftop': 418, 'bufname': 'edsel.py',
'dot': 423}, 1: {'wintop': 12, 'wlines': 11, 'buftop': 418, 'bufname':
'edsel.py', 'dot': 423}}

>>> edsel.focus
1
>>> edsel.windows
{0: {'wintop': 1, 'wlines': 11, 'buftop': 418, 'bufname': 'edsel.py',
'dot': 423}, 1: {'wintop': 12, 'wlines': 11, 'buftop': 418, 'bufname':
'edsel.py', 'dot': 423}}
>>> edsel.wkeys
[0, 1]

>>> o1()
>>> edsel.focus
0
>>> edsel.wkeys
[0]
>>> edsel.windows
{0: {'wintop': 1, 'wlines': 22, 'buftop': 412, 'bufname': 'edsel.py',
'dot': 423}}

Yay, that's right.  Now let's pay attention to marker.


>>> o2()
>>> l()
>>> l()
>>> on()
>>> l()

Now we have two windows, last l() moved cursor in lower window 1,
in top window 0 status says line 425 lower window 1 says line 424.

>>> edsel.focus
1
>>> edsel.wkeys
[0, 1]
>>> edsel.windows
{0: {'wintop': 1, 'wlines': 11, 'buftop': 418, 'bufname': 'edsel.py',
'dot': 425}, 1: {'wintop': 12, 'wlines': 11, 'buftop': 418, 'bufname':
'edsel.py', 'dot': 423}}

Right, haven't called save window on lower window 1 yet.

>>> o1()>>> edsel.focus0>>> edsel.wkeys[0]>>> edsel.windows{0: {'wintop': 1, 'wlines': 22, 'buftop': 413, 'bufname': 'edsel.py',
'dot': 424}}

Now saved window shows dot at 424.

Summary: edsel shows marker in both windows, only updates focus window,
even when other window is same buffer.  That's expected.

Jonathans-MBP-6:editors jon$ git commit -am 'edsel: fix wlines() for multiple windows, restore update focus and wkeys in o1, fix global in o1 and o2
> edselinit: add buftop and dot in initial saved window'
[window 61fc483] edsel: fix wlines() for multiple windows, restore update focus and wkeys in o1, fix global in o1 and o2 edselinit: add buftop and dot in initial saved window
 2 files changed, 7 insertions(+), 5 deletions(-)
Jonathans-MBP-6:editors jon$ git push
...

Next: see how the marker behaves in pmacs.  

I think it's fine now in edsel.   All we had to do was fix use of wline.

BUT shouldn't we fold that fix into wline itself?  Try testing some of
the many many uses of wline in edsel for fcns we don't use much anymore
now that we have pmacs.


24 Nov 2023

pmacs - cursor moves to focus window, no marker in other window.
We can easily see where cursor will return in other window by
C-x o  C-x o.  It's like C-x x C-x x to see where mark is.

BUG - we got "? only one window" after C-x 2 and C-x o.  are the C-x
still bound to the old definitions?

>>> edsel.o2
<function o2 at 0x10bd64c10>

>>> edsel.o2
<function o2 at 0x10bd64c10>
>>> dmacs.keymap[key.C_x + '2']
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
NameError: name 'key' is not defined
>>> import key
>>> dmacs.keymap[key.C_x + '2']
<function o2 at 0x10bd2b820>

dmacs is out of date with edsel!

>>> reload(dmacs)
<module 'dmacs' from '/Users/jon/Piety/editors/dmacs.py'>
>>> dmacs.keymap[key.C_x + '2']
<function o2 at 0x10bd65c10>

Oh, that's yet a different o2 - ...bd65... instead of ...bd64...

>>> from dmacs import *

>>> reload(pmacs)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: reload() takes 0 positional arguments but 1 was given
>>> from importlib import reload
>>> reload(pmacs)
<module 'pmacs' from '/Users/jon/Piety/editors/pmacs.py'>

So dmacs must define its own reload - !?  Yes, and it's only 
used in dmacs save_reload.  Rename it to reload_buffer

Wrote dmacs.py, 233 lines
Reload module dmacs
>>> from dmacs import *
>>> del(dmacs.reload)

Then C-x C-r from pmacs, from pmacs import *

Back to 

In pmacs, do we want to put marker in non-focus window?  
Emacs does *not* have a marker in the non-focus window.
So let's leave it out.  We're done with the marker, the
cursor behaves as it should.

Next: resolve wline() issue.  Are uses of wline() we haven't revised yet 
erroneous?


25 Nov 2023

wline() is called in update_below: calcultes wstart from bstart
and in open_line: calls put_cursor(wline(...)

put_marker calls *fixed* wline(

display_change_lines calls update_lines(... wline(...)

display_d has nlines = wlines - wline(ed.dot) which looks wrong for multi win
 dmacs C-w calls edsel.d which calls ed.d with display_d
Test - yes, when C-w and C-y in bottom window, text changes in top window.

display_c, display_j  call put_cursor(wline(...)
edsel.c calls ed.c with display_c
dmacs replace_string calls edsel.c, dmacs M-% calls replace string.
Test - yes, when M-% in bottom window, text changes in top window.

display_input_line calls put_cursor(wline(...) but only at end of buffer

I'm satisfied with teting just C-w and M-% - wline() is wrong, we
know how to fix, we've already fixed it in put_marker.   Back out
change in put_marker and put it in wline instead. 


26 Nov 2023

Test put_marker that uses revised wline in edsel.  IT works - puts cursor
at intended line in both windows - but then it leaves cursor there so 
>>> prompt appears there in window, not at bottom from term window.
BUT now refresh() does not work. - it just clears whole term window and 
puts >>>  at top of term windw - !?   Then repeating refresh() just 
refreshes the focus window, that is, half the frame.  I thought I 
defined a refresh_all (all windows) but grep can't find it.

But it looks like put_marker and thus wline are working.

Next, test pmacs restore_cursor_to_window which calls revised wline.

It's used by many pmacs fcns including kill_region, invoked by C_w.

C-w and C-y work in the top window but not the bottom window.
Bottom window just doesn't update.  Must type C-l to see effect
of C-w or C-y in lower window.

Curiously, C-x C-x  C-x C-x to exchange point and dot do work 
in lower window - it
just calls edsel.display_move_dot which calls put_marker(ed.dot, ...)
which in turn calls put_cursor(wline(.....)

So the problem with C-w and C-y in the window isn't explained by
put_cursor - which apparently works correctly, so does put_marker.

restore_cursor_to_window also called by pmacs.open_line which 
is just typing RET within a line.   Hmn, in lower window it 
seems to put the cursor in the right place but it doesn't display
the suffix of the line - until you type C-l.   

So there is a lot wrong with windowing, still.

Restart python session to confirm we still have problems with C-w C-y
and RET in bottom window.  Yes, it still has the same problems - 

BUT the cursor goes to the right places in the lower window.

RET calls pmacs open_line which calls edsel.update_below.
update_below calls wline and update_lines.

C-l refresh does work in lower window.  pmacs C_l calls dmacs C_l which
calls edsel refresh which calls update_window and update_status.
update_window calls update_lines.  So they all work.  So what's the
problem with C-w C-y and RET?

First, see if we can just fix RET within line in lower window.  see above, 
pmacs.open_line -> edsel.update_below -> edsel.wline, update_lines.
Are we passing the correct wstart to update_lines?  But check whole path.


30 Nov 2023

Starting work on Chromebook instead of Macbook!

(Following lines copied, pasted from MyDrive/notes/chromebook_1.txt,L243 -- L440)First set up Piety development.

jon@penguin:/$ git clone https://github.com/jon-jacky/Piety Piety
fatal: could not create work tree dir 'Piety': Permission denied

-- !?  Oh, we're in /

jon@penguin:~$ git clone https://github.com/jon-jacky/Piety Piety
Cloning into 'Piety'...
remote: Enumerating objects: 8804, done.
remote: Counting objects: 100% (1840/1840), done.
remote: Compressing objects: 100% (606/606), done.
remote: Total 8804 (delta 1304), reused 1767 (delta 1232), pack-reused 6964
Receiving objects: 100% (8804/8804), 1.93 MiB | 5.48 MiB/s, done.
Resolving deltas: 100% (6067/6067), done.

Oh, but we're on the wrong branch.  Fix now.

jon@penguin:~/Piety/editors$ git branch
* master
jon@penguin:~/Piety/editors$ git checkout window
Branch 'window' set up to track remote branch 'window' from 'origin'.
Switched to a new branch 'window'

Now it looks right.

Leave desk for about 20 minutes, return to find Chromebook screen dark.
Typing keys does not revive it.  Tapping power key in urc briefly does
revive it, showing previous contents - it did not reboot.

WD disk light is blinking continually - !?

Prepare to get Python.  First, on advice of Set up Linux on your
Chromebook page - bookmarked:

jon@penguin:~$ sudo apt-get update && sudo apt-get dist-upgrade
... several hundred lines ...

Try advice in https://www.makeuseof.com/install-python-ubuntu/

jon@penguin:~$ sudo apt install python3
Reading package lists... Done
Building dependency tree... Done
Reading state information... Done
python3 is already the newest version (3.9.2-3).
0 upgraded, 0 newly installed, 0 to remove and 0 not upgraded.

Oh, the command is python3 not python!

jon@penguin:~$ which python3
/usr/bin/python3

So we should be ready to go.  First set up the paths:

jon@penguin:~/Piety/bin$ . paths
jon@penguin:~/Piety/bin$ echo $PIETY
/home/jon/Piety
jon@penguin:~/Piety/bin$ echo $PATH
/home/jon/Piety/bin:/usr/local/bin:/usr/bin:/bin:/usr/local/games:/usr/games
jon@penguin:~/Piety/bin$ echo $PYTHONPATH
/home/jon/Piety/util:/home/jon/Piety/unix:/home/jon/Piety/vt_terminal:/home/jon/Piety/shells:/home/jon/Piety/editors:
jon@penguin:~/Piety/bin$ pwd
/home/jon/Piety/bin

Now start pmacs.  If this works, I'll be astonished.

jon@penguin:~/Piety/editors$ python3 -im pm
...
  File "/home/jon/Piety/editors/sked.py", line 24, in <module>
    exec(open(EDPATH + 'skedinit.py').read())
FileNotFoundError: [Errno 2] No such file or directory: '/Users/jon/Piety/editors/skedinit.py'

But edsel.py contains:

EDPATH = '/Users/jon/Piety/editors/' # FIXME? assign via env var or cmd line?

This is wrong on Linux because we're in /home/jon not /Users/jon
See L305 above.

The (temporary) fix for this is to get rid of EDPATH and
replace exec(open...) with from edselinit import *
which we already have in edsel.py

BUT we don't have an editor -- except vim!  Can we figure that out?

jon@penguin:~/Piety/editors$ vim sked.py
... esc i to get into insert mode
... replace exec(open(...)) with from skedinit ...
... esc :wq to write out file and exit.
jon@penguin:~/Piety/editors$ git diff sked.py
...
-    exec(open(EDPATH + 'skedinit.py').read())
+    from skedinit import 

Oh, but we also have to delete the EDPATH line.  Done.

Ditto in dmacs, editline, and pmacs.  Done. 

jon@penguin:~/Piety/editors$ python3 -im pm
...
  File "/home/jon/Piety/editors/dmacsinit.py", line 7, in <module>
    promptline = edsel.flines+1 # line after end of edsel frame
NameError: name 'edsel' is not defined

Right, because now we are importing edselinit not just exec'ing it 
in the context of edsel.  So we have to import edsel in dmacsinit now.
Also in pmacsinit.'

jon@penguin:~/Piety/editors$ python3 -im pm
...
  File "/home/jon/Piety/editors/edsel.py", line 10, in <module>
    import terminal_util, display
ModuleNotFoundError: No module named 'terminal_util'

But

jon@penguin:~/Piety/editors$ ls ../unix
__pycache__  README.md  terminal.py  terminal_util.py

Is there an error in the PATH?

jon@penguin:~/Piety/editors$ echo $PYTHONPATH

Nothing!  I'm in a different terminal window and didn't run paths!

jon@penguin:~/Piety/editors$ . ../bin/paths 
jon@penguin:~/Piety/editors$ echo $PYTHONPATH
/home/jon/Piety/util:/home/jon/Piety/unix:/home/jon/Piety/vt_terminal:/home/jon/Piety/shells:/home/jon/Piety/editors:

jon@penguin:~/Piety/editors$ python3 -im pm
...

Finally it works -- sort of.   Window appears.  Status line is 
almost illegible because background bar is very black and letters
are very faint gray.  This might just be a feature of the theme or
terminal settings.

C-x C-f to read a file works.  Read edsel.py and README.md.
C-x C-b lists buffers.  C-x b switches buffer. 
M-x goes to Python REPL and pm() resumes editing.

BUT C-n doesn't go to next line, it opens a new terminal window.
And C-v doesn't page down, it pastes into the buffer.

So the Term app is still interpreting the Chromebook keyboard 
shortcuts.  

Maybe we can run a Linux terminal?  

jon@penguin:~/Piety/editors$ ls /bin/*term*
/bin/garcon-terminal-handler  /bin/setterm  /bin/x-terminal-emulator

Oh dear, xterm has to run under X, duh.

This might be a show stopper.  Can we run X?  There are X programs in /bin.

Hey, wasn't there an setting to turn on/off keyboard shortcuts in terminal?
Yes, terminal settings > Keyboard & mouse - turn *everything* off.

Now C-n and C-v work!   Piety is working on Chromebook Linux --
the first time it has run on any computer besides my old Mac! 

...$ git commit -am ...

Author identity unknown

** Please tell me who you are 

...$ git config --global user.name jon-jacky

ditto user.email "..."

BUT then ... support for password authentication was removed ...

Yes, we've seen this before.  Search email for github,
find Sep 5 email with link.

Log into github - says this token has no expiration date.  Try to 
find use of token in notes.txt

Find token 31 Jan 2023, L188

 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

 Can't paste into terminal window because I disabled it
 Re-enable C-v paste - but it still doesn't work.  
 Maybe that code has expired.

That's enough for today - try again tomorrow.

Nah, regenerate token now:

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

It worked!  Look at github, committed files are there.

A good day's work!

(end of excerpt from My Drive/notes/chromebook_1.txt, L243 -- 440)


 1 Dec 2023

Move notes.txt and other.txt from ~/notes/piety to ~/Piety/doc 
so we can edit them on the Chromebook under version control, without
having to load the whole notes repo onto the Chromebook.

Jonathans-MBP-7:piety jon$ cp -i notes.txt other.txt ~/Piety/doc

Now add, commit, and push:

Jonathans-MBP-7:doc jon$ git add notes.txt other.txt

Jonathans-MBP-7:doc jon$ git commit -am 'add notes.txt, other.txt - copied from notes/piety'
[window a6a47c5] add notes.txt, other.txt - copied from notes/piety
 2 files changed, 32104 insertions(+)
 create mode 100644 doc/notes.txt
 create mode 100644 doc/other.txt

Now spend about a half hour fighting with git:

Jonathans-MBP-7:doc jon$ git push
remote: Invalid username or password.
fatal: Authentication failed for 'https://github.com/jon-jacky/Piety/'

- !?

Last night from Chromebook we had to generate and use new
'persill_cmds = (kill_word, kill_line, discard_line) # cmds that update killed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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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onal authentication token' to push.  It was

  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

Jonathans-MBP-7:doc jon$ git push
Username for 'https://github.com': jon-jacky
Password for 'https://jon-jacky@github.com': (paste in PAT, it didn't echo)

Then a long wait ... a minute or two ...

fatal: unable to access 'https://github.com/jon-jacky/Piety/': Failed to connect to github.com port 443: Operation timed out

Jonathans-MBP-7:doc jon$ git push

long wait ...

fatal: unable to access 'https://github.com/jon-jacky/Piety/': Could not resolve host: github.com

-- !!??

Are we still connected to net?

Browser can't connect to github from link to Piety on my home page.
It can connect to HN.  Is this a problem just with github?

A few minutes later, try again to connect browser to github. 
This time it works.  Try push again:

Jonathans-MBP-7:doc jon$ git push
Username for 'https://github.com': jon-jacky
Password for 'https://jon-jacky@github.com': (paste in PAT)
To https://github.com/jon-jacky/Piety
 ! [rejected]        window -> window (fetch first)
error: failed to push some refs to 'https://github.com/jon-jacky/Piety'
hint: Updates were rejected because the remote contains work that you do
hint: not have locally. This is usually caused by another repository pushing
hint: to the same ref. You may want to first integrate the remote changes
hint: (e.g., 'git pull ...') before pushing again.
hint: See the 'Note about fast-forwards' in 'git push --help' for details.

Jonathans-MBP-7:doc jon$ git push https://github.com/jon-jacky/Piety  window
To https://github.com/jon-jacky/Piety
 ! [rejected]        window -> window (fetch first)
error: failed to push some refs to 'https://github.com/jon-jacky/Piety'
hint: Updates were rejected because the remote contains work that you do
hint: not have locally. This is usually caused by another repository pushing
hint: to the same ref. You may want to first integrate the remote changes
hint: (e.g., 'git pull ...') before pushing again.

Jonathans-MBP-7:doc jon$ git pull
remote: Enumerating objects: 9, done.
remote: Counting objects: 100% (9/9), done.
remote: Total 9 (delta 8), reused 9 (delta 8), pack-reused 0
Unpacking objects: 100% (9/9), done.
From https://github.com/jon-jacky/Piety
   642ec83..cb22c50  window     -> origin/window
There is no tracking information for the current branch.
Please specify which branch you want to merge with.
See git-pull(1) for details

Jonathans-MBP-7:doc jon$ git pull origin window
From https://github.com/jon-jacky/Piety
 * branch            window     -> FETCH_HEAD
error: There was a problem with the editor 'vi'.
Not committing merge; use 'git commit' to complete the merge.
Jonathans-MBP-7:doc jon$ git commit
[window 5ad6525] Merge branch 'window' of https://github.com/jon-jacky/Piety into window

Jonathans-MBP-7:doc jon$ git push origin window
Counting objects: 7, done.
Delta compression using up to 4 threads.
Compressing objects: 100% (7/7), done.
Writing objects: 100% (7/7), 359.11 KiB | 0 bytes/s, done.
Total 7 (delta 3), reused 0 (delta 0)
remote: Resolving deltas: 100% (3/3), completed with 2 local objects.
remote: To https://github.com/jon-jacky/Piety
   cb22c50..5ad6525  window -> window

Finally!  Are the new files at github?   Yes!

(Following lines copied from My Drive/notes/chromebook_1.txt, starting L444
- L482)

On the Mac, copy ~/notes/piety/notes.txt and other.txt to
 ~/Piety/doc, add, commit push.   Then pull on Chromebook

jon@penguin:~/Piety/doc$ git pull
hint: Pulling without specifying how to reconcile divergent branches is
hint: discouraged. You can squelch this message by running one of the following
hint: commands sometime before your next pull:
hint: 
hint:   git config pull.rebase false  # merge (the default strategy)
hint:   git config pull.rebase true   # rebase
hint:   git config pull.ff only       # fast-forward only
hint: 
hint: You can replace "git config" with "git config --global" to set a default
hint: preference for all repositories. You can also pass --rebase, --no-rebase,
hint: or --ff-only on the command line to override the configured default per
hint: invocation.
remote: Enumerating objects: 11, done.
remote: Counting objects: 100% (11/11), done.
remote: Compressing objects: 100% (5/5), done.
remote: Total 11 (delta 6), reused 11 (delta 6), pack-reused 0
Unpacking objects: 100% (11/11), 360.77 KiB | 2.01 MiB/s, done.
From https://github.com/jon-jacky/Piety
   cb22c50..76ec644  window     -> origin/window
Updating cb22c50..76ec644
Fast-forward
 doc/notes.txt | 18678 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 doc/other.txt | 13530 ++++++++++++++++++++++++++++++++++++++++
 2 files changed, 32208 insertions(+)
 create mode 100644 doc/notes.txt
 create mode 100644 doc/other.txt
jon@penguin:~/Piety/doc$ ls
analogies.md         language.md  other.md       python3.md  term.txt
baremachine.md       modules.md   other.txt      README.md   utilities.md
gracle_excerpts.txt  notes.txt    precursors.md  term.md

So we got the new files.  What about the contents?

jon@penguin:~/Piety/doc$ tail notes.txt
... contents as expected ...

(end of excerpts from My Drive/notes/chromebook_1.txt L444 -- 482)


 4 Dec 2023

Now we can get back to programming Piety itself - we're trying to 
fix those windows.   See 26 Nov above, L18571:

update_window calls update_lines.  So they all work.  So what's the
problem with C-w C-y and RET?

BUG - C-y doesn't work because we keep getting back into inline mode.
When sked.killed holds text, we should not be in inline mode.
Workaround: M-x then pmacs.inline = False then C-y.  

Back to lower window problem. Recall this from L18571:

"First, see if we can just fix RET within line in lower window.  see above, 
pmacs.open_line -> edsel.update_below -> edsel.wline, update_lines.
Are we passing the correct wstart to update_lines?  But check whole path."

Also DEL at start of line to join lines doesn't work in lower window.

After these lower window problems C-l refresh does update window
correctly.

 4 Dec 2023

Let's fix bug with sked.inline first. 

grep shows inline is only assigned and used in pmacs.  
It is only assigned in four statements.


    # Lone kill line or first kill line in a series is inline ...
   if dmacs.prev_cmd != kill_line:
        inline = True
    # ... except begin multiline mode when kill empty line of only \n
    if ed.buffer[ed.dot] == '\n':
        inline = False # Enter multiline mode


def kill_region(keycode):
    global inline
    inline = False


def pm():
      ...
            elif k in el.printing_chars or k in el.keymap:
                ed.buffer[ed.dot] = el.runcmd(k, ed.buffer[ed.dot])
                inline = True # editing inline, kill and yank word(s) in line

I think the problem is this last one - typing *any* printing character
or line editing control code returns to inline.   Maybe only typing C-k
inline should return to inline mode.   Or just C-k and the delete word
code M-d and the delete segment code C-u.  In pmacs.py:

-                inline = True # editing inline, kill and yank word(s) in line
+                if k in (key.M_d, key.C_u): # M_d kill_word, C_u discard line 
+                    inline = True

I think that should do it.

C-x C-r write pmacs, reload pmacs then >>> from pmacs ioprt pm
No explicit tets, let's just see if C-k then C-y work as intended
in the future.

Now fix RET.  key.cr: open_line.  Compare code in this trace:

pmacs.open_line -> edsel.update_below -> edsel.wline, update_lines.

which doesn't work, to code in refresh(), which does.

pmacs.refresh -> dmacs.runcmd(key.C_l) -> edsel.refresh -> edsel.erase_lines
 -> edsel.update_window


 7 Dec 2023

Briefly test C-k M-d C-u  and C-y.   Try repeated C-k then C-y 
to cut and  paste, then M-d C-k inline then C-y.  C-w then C-y, 
then more inline C-u M-d.

BUG - C-y inline includes old inline cut.   When do we clear
editline.killed ?   After inline C-y - but we may want to 
repeat paste.   I think we want to do it wheb new C-k C-u or M-d
after C-y.

Do we really have to keep track of 'after C-y'.  Wouldn't it be acceptable
to clear editline.killed on any C-k C-u M-d that does not follow another
C-k C-u M-d? 

Oh, we already tried to code that -- for example editline.kill_word has:

        killed = (killed + killed_word if prev_cmd in kill_cmds
                       else killed_word)

where

kill_cmds = (kill_word, kill_line, discard_line) # cmds that update killed

BUT I think the problem might be the prev_cmd is local to editline
so it can't see cmds that aren't editline commands.

Right, there is a prev_cmd in editlineinit.py which is different
from the prev_cmd in dmacsinit.py

Hmn - these two distinct prev_cmd invalidate all the prev_cmd code, right?
Fix it in pmacs?  In editline branch in pm, before calling, first assign 
editline.prev_cmd = dmacs.prev_cmd and then after editline fcn returns,
dmacs.prev_cmd = editline.prev_cmd.

We already assign dmacs.prev_cmd after el.runcmd returns.  
So just add the complementary assignment before we call el.runcmd.

We got a crash where echoing in terminal is turned off - 
even after exit and restart python, terminal does not echo
typed characters at shell or in Python REPL or in dmacs editor -- !!??
So close that Term and open another.

Now we have in pmacs.py pm:

             elif k in el.printing_chars or k in el.keymap:
                 ed.buffer[ed.dot] = el.runcmd(k, ed.buffer[ed.dot])
-                inline = True # editing inline, kill and yank word(s) in line
+                el.prev_cmd = dmacs.prev_cmd
+                if k in (key.M_d, key.C_u): # M_d kill_word, C_u discard line 
+                    inline = True
                 dmacs.prev_cmd = el.prev_cmd

Now I suppose I should try some cut/paste.  

C-u then C-y, also C-k then C-y both work inline.  Display updates
and editline.killed has proper contents.

BUT M-d kill word doesn't update display. C-l refresh does update
display as expected, so buffer was updated currectly.
Also, only *last* cut word appears in editline.killed.

Let's see if we can get display to update first.  kill_word has line:

        display.delete_nchars(point - (m.start()+1))

where display has 

def delete_char():
    'Delete character under the cursor'
    putstr(dch % 1)

def delete_nchars(n):
    'Delete n characters under, then after the cursor'
    putstr(dch % n)    

We try delete_char, it updates display .   So are we not handling n right?

C_y after M_d in inline mode works, updates display with killed word.

Is it possible the CB Term doesn't handle delete_nchars correctly?
We could commit this code then pull on the mac ans see if it works there.

First try editline by itself on CB, just run test fcn el().
That works - M_d deletes word updates on display as expected.

So code pmacs kill_word *after* el.kill_line must mess it up - !?
But pmacs just has   

            elif k in el.printing_chars or k in el.keymap:
                ed.buffer[ed.dot] = el.runcmd(k, ed.buffer[ed.dot])
                el.prev_cmd = dmacs.prev_cmd
                if k in (key.M_d, key.C_u): # M_d kill_word, C_u discard line 
                    inline = True
                dmacs.prev_cmd = el.prev_cmd

That's the whole case - it doesn't do anything with the display
after that.   Loop in editline is:

  while True:
        c = terminal.getchar()
        k = keyseq.keyseq(c)
        if k: # keyseq returns '' if key sequence is not complete
            if k == key.M_x:
                break
            else:
                line = runcmd(k, line)

Oh, where do we make multiple calls to keyseq?   Oh, it should just
keep looping around.

See if M_f and M_b work - but we know they do.  They work in pmacs, yes.

How can M_d display update work in editline el() but not in pmacs pm() - ?
In both cases we are calling editline.kill_word which calls

What if we back out changes to pmacs adn try again?
on@penguin:~/Piety/editors$ mv pmacs.py pmacs_prevcmd_inline.py
jon@penguin:~/Piety/editors$ git checkout pmacs.py
Updated 1 path from the index
jon@penguin:~/Piety/editors$ diff pmacs.py pmacs_prevcmd_inline.py
204c204,206
<                 inline = True # editing inline, kill and yank word(s) in line
---
>                 el.prev_cmd = dmacs.prev_cmd
>                 if k in (key.M_d, key.C_u): # M_d kill_word, C_u discard line 
>                     inline = True

Then kill pmacs.py buffer, then C-x C-f pmacs.py  C-x C-r reload then 
from pmacs import pm.

No, M_d doesn't display there either.  Try restarting python.
M_d display still doesn't work.

Try it on Mac downstairs?

I am inclined to defer working on this problem and return to the 
lower window display update problems.


 8 Dec 2023

Tried repeated M_d on the old Mac downstairs.   It worked - the
display updated as expected and repeated M_d were appended to
editline.killed so C_y pasted them all back in.

This was running the same version of pmacs.py that we tried 
on the CB last night when we reverted.

Have we found something that works on Mac but not CB?

Repeated test with editline el() - now it *doesn't* work, 
display does not updael() after M_d, on CB just like in pmacs.
BUT I recall testing it last night and it worked -- !?
Was I mestaken?

This morning, editline el() definitely behaves like pmacs -
M_d does not update on display until you type C_l refresh -
C_y does paste.  And, repeated M_d to append to killed buffer.
So the M_d not updating display til C_l does occur on CB in 
both pmacs and editline el().

What does editline el() do on the Mac?

It behaves as intended - M_d updates display and repeated M_d append
to killed buffer.  Here on CB M_d does not update display (today - but
last night I recalled it did)

Both Mac and CB are running the same version of editline, 
with 'from editline import *' instead of exec(open... editline.py....)

Both Mac and CB have a __pycache__ directory with all the 
<name>.cpython-39.pyc

Is this a real system difference?  It seems we are running identical
source code.   Maybe the CB Term app doesn't handle the delete_nchars
escape sequence properly?   I'm tempted to recode it as multiple
calls to delete_char escape sequence, see if that works.

Once again, ran editline el() on Mac -- it works, M_d updates display.
Onec again, ran it on CB -- M_d doesn't update display - BUT 
consecutive M_d to append to killed buffer - revealed after C_l refresh
and C_y yank.

It's the *same code*!  Also, Piety/editors vt_terminal and unix all
contain __pycache__ dirs with .pyc files.  There are no obvious 
environmental differences.

Can it be that the CB Term app doesn't handle the delete n chars esc
sequence?   I don't see how we can test this -- the only way we have
to access Linux and Python is through the Term app.

The *only* test is to rewrite kill_word to use repeated delete_char.

What about my memory and notes that in editline el() on CB, M_d did
update the display?   What changed?  We restarted the Python 
sessions in a new Term?  That would recompile editline again?
BUT we never changed the code!

In editline, we did replace exec(open...) with from ... import *.
Did we make that change on Mac?

Yes, we did.  git log shows change on Nov 30, editline.py has date
1 Dec and editline.cpython-39.pyc has date Dec 8.

Mac is running Python 3.9.0 and CB is running 3.9.2

Visually inspect editline editlineinit and display on CB and Mac.
Also compare wc char, word, linecounts.  They are the same.

Hey, I just noticed in kill_word

      display.delete_nchars(point - (m.start()+1))

But all the other lines imply m.start() is larger than point.
Have I got this - expr backward?  And mac term ignores sign on 
delete_nchars arg but CB Term does not?  

Try reversing it.

-        display.delete_nchars(point - (m.start()+1))
+        # display.delete_nchars(point - (m.start()+1)) # FIXME? args reversed?
+        # display.delete_nchars((m.start()+1) - point) -        display.delete_nchars(point - (m.start()+1))

Has no effect.  M_d still does not update display, C_d does update display.

ls -l shows we have new editline.py and new editline.cpython-39.pyc.

Oh wait, we commented out *both* lines!  FIx now.

YAY!  Now it works!   It looks like there is a difference in Mac terminal
and CB Term - Mac terminal tolerates negative arg in this escape sequence - 
it must treat arg as unsigned - but CB Term does not.

Go downstairs to look at Mac and confirm that the Mac code also
has the same arg order: point - (m.start()+1) - I didn't somehow
reverse it just on the CB.  The Mac really does handle this code
differently than the CB.

Try pmacs.  

Wrote editline.py, 249 lines
Reload module editline
>>> from pmacs import pm
>>> pm()
README_2.md, 423 lines

Then edit in README_2.md.   YAY!  Now M_d updates display here too!

BUT consecutive M_d do not append to editline killed buffer. killed
only contains the last word killed.   This must be a problem with 
pmacs code that wraps editline.runcmd.

I think I see the problem.  It's the old key vs. command issue again.
editline.py has cmd = keymap[keycode]

kill_word etc. has

       killed = (killed + killed_segment if prev_cmd in kill_cmds
                       else killed_segment)

where

kill_cmds = (kill_word, kill_line, discard_line) # cmds that update killed

Oh - that should be ok.  Does editline el() append consecutive killed words?
Yes!  BUT pmacs does not.   So problem must be in pmacs wrapper of el.runcmd

In pm(), it looks like assigning el.prev_cmd = dmacs.prev_cmd comes
*after* runcmd! Shouldn't it come *before* runcmd?   Try that.

It works!

BUT what about calls to el.runcmd in pmacs fcns other than pm?  
There are several.   Shouldn't they also be wrapped in assignments
from/to dmacs.prev_cmd?     I think so.

Ok, for now we just assign dmacs.prev_cmd = cmd in pmacs.runcmd.
BUT in some cases that should really be el.runcmd, because we 
pass it back in to el.runcmd.

The right way to do this is to define el_runcmd which just wraps
el.runcmd in prev_cmd assignments.   BUT then we can't have 
all purpose pmacs runcmd that assigns prev_cmd, because pmacs
fcns that call el_runcmd will already assign prev_cmd.
  

on@penguin:~/Piety/editors$ git commit -am 'editline: bug fix, kill_word displa
y.delete_nchars correct arg order
> pmacs: in pm editline case, assign inline = True only for editline kill_word, discard_line
> also assign el.prev_cmd = dmacs.prev_cmd before calling el.runcmd()
> FIXME?  Be careful about assigning dmacs. and el.prev_cmd elsewhere in pmacs'
[window ea187e4] editline: bug fix, kill_word display.delete_nchars correct arg order pmacs: in pm editline case, assign inline = True only for editline kill_word, discard_line also assign el.prev_cmd = dmacs.prev_cmd before calling el.runcmd() FIXME?  Be careful about assigning dmacs. and el.prev_cmd elsewhere in pmacs
 4 files changed, 742 insertions(+), 2 deletions(-)
jon@penguin:~/Piety/editors$ git push
Username for 'https://github.com': jon-jacky
Password for 'https://jon-jacky@github.com': 

Tried pasting in token from L18807  above:

  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

remote: Invalid username or password.
fatal: Authentication failed for 'https://github.com/jon-jacky/Piety/'

Not sure if the token is no good or my copy/paste didn't work.
Hard to tell because pw does not echo.  I may have got leading
or trailing spaces in there.   Try again.   And again.
No, they all fail.  I think I need new token.  

See L496 in chromebook_1.txt.  Apparently the token above was indeed
revoked, I have to generate yet another.  Grrr... It's late, do it tomorrow.

I think we do have to wrap all the pmacs calls to el.runcmd with
prev_cmd assignments.  What a nuisance, because then assignments
to prev_cmd from pmacs itself all need special-case handling, depending
on whether those fcns call el.runcmd.

This is all just for C_k, C_u, and M_d, right?   I think C_k
kill_line is the complicated one because there are *different* kill_line
in pmacs and editline.  Does this create problems when prev_cmd  is
kill_line?  Must we be careful to test which one it is?

What a complicated mess.  This is a consequence of having a line-oriented
editor underneath.

We must be careful when editing to use C_k correctly.  When we want
inline C_k - we *must not* do second C_k to delete empty line.
When we want whole line C_k, we *must* do second C_k to delete empty line.
This is what we must do when we want to cut/paste even a *single* whole line.


10 Dec 2023

Generate new token by clicking on button on mail msg from Dec 1 
email from github:

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

Try again:

jon@penguin:~/Piety/editors$ git push
Username for 'https://github.com': jon-jacky
Password for 'https://jon-jacky@github.com': 

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(Paste in token shown above)

Enumerating objects: 15, done.
Counting objects: 100% (15/15), done.
Delta compression using up to 8 threads
Compressing objects: 100% (8/8), done.
Writing objects: 100% (8/8), 11.03 KiB | 114.00 KiB/s, done.
Total 8 (delta 7), reused 0 (delta 0), pack-reused 0
remote: Resolving deltas: 100% (7/7), completed with 7 local objects.
To https://github.com/jon-jacky/Piety
   76ec644..ea187e4  window -> window

Then, after git status we see ../doc/notes.txt is not committed,
commit and push, but then we get prompted again for username and pw,
Again, try to paste in same token, but it doesn't work.
After a few tries, we do get it to work.  Is github going to demand 
this for *every* push - !?  

jon@penguin:~/Piety/editors$ git commit -am 'pmacs: assign prev_cmd in runcmd'
[window 465759c] pmacs: assign prev_cmd in runcmd
 1 file changed, 2 insertions(+), 4 deletions(-)

jon@penguin:~/Piety/editors$ git push
Username for 'https://github.com': jon-jacky
Password for 'https://jon-jacky@github.com': 

Paste in token again.
Yes, apparently it is demanding token on every push.   Grrr....

Enumerating objects: 7, done.
Counting objects: 100% (7/7), done.
Delta compression using up to 8 threads
Compressing objects: 100% (4/4), done.
Writing objects: 100% (4/4), 468 bytes | 117.00 KiB/s, done.
Total 4 (delta 3), reused 0 (delta 0), pack-reused 0
remote: Resolving deltas: 100% (3/3), completed with 3 local objects.
To https://github.com/jon-jacky/Piety
   11db2ee..465759c  window -> window

So token worked this time -- but what a nuisance!

Wrote pmacs.py, 214 lines
Reload module pmacs
>>> from pmacs import pm
>>> pm()

Now I suppose we should try some tests that use prev_cmd.

In particular, test pmacs, try some C_k and make sure - 
1. One inline C_k then C_y - cut segment is pasted in place
2. Consecutive C_k then C_y - all lines get pasted

Also test editline, try:
1. consecutive M_d M_d then C_y
2. C_u then M_d then C_y
3. M_d then C_k then C_y

In Term with code in pmacs, characters are not echoing - not
in C-x b prompt - which is just Python input() - and not in
pmacs editing window, which is editline.   So it is some
problem with Term, not our code.  We saw this before - how
did we get out?

L19045 - we closed that Term and opened another.

This time - click little >_ icon in Term ULC to get menu -
there is no 'Reset terminal' option but just clicking Penguin
I do reset the terminal, including killing the running 
program - I'm back to $ shell prompt in /home/jon, $PYTHONPATH
is empty again - so that's like killing the term and opening
a new one.  Run bin/paths and then start session with python3 -im pm.

Now run those tests above.  C_k 1. and 2. work.  
editline 1. 2. 3. all work.   So the M_d display update is
working, inline and prev_cmd are apparently working.

So the simple (trivial) tests pass.  Keep watching for errors in real
use: C_y pastes from wrong killed buffer, or  pasted killed buffer
contains extra content (it was not reset when it should have been).
 
Return to fixing display updates in non-focus window.

At L18954:
---------------------------
Back to lower window problem. Recall this from L18571:

"First, see if we can just fix RET within line in lower window.  see above, 
pmacs.open_line -> edsel.update_below -> edsel.wline, update_lines.
Are we passing the correct wstart to update_lines?  But check whole path."

Also DEL at start of line to join lines doesn't work in lower window.

After these lower window problems C-l refresh does update window
correctly.
 ----------------------------- 

At L18536:
-------------------------------
C-w and C-y work in the top window but not the bottom window.
Bottom window just doesn't update.  Must type C-l to see effect
of C-w or C-y in lower window.

Curiously, C-x C-x  C-x C-x to exchange point and dot do work 
in lower window - it
just calls edsel.display_move_dot which calls put_marker(ed.dot, ...)
which in turn calls put_cursor(wline(.....)

So the problem with C-w and C-y in the window isn't explained by
put_cursor - which apparently works correctly, so does put_marker.

restore_cursor_to_window also called by pmacs.open_line which 
is just typing RET within a line.   Hmn, in lower window it 
seems to put the cursor in the right place but it doesn't display
the suffix of the line - until you type C-l.   
----------------------- 

L18996:
-----------------------
Now fix RET.  key.cr: open_line.  Compare code in this trace:

pmacs.open_line -> edsel.update_below -> edsel.wline, update_lines.

which doesn't work, to code in refresh(), which does.

pmacs.refresh -> dmacs.runcmd(key.C_l) -> edsel.refresh -> edsel.erase_lines
 -> edsel.update_window
------------------------

Easiest to see problem after RET in the middle of a line in the lower window.

So, the summary seems to be edsel.update_below does not work in lower
window, but edsel.refresh does.  refresh mostly calls update_window
update_window just calls update_lines(buftop, wintop, wlines-1)
update_lines just puts cursor at wintop and puts lines starting at buftop.
It works because it starts by putting the cursor at wintop, which
is correct for each window including lower window.

update_below is just:

def update_below(bstart, offset=0):
    wstart = wline(bstart) + offset
    nlines = wlines - wstart
    update_lines(bstart, wstart, nlines)

where 

def wline(iline):
    wiline = wintop + (iline - buftop)
    return wiline if wiline >=1 else 1

1.  Do I have bstart, wstart in the right order in call to update_lines?
Yes, I think so.

2.  Do I have correct order in wlines - wstart ?
I must - because it works in top window.  There must be an offset needed.
I think wstart is relative to frame but wlines is relative to window.
Look again at update_status: put_cursor(wintop+wlines-1)
instead of just wlines - wstart, try (wintop+wlines-1) - wstart
When wintop is 1, this reduces to the earlier code.

Yes, now RET works in lower window.   So do C_w, repeated C_k and C_y.
That was much easier than getting M_d to display!

jon@penguin:~/Piety/editors$ git commit -am 'edsel.py: fix nlines in update_below to work in lower window
> pmacs.py: revise comments
> doc/notes.txt: recent updates'
[window 0fb59d2] edsel.py: fix nlines in update_below to work in lower window pmacs.py: revise comments doc/notes.txt: recent updates
 3 files changed, 185 insertions(+), 2 deletions(-)

jon@penguin:~/Piety/editors$ git push
Username for 'https://github.com': jon-jacky
Password for 'https://jon-jacky@github.com': 

(paste in token above)

Enumerating objects: 13, done.
Counting objects: 100% (13/13), done.
Delta compression using up to 8 threads
Compressing objects: 100% (7/7), done.
Writing objects: 100% (7/7), 2.92 KiB | 44.00 KiB/s, done.
Total 7 (delta 6), reused 0 (delta 0), pack-reused 0
remote: Resolving deltas: 100% (6/6), completed with 6 local objects.
To https://github.com/jon-jacky/Piety
   465759c..0fb59d2  window -> window

Confirm latest versions are at github.
Haven't done that yet - got email saying my personal access token appeared
in a commit, has been revoked, I must generate a new one.   Bah!

Apparently this comes about when I try to paste token into password: prompt
but fail.

It might be worth contacting github support about this.

Back to edsel.  We used that idiom twice, in update_status put_cursor call
and in update_below nlines = rhs.   Should we write a functin for this?
Have we already -- is it wlines?  The pertinent code is:

def update_status():
    display.put_cursor(wintop+wlines-1, 1) # window status line
    ...

def update_below(bstart, offset=0):
    wstart = wline(bstart) + offset
    nlines = (wintop + wlines - 1) - wstart
    update_lines(bstart, wstart, nlines)  

Then wline is:

def wline(iline):
    wiline = wintop + (iline - buftop)
    ...

No, it's not quite the same as wline, because buftop doesn't appear.
what if we consider wlines -> iline ?  No, it doesn't quite work,
because iline is the index of the line in the buffer and 
wlines is number of lines in the window - which doesn't depend on the buffer.
In our formula, we're just adjusting an offset for wintop.
If we could think of a good name for this, that would make a fcn worthwhile.wl
wline translates line in buffer to line in frame.
w???? translates line in window to line in frame.

No, this should be an argument-less fcn that returns the 
whole wintop+wlines-1
 
call it wbottom() analogous to wtop.   BUT then the constant wlines 
should be renamed wsize so as not to confuse it with wline()  


11 Dec 2023

Rename wlines to wheight not wsize - be specific, if we ever do vertical
window split (unlinkely!) we will also have wwidth. 

grep shows wlines is pervasive!  Also that wheight is much better.

BUG - status line scrolls up one line sometimes when status message
appears at bottom of window.
Oh, but that's only in notes.txt frame, not in code frame.  Maybe this
got fixed in the course of other fixes - code frame is more recent.

Restart notes frame.  Done.

Now, no bogus scrolling.  BUT in code fram, we adjusted window width
with CB Term and now there is bogus scrolling there.  Did adjusting 
Term width cancel scrolling region?

At REPL type win(24).  That calls set_scroll, indeed it fixes bogus
scrolling.  So adjusting Term width in window mgr. cancels scrolling region,
win() restores it.

More window weirdness - in notes frame we got frozen cursor, no echo,
cursor doesn't move.   Had to close Term and open a new one.

Replace wlines with wheight in edsel using c(...) command.
git diff reveals 

-    nlines = min(nlines, wintop+wlines-wstart) # n of lines at end of window
+    nlines = min(nlines, wintop+wheight-wstart) # n of lines at end of window
     nlines = min(nlines, len(ed.buffer)-bstart+1) # n of lines at e.o. buffer

Can't we replace wintop+wheight with wbottom() - do we need +1 there?
Yes, we do need the +1 to make it a strict translation - because
wbottom() returns wintop + wheight - 1.  Also it looks right, like bstart+1:

    nlines = min(nlines, wbottom()-wstart+1) # n of lines at end of window

We use wbottom in three places: update_status, update_below, update_lines.
It's well worth defining it!

Should test this before committing.  Those three fcns are pervasive!
Just interact ad lib to exercise them all -- they all seem to work.

BUG - if you kill a buffer in one window, and it is also displayed
in another window, when you C_o to that window, pmacs crashes:

                             bufname = buffers[bname].get('bufname', 'no
name')
KeyError: 'README_2.md'


13 Dec 2023

Here is a more complete traceback:

File "/home/jon/Piety/editors/edsel.py", line 483, in  restore_window(focus)
File "/home/jon/Piety/editors/edsel.py", line 426, in restore_window
ed.restore_buffer(bufname) # assign global bufname, buffer, dot etc.
File "/home/jon/Piety/editors/sked.py", line 80, in restore_buffer
bufname = buffers[bname].get('bufname', 'no name')       KeyError:
'README_2.md'

Oh, it's not get('bufname', ...) that's failing, it's buffers[bname].

We need a guard 'if bname in buffers...' somewhere - but where?
And what's the 'else' ?

Oh, after the crash, that Term is in the weird no-echo mode.
Reset term then restart pm at $ prompt.

Try to fix by adding line in edsel restore_window

     ...
     bufname = windows[wkey].get('bufname', ed.bufname) # *local* bufname here!
+    # What if bufname is not in buffers?  It may have been killed.
+    # But scratch.txt is always in buffers.
+    bufname = bufname if bufname in ed.     bufname = windows[wkey].get('bufname', ed.bufname) # *local* bufname here!
+    # What if bufname is not in buffers?  It may have been killed.
+    # But scratch.txt is always in buffers.
+    bufname = bufname if bufname in buffers else 'scratch.txt'
     if bufname != ed.bufname:
         ed.prev_bufname = ed.bufname
         ed.restore_buffer(bufname) # assign global bufname, buffer, dot etc.buffers else 'scratch.txt'
     if bufname != ed.bufname:
         ed.prev_bufname = ed.bufname
         ed.restore_buffer(bufname) # assign global bufname, buffer, dot etc.
     ...

BUt then after C_k kill buffer and C_o other window

 reset_point()
                 File "/home/jon/Piety/editors/pmacs.py", line 23, in reset_point
     linelen = len(ed.buffer[ed.dot])
                                     IndexError: list index out of range

This crashes because ed.dot is now 0 and there is no line at that index.
BUT isn't scratch.txt supposed to have one line at index zero: '\n'
Yes, see skedinit.py, confirm in running session:

>>> sked.buffers
{'scratch.txt': {'bufname': 'scratch.txt', 'filename': 'scratch.txt',
'buffer': ['\n'], 'dot': 0, 'saved': True}}

I don't see what went wrong there.  And it's hard to tell because after
every pmacs crash, Term is in no-echo mode.   Is some exception handler
not running?  Is there a reset terminal command I can type blind?
Try tl = pmacs.terminal.set_line_mode() then type tl() - it works!

After crash with same traceback:

>>> sked.dot
23
>>> sked.bufname
'scratch.txt'
>>> sked.buffer
['\n']

sked.dot was not reassigned, even though bufname and buffer where restored

>>> sked.buffers[sked.bufname]
{'bufname': 'scratch.txt', 'filename': 'scratch.txt', 'buffer': ['\n'],
'dot': 0, 'saved': True}

Why wasn't dot restored?  Look at sked.restore_buffer.  It looks like
it does the right thing.  IT does assign dot and default is 0.

dmacs C_x + o just runs edsel.on

pmacs calls dmacs.runcmd but then, restore_cursor_to_window
which calls reset_point with the crashing lineline = ... ed.buffer[ed.dot]...

BUT I don't see any code in that path that reassigns ed.dot after 
restore_buffer assigns it -- !?   Trace through again.
 

14 Dec 2023

Instead of reading the code path once more, maybe try the debugger?
Like we did at on 2 Apr 2023, L5155: import pdb then pdb.run("... fcn call...")
then (Pdb) s to step into fcn.


15 Dec 2023

Split window, delete current buffer in one, then:

 pdb.run("edsel.on()")

Just following along in code as we step through with debugger, we soon
find:

def save_window(wkey):
    """
    Save window items in saved windows at the index wkey.
    wkey is arg so we can save windows other than focus window.
    Save window's buffer also, next window might use a different buffer.
    """
    windows[wkey] = { 'wintop': wintop, 'wheight': wheight, 'buftop': buftop,
                      'bufname': ed.bufname, 'dot': ed.dot } 
    ed.save_buffer() # FIXME? saves current buffer, not buffer for window wkey
                     # BUT wkey is only used in o2 where buffer is the same

Is this a problem?  The FIXME arises because save_buffer does not
have a wkey arg.   

After restore_window(focus) at end of on we get:

(Pdb) ed.buffer
['\n']
(Pdb) ed.dot
1
(Pdb) 

but

(Pdb) ed.buffers['scratch.txt']
{'bufname': 'scratch.txt', 'filename': 'scratch.txt', 'buffer': ['\n'],
'dot': 0, 'saved': True}

even though

(Pdb) ed.bufname
'scratch.txt'

but then we Pdb n to the end of the fcn and we get back to >>> with no crash.

BUT then >>> refresh() does crash with same error about ed.buffer[ed.dot]
index out of range.

I think we have to step through restore_window.

Could we solve this problem with a hack, just initialize scratch.txt
in buffers to ['\n','\n'] with dot = 1 not 0?   That would also fix
weirdness where cursor doesn't apper, or appears in status line of
window above.

git diff skedinit.py:

 # buffer is zero indexed, but we want first line of file to be at index 1
 # so first entry in buffer list is never used - it's always just '\n'
-buffer = ['\n']  # '\n' at index 0 is never used
-dot = 0            # dot, index of current line in buffer
+buffer = ['\n','\n']  # '\n' at index 0 is never used, index 1 is first shown
+dot = 1            # dot, index of current line in buffer

Then after startup

>>> sked.buffers
{'scratch.txt': {'bufname': 'scratch.txt', 'filename': 'scratch.txt',
'buffer': ['\n', '\n'], 'dot': 1, 'saved': True}}

Now run the test again: C-x C-f edsel.py, C-x 2, C-x k, C-x o

That doesn't crash, but scratch.txt doesn't appear in bottom window,
edsel.py just stays there and in status line - until C-l refreshes
window with scratch.txt at line 2.  Does regular C-x o still work?
Yes.   Destination window doesn't update in this case because  normally
it doesn't - contents already there are valid.  This is sort of a weird
case - as long as it doesn't crash, let's just leave it?
No, it's sort of a wart - but let's try fixing it.

NO, doesn't work at all - Now we have 

 
>>> ed.bufname
'scratch.txt'
>>> ed.buffer
['\n', '\n']
>>> ed.dot
492

That's the dot 492 shown in status line of second window, which 
was dot in edsel.py before we killed it.  So somehow ed.dot is
not getting restored, and hack with two-line scratch.txt does
not help.  Revert scratch.txt, refresh() at the end of edsel on fcn.

Let's commit now, even with this error still there.

jon@penguin:~/Piety/editors$ git commit -am 'edselinit, edsel: rename wlines 
  to wheight
> add wbottom function, use in update_lines, update_below, update_status
> pm: define tl function to restore terminal line mode, can use after crash
> NOT FIXED: edsel crashes when you change to window that shows killed buffer.'
[window 2e981ad] edselinit, edsel: rename wlines to wheight add wbottom function, use in update_lines, update_below, update_status pm: define tl function to restore terminal line mode, can use after crash NOT FIXED: edsel crashes when you change to window that shows killed buffer.
 5 files changed, 367 insertions(+), 35 deletions(-)
 
jon@penguin:~/Piety/editors$ git push
Username for 'https://github.com': jon-jacky
Password for 'https://jon-jacky@github.com': 

Tried to paste in old token
 
remote: Invalid username or password.
fatal: Authentication failed for 'https://github.com/jon-jacky/Piety/'  

Tried to paste in old token but of course it didn't work
because it was revoked - see email from github on 12/10.
Generate new jon@penguin:~/home$ # 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token by pressing button on email.

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

Now practice pasting this in terminal window so we don't flub that
and get it revoked again.   Now try git push again.

@penguin:~/Piety/editors$ git push
Username for 'https://github.com': jon-jacky
Password for 'https://jon-jacky@github.com': 
Enumerating objects: 17, done.
Counting objects: 100% (17/17), done.
Delta compression using up to 8 threads
Compressing objects: 100% (9/9), done.
Writing objects: 100% (9/9), 6.08 KiB | 183.00 KiB/s, done.
Total 9 (delta 8), reused 0 (delta 0), pack-reused 0
remote: Resolving deltas: 100% (8/8), completed with 8 local objects.
To https://github.com/jon-jacky/Piety
   0fb59d2..2e981ad  window -> window
 
It apparently worked.  Is latest push at github?   Yes!

Next: merge each ...init.py back into its main module except... branch.

How to test? First merge edselinit into edsel.  Then restart python session
with pm, make sure edsel global vars are initialized.  Then load 
buffers and split window to update edsel vars.  Then C-x C-r to reload
and confirm variables were not re-initialized.

>>> edsel.focus
0
>>> edsel.wkeys
[0]
>>> edsel.windows
{0: {'wintop': 1, 'wheight': 20, 'buftop': 1, 'bufname': 'scratch.txt',
'dot': 0}}

Then update variables:

>>> edsel.focus
1
>>> edsel.wkeys
[0, 1]
>>> edsel.windows
{0: {'wintop': 1, 'wheight': 11, 'buftop': 1, 'bufname': 'sked.py',
'dot': 1}, 
 1: {'wintop': 12, 'wheight': 11, 'buftop': 1, 'bufname':
'edsel.py', 'dot': 1}}

Now reload the module:

>>> pm()
Wrote edsel.py, 530 lines
Reload module edsel

>>> edsel.focus
1
>>> edsel.wkeys
[0, 1]
>>> edsel.windows
{0: {'wintop': 1, 'wheight': 11, 'buftop': 1, 'bufname': 'sked.py',
'dot': 1}, 
 1: {'wintop': 12, 'wheight': 11, 'buftop': 1, 'bufname':
'edsel.py', 'dot': 1}}

It's all still there - as expected.  Now the other modules.  Done.
Now restart session without any ...init.py.   Seems to work.

How to test?  Look at vars in each module, then do some work
that assigns to them, then reload, confrm that vars are still there?

We did edsel already. Next, sked

>>> sked.buffers.keys()
dict_keys(['scratch.txt', 'edsel.py', 'sked.py', 'dmacs.py',
'editline.py', 'pmacs.py'])

Wrote sked.py, 505 lines
Reload module sked   

>>> sked.buffers.keys()
dict_keys(['scratch.txt', 'edsel.py', 'sked.py', 'dmacs.py',
'editline.py', 'pmacs.py'])

Still there.    Now dmacs:

>>> dmacs.prev_cmd
<function switch_buffer at 0x78e7373b80>

Wrote dmacs.py, 234 lines
Reload module dmacs

>>> dmacs.prev_cmd
<function save_reload at 0x78e73780d0>

It's not the same value - in fact it's the reload command itself!
What's important is, it was not re-initialized to None.  Now editline:

>>> editline.killed
'    editlinekilled = str() # saved killed (cut) words, can be restored
with yank (paste)'

Wrote editline.py, 258 lines
Reload module editline\

>>> editline.killed
 '    killed = str() # saved killed (cut) words, can be restored with
yank (paste)'

It's still there.  Now pmacs.  After cut and paste two empty lines:

>>> pmacs.inline 
False

Wrote pmacs.py, 216 lines
Reload module pmacs

>>> pmacs.inline 
False

It's still False.  Initialization in pmacs.py sets it True.
That's the last of the five modules.

Revew with git diff the five *.py, eyeball compare to *init.py at gitnub.

jon@penguin:~/Piety/editors$ ls *init.py
dmacsinit.py  editlineinit.py  edselinit.py  pmacsinit.py  skedinit.py
jon@penguin:~/Piety/editors$ git rm *init.py
rm 'editors/dmacsinit.py'
rm 'editors/editlineinit.py'
rm 'editors/edselinit.py'
rm 'editors/pmacsinit.py'
rm 'editors/skedinit.py'

jon@penguin:~/Piety/editors$ git push
Username for 'https://github.com': jon-jacky 
Password for 'https://jon-jacky@github.com': 
Enumerating objects: 5, done.
Counting objects: 100% (5/5), done.
Delta compression using up to 8 threads
Compressing objects: 100% (3/3), done.
Writing objects: 100% (3/3), 358 bytes | 179.00 KiB/s, done.
Total 3 (delta 2), reused 0 (delta 0), pack-reused 0
remote: Resolving deltas: 100% (2/2), completed with 2 local objects.
To https://github.com/jon-jacky/Piety
   2e981ad..84b2848  window -> window

Pasted token from L19839 after password:  Apparently it workd.

Look at github web page.  The ...init.py are gone, but we still have
the old versions of all the main modules -- !?   But git diff showed
they had all changed -- !?   Now git status shows they are modified - they
didn't get committed?   Try repeatin the commands:

jon@penguin:~/Piety/editors$ git commit -am 'move contents of all the 
> ...init.py into all their main modules'
[window efc00ac] move contents of all the ...init.py into all their main modules
 6 files changed, 268 insertions(+), 21 deletions(-)

jon@penguin:~/Piety/editors$ git push 
... again pasted token, it seemed to work ...

Now git status shows no more modifed files.  Github web page
shows new versions with initializations in except...

So does that complete the window branch?  Just a few loose ends:
1. crash when change to window that still displays killed buffer
2. refresh() command - just refreshes focus window 

also

3.  separate frame out of edsel?  Is that even a good idea?

Oh, and more important than 1,2,3

0. README.md and maybe HOW.md and NOTES.txt

Once more my token has been revoked!   See email just now, 15 Dec 5:36 pm.
Must contact github tech support to find out how I am supposed to push
these days.

What about ssh keys?   Now that I'm using CB I certainy don't have
ssh keys here - but I still had to do all that token stuff when I
was using the Mac, which did have ssh keys -- I thought.

support.github.com has Authentication button which eventually leads here:

https://docs.github.com/en/authentication

there's a button Overview and then scroll down to All Authentication docs,
a long list of links.

Maybe I can just set up ssh again -?

Overview goes to this page:

https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/about-authentication-to-github

Seems to say Personal access token is alternative to SSH key

"Authenticating with the command line

You can access repositories on GitHub from the command line in two ways,
HTTPS and SSH, and both have a different way of authenticating. The
method of authenticating is determined based on whether you choose an
HTTPS or SSH remote URL when you clone the repository. ..."

At L18584 above, we cloned the Piety repo on penguin (the Chromebook, or CB)
with git clone https://...    So we use HTTPS.

There is something called Git Credential Manager (GCM) that you have
to install in your Linux.  After that you don't have to type credentials again.

https://docs.github.com/en/get-started/getting-started-with-git/caching-your-github-credentials-in-git

BUT what happened to ssh?  I've only been using git clone https://...
this year.   Did I use ssh URLs in version1?   Here on penguin, the CB:

penguin:~/Piety/editors$ git remote -v
origin  https://github.com/jon-jacky/Piety (fetch)   (note - no .git suffix)
origin  https://github.com/jon-jacky/Piety (push)

https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/about-authentication-to-github

"SSH

...
Every time you use Git to authenticate with GitHub, you'll be prompted
to enter your SSH key passphrase, unless you've stored the key."


Managing Remote Repositories
https://docs.github.com/en/get-started/getting-started-with-git/managing-remote-repositories

Shows how to switch remote URL from SSH to HTTPS and vice versa


16 Dec 2023

BUG - cut several lines with consecutive C-k then C-y pastes noithing

pmacs.inline FALSE
sked.killed ['\n']

So the last line I cut was an empty line - \n by itself.   Does
that cause sked.killed to reset?   

Look on the old Mac in Piety.version1 with remote -v
Right, origin fetch and push are both 

Piety.version1: git@github.com:jon-jacky/Piety  (no .git suffix)

How about the other repos?

home: git@github.com:jon-jacky/home.git

PyModel.git, FLiP also have git@...git URLs

What about noreen?

z: https://github.com/jon-jacky/CNTS.git 

CNTS: https://github.com/jon-jacky/CNTS.git

notes: ssh://jon@gorter.me.washington.edu/Users/jon/git/notes (no .git suffix)

Wow!  That's old!

I could look up how I created those repos.   There are notes 
files for those ... somewhere.

On Mac, ~/notes/home/notes.txt shows some git activity, but no git clone
or creating the repo.
  
Ah, On mac ~/notes/tech/uw-migrate.txt is about the activity last
summer/fall to create CNTS, z etc.

Then lots of git activity in ~/notes/piety/notes.version1.txt of course.
Creating the initial Piety git repo should be in there.

I recall the process is to create a git repo at github, then 
clone it to your local machine - doesn't github itself determine
the remote URL?   ~/notes/tech/uw-migrate.txt should have recent examples.


Later -- copy uw-migrate.txt to the Kindle so I can read it upstairs
At 1 Oct 2022, at 12%, I see commands I used to create repos for Z etc.
At 17%  I did git remote add origin https://github.com/jon-jacky/z-book.git
Note, I used https URL.  Then when I try git push, github says I have
to get personal access token.   If I used git@github.com URL instead,
would ssh have worked?

uw-migrate mentions these URLs:

https:docs.github.com/en/repositories

We already have looked at .../getting-started  .../authentication

https://docs.github.com/en/authentication/connecting-to-github-with-ssh/about-ssh

"... With SSH keys, you can connect to GitHub without supplying your
username and personal access token at each visit ..."

Possible experiment: On Chromebook, change Piety remote 
from http://.... to git@....  then set up ssh following directions
at the above page - we've done it before - and see if we can push
without messing with personal access token.

That's a lot of work.   On Mac, can't we just try pushing from
a repo with an *existing* git@remote ?  We already have ssh set up
on the Macbook.   See if we can push to a git@ remote even when
we *can't* push to an https remote.   That's the first expt to try.
THe home repo has a git@ remote.   Can we just try a push from there?

But meanwhile, how can we back up work we're doing on Chromebook if
we can't even push to github?

What about those Linux Files in the CB file system?  Are they automatically
synched?   Then can we copy them to a USB external disk?

I just looked in CB file system, Linux Files Piety/doc/notes.txt - this file.
Yes, the preceding sentence is already there.  They are synched.
Is there a .git in the top level of CB Piety?  So I could git pull from CB?
That could be a stopgap if I couldn't reach github.

Yes, there is a .git at top level of CB Piety.

There is some way to make a CB file appear in Linux file system.
So could we copy notes and noreen directories from USB ext hard disk to 
CB  file system, then make them known to Linux, edit in Linux, 
see if Linux edits appear in CB file system.  Oh, but then
there is no way to git pull from CB file system to ext hard disk.
Because there is no command line and no git on the CB itself.
We could only use CB Files GUI to copy updated files back to ext
hard disk --- which is crude compared to git or rsync. 


21 Dec 2023

We started working on the Chromebook (CB) on Nov 30.

git log here on CB shows ~/home/design.md updated on Nov 27 and Dec 2,
but no notes about it above.   On Dec 2 did we edit, commit and push design
here on CB or on the Mac?  In particular, were we able to push from
here?   I don't think so, no notes about it in this file above.

git pull in home on the three external backup disks Spare, WD2TB, WDBLUE,
to update design.md and design.txt.

On the Mac, most recent ~/home/design.txt and .md are 27 Nov.  git log
shows most recent update to design.md there is on 27 Nov.   So we must have
done 3 Dec push from CB.   Indeed, ls -lt shows design.txt .md on CB
are from 2 Dec.

Later ...  try git pull onto mac, get updates we made on CB.

On mac in ~/home, 

...$ git pull

Pops up window to ask for password, I type in my old text password,
not the token

Identify added: /Users/jon/.ssh/id_rsa ((null))
...
    .... gh-pages -> origin/gh-pages

There is no tracking information for the current branch

...$ git pull origin gh-pages
 
  design.md   | 5 +++++-
  design.txt  | 5 +++++-

2 files changed ...

Now ls -l shows design.md design.txt 21 Dec

Now try Piety

...$ git pull origin window
...

Now without prompting for any password, it updares notes.txt, other.txt
pm.py and the 5 *.py files, and removes the 5 *init.py files.
ls -l confirms the editors/*.py files are new today and the *init.py
files are gone.  Also doc/notes.txt and other.txt are new today.

So it looks like pushing from CB and then pulling into Mac works, 
even though we only previously pushed from those Mac directories.

Now see if we can push from ~/home directory on mac.  Do we need
that infernal token?   

...$ git remote -v
...
origin git@github.com:jon-jacky/home.git (push)

It's *not* and https URL - that's why it might not need token --- 
ssh key was enough, once,   

...$ cat > test1.txt
...
...$ git add text1.txt
...$ git commit test1.txt -m '...'

...$ git push
...
... (no complaints, no prompt for password)   
...
    ... gh-pages -> gh-pages

It looks like it worked.   Look for file  at github.  Yes, text1.txt
is there.  

Try git pull on CB linux.  Oh, that might not work because git remote -v
says it an https URL.   Try anyway:

jon@penguin:~/home$ git pull
hint: Pulling without specifying how to reconcile divergent branches is
hint: discouraged. You can squelch this message by running one of the following
hint: commands sometime before your next pull:
hint: 
hint:   git config pull.rebase false  # merge (the default strategy)
hint:   git config pull.rebase true   # rebase
hint:   git config pull.ff only       # fast-forward only
hint: 
hint: You can replace "git config" with "git config --global" to set a default
hint: preference for all repositories. You can also pass --rebase, --no-rebase,
hint: or --ff-only on the command line to override the configured default per
hint: invocation.
remote: Enumerating objects: 4, done.
remote: Counting objects: 100% (4/4), done.
remote: Compressing objects: 100% (2/2), done.
remote: Total 3 (delta 1), reused 3 (delta 1), pack-reused 0
Unpacking objects: 100% (3/3), 383 bytes | 31.00 KiB/s, done.
From https://github.com/jon-jacky/home
   cc92df8..4e4173a  gh-pages   -> origin/gh-pages
Updating cc92df8..4e4173a
Fast-forward
 test1.txt | 2 ++
 1 file changed, 2 insertions(+)
 create mode 100644 test1.txt

It looks like it worked anyway, despite warning.
        
jon@penguin:~/home$ cat test1.txt
This is test1.txt.  git add, commit to local repo, see if we can push to github
without personal access token.  remote here is a git@... URL not https:...

By 'remote here' I meant 'remote here on the the Mac'.

So we can pull from this https URL without password or token.

Next: try changing Piety URL to git@... and see if we can push without 
password or token.


22 Dec 2023

Try committing to home from CB.   Create ~/home/test2.txt.  
I'll bet it *won't* work - here we have https remote:

jon@penguin:~/home$ git remote -v
origin  https://github.com/jon-jacky/home (fetch)
origin  https://github.com/jon-jacky/home (push)

jon@penguin:~/home$ git add test2.txt
jon@penguin:~/home$ git commit test2.txt -m 'first commit of new test2.txt to local home repo on Chromebook'
[gh-pages 9e3fa66] first commit of new test2.txt to local home repo on Chromebook
 1 file changed, 2 insertions(+)
 create mode 100644 test2.txt

on@penguin:~/home$ git push origin gh-pages
Username for 'https://github.com': jon-jacky
Password for 'https://jon-jacky@github.com': 
remote: Support for password authentication was removed on August 13, 2021.
remote: Please see https://docs.github.com/en/get-started/getting-started-with-git/about-remote-repositories#cloning-with-https-urls for information on currently recommended modes of authentication.
fatal: Authentication failed for 'https://github.com/jon-jacky/home/'

Just tried the old password - as expected it doesn't work.  Next,
try pasting in the revoked token.   

jon@penguin:~/home$ # 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

I tried pasting this in but got the same message as above.  Bah.

Let's see if we can change remote.   Follow directions at:

https://docs.github.com/en/get-started/getting-started-with-git/managing-remote-repositories

jon@penguin:~/home$ git remote set-url origin git@github.com:jon-jacky/home.git
jon@penguin:~/home$ git remote -v
origin  git@github.com:jon-jacky/home.git (fetch)
origin  git@github.com:jon-jacky/home.git (push)

jon@penguin:~/home$ git push
The authenticity of host 'github.com (20.29.134.23)' can't be established.
ECDSA key fingerprint is SHA256:p2QAMXNIC1TJYWeIOttrVc98/R1BUFWu3/LiyKgUfQM.
Are you sure you want to continue connecting (yes/no/[fingerprint])? y
Please type 'yes', 'no' or the fingerprint: yes
Warning: Permanently added 'github.com,20.29.134.23' (ECDSA) to the list of known hosts.
git@github.com: Permission denied (publickey).
fatal: Could not read from remote repository.

Please make sure you have the correct access rights
and the repository exists.  

Ah, yes.   I haven't set up ssh on the CB.   So I guess I have to
run ssh-keygen to create a public/private pair, and append the public
key to something in my account at github?   Or, do I have to copy
my public key at github to something on my Chromebook -- ?

https://docs.github.com/en/authentication/connecting-to-github-with-ssh/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent

https://docs.github.com/en/authentication/connecting-to-github-with-ssh/adding-a-new-ssh-key-to-your-github-account

https://docs.github.com/en/authentication/connecting-to-github-with-ssh/checking-for-existing-ssh-keys

Check for existing ssh keys:

jon@penguin:~$ ls -al .ssh
total 4
drwx------ 1 jon jon  22 Dec 22 12:54 .
drwxr-xr-x 1 jon jon 260 Dec 22 12:54 ..
-rw-r--r-- 1 jon jon 444 Dec 22 12:54 known_hosts

I think that means we don't have any.   Follow the directinos to add one:

jon@penguin:~$ ssh-keygen -t ed25519 -C 'jon.p.jacky@gmail.com'
Generating public/private ed25519 key pair.
Enter file in which to save the key (/home/jon/.ssh/id_ed25519): 
Enter passphrase (empty for no passphrase): 
Enter same passphrase again: 
Your identification has been saved in /home/jon/.ssh/id_ed25519
Your public key has been saved in /home/jon/.ssh/id_ed25519.pub
The key fingerprint is:
SHA256:gTMMWwkYBi7VciYJ/DAjlKoXyQv9C+OZWDgg/h+ZuXI jon.p.jacky@gmail.com
The key's randomart image is:
+--[ED25519 256]--+
|=+==o...         |
|oO= +=..         |
|++=*. = .        |
|* =.   o .       |
|=o +    S        |
|+.* . +          |
| *.= *           |
|. +o.Eo          |
|    +o           |
+----[SHA256]-----+

passphrase was piety2023

jon@penguin:~$ ls -l .ssh
total 12
-rw------- 1 jon jon 464 Dec 22 13:14 id_ed25519
-rw-r--r-- 1 jon jon 103 Dec 22 13:14 id_ed25519.pub
-rw-r--r-- 1 jon jon 444 Dec 22 12:54 known_hosts

jon@penguin:~$ eval "$(ssh-agent -s)"
Agent pid 10229
jon@penguin:~$ ssh-add ~/.ssh/id_ed25519
Enter passphrase for /home/jon/.ssh/id_ed25519: 
Identity added: /home/jon/.ssh/id_ed25519 (jon.p.jacky@gmail.com)

Then went through the directions "Adding a new SSH key to your Github Account"
all the way through Add SSH Key.    So we should be ready to push.


jon@penguin:~/home$ git push
Enumerating objects: 4, done.
Counting objects: 100% (4/4), done.
Delta compression using up to 8 threads
Compressing objects: 100% (3/3), done.
Writing objects: 100% (3/3), 397 bytes | 79.00 KiB/s, done.
Total 3 (delta 1), reused 0 (delta 0), pack-reused 0
remote: Resolving deltas: 100% (1/1), completed with 1 local object.
To github.com:jon-jacky/home.git
   4e4173a..9e3fa66  gh-pages -> gh-pages

It seemed to work.  Yes, test2.txt is at github.

Next: change Piety on CB remote to git@ URL.


29 Dec 2023   

We find:

jon@penguin:~/Piety$ git remote -v
origin  git@github.com:jon-jacky/Piety.git (fetch)
origin  git@github.com:jon-jacky/Piety.git (push)

So we already did change remote on CB Piety.   Did we push anything?
Apparenty not.  Now doc/other.txt is only file not up to date.

jon@penguin:~/Piety/doc$ git commit other.txt -m 'recent updates'
[window 6a34f4b] recent updates
 1 file changed, 75 insertions(+)

jon@penguin:~/Piety/doc$ git push
Enter passphrase for key '/home/jon/.ssh/id_ed25519': 
Enumerating objects: 7, done.
Counting objects: 100% (7/7), done.
Delta compression using up to 8 threads
Compressing objects: 100% (4/4), done.
Writing objects: 100% (4/4), 1.67 KiB | 39.00 KiB/s, done.
Total 4 (delta 3), reused 0 (delta 0), pack-reused 0
remote: Resolving deltas: 100% (3/3), completed with 3 local objects.
To github.com:jon-jacky/Piety.git
   4701926..6a34f4b  window -> window

I used passphrase piety2023. 

Before push, at github in other.txt last entry was 19 Dec to L13714.
Now refresh github page for other.txt, has entry for 28 Dec to L13789.
So we can push to github from CB Piety repo.

Now github has Piety files not up-to-date on WD2TB disk.  Can
we git pull from Github Piety to WD2TB, while WD2TB attached to CB?

Argh, I lost notes because this maneuver reset all the terminals.
BUT we now have

jon@penguin:/mnt/chromeos/removable/WD2TB/Piety$ ls -a
.   bin        DIRECTORIES.md  editors  README.md  vt_terminal
..  BRANCH.md  doc             .git     unix

...$ git remote -v
origin https://github.com/jon-jacky/Piety/ (fetch)
...

So it's https not git@.  Let's try pull anyway:

...
Unpacking objects: 100% (13/13), 8.70 KiB | 2.00 KiB/s, done.
From https://github.com/jon-jacky/Piety
   efc00ac..6a34f4b  window     -> origin/window
Already up to date.

jon@penguin:/mnt/chromeos/removable/WD2TB/Piety$ cd doc
jon@penguin:/mnt/chromeos/removable/WD2TB/Piety/doc$ ls -l other.txt
-rwxr-xr-x 1 jon chronos-access 486954 Dec 20 18:11 other.txt
jon@penguin:/mnt/chromeos/removable/WD2TB/Piety/doc$ tail other.txt
13 Dec 2023

https://olano.dev/2023-12-12-reclaiming-the-web-with-a-personal-reader/

"... I tried several Python libraries to extract HTML content, but none
worked as well as the readability one used by Firefox. Since its a
JavaScript package, I had to resign myself to introducing an optional
dependency on Node.js. ..."

So it didn't get the latest.  Try again

jon@penguin:/mnt/chromeos/removable/WD2TB/Piety/doc$ git pull origin window
hint: Pulling without specifying how to reconcile divergent branches is
hint: discouraged. You can squelch this message by running one of the following
hint: commands sometime before your next pull:
hint: 
hint:   git config pull.rebase false  # merge (the default strategy)
hint:   git config pull.rebase true   # rebase
hint:   git config pull.ff only       # fast-forward only
hint: 
hint: You can replace "git config" with "git config --global" to set a default
hint: preference for all repositories. You can also pass --rebase, --no-rebase,
hint: or --ff-only on the command line to override the configured default per
hint: invocation.
From https://github.com/jon-jacky/Piety
 * branch            window     -> FETCH_HEAD
Updating efc00ac..6a34f4b
Fast-forward
 doc/notes.txt     | 433 +++++++++++++++++++++++++++++++++++++++++++++++++++++-
 doc/other.txt     |  99 +++++++++++++
 editors/README.md |  29 ++--
 3 files changed, 541 insertions(+), 20 deletions(-)


jon@penguin:/mnt/chromeos/removable/WD2TB/Piety/doc$ ls -l other.txt
-rwxr-xr-x 1 jon chronos-access 490277 Dec 29 11:45 other.txt
jon@penguin:/mnt/chromeos/removable/WD2TB/Piety/doc$ tail other.txt
via https://news.ycombinator.com/item?id=38792446  168 comments in 4 hours!
Lots of praise for VSCode, JetBrains


https://github.com/michalc/sqlite-memory-vfs

"Python virtual filesystem for SQLite to read from and write to memory...."

via https://news.ycombinator.com/item?id=38786012  10 comments in 1 day

It got it!  It works!  SO that simplifies our workflow with Piety - we
can get ext hard disk up-to-date without going downstairs and connecting
it to Mac.  

While we're at it:

jon@penguin:/mnt/chromeos/removable/WD2TB/Piety/doc$ cd ../..
jon@penguin:/mnt/chromeos/removable/WD2TB$ cd home
-bash: cd: home: No such file or directory
jon@penguin:/mnt/chromeos/removable/WD2TB$ ls
Piety

Now go back to File app, select WD2TB/home with a click,
the alt-click to get terminal into WD2TB/home
In that terminal we get:

jon@penguin:/mnt/chromeos/removable/WD2TB/home$ ls
brackets.py      diary2md.py                                notes
comments.md      index.html                                 others.html
... etc. ...

Now here in the terminal where we did git pull in Piety:

jon@penguin:/mnt/chromeos/removable/WD2TB$ ls
home  Piety
jon@penguin:/mnt/chromeos/removable/WD2TB$ cd home
jon@penguin:/mnt/chromeos/removable/WD2TB/home$ ls
brackets.py      diary2md.py                                notes
comments.md      index.html                                 others.html
... 


on@penguin:/mnt/chromeos/removable/WD2TB/home$ git pull
hint: Pulling without specifying how to reconcile divergent branches is
hint: discouraged. You can squelch this message by running one of the following
hint: commands sometime before your next pull:
hint: 
hint:   git config pull.rebase false  # merge (the default strategy)
hint:   git config pull.rebase true   # rebase
hint:   git config pull.ff only       # fast-forward only
hint: 
hint: You can replace "git config" with "git config --global" to set a default
hint: preference for all repositories. You can also pass --rebase, --no-rebase,
hint: or --ff-only on the command line to override the configured default per
hint: invocation.
remote: Enumerating objects: 13, done.
remote: Counting objects: 100% (13/13), done.
remote: Compressing objects: 100% (6/6), done.
remote: Total 10 (delta 5), reused 9 (delta 4), pack-reused 0
Unpacking objects: 100% (10/10), 2.23 KiB | 0 bytes/s, done.
From https://github.com/jon-jacky/home
   cc92df8..cbb3c7e  gh-pages   -> origin/gh-pages
Updating cc92df8..cbb3c7e
Fast-forward
 computing.md  | 29 ++++++++++++++++++++++++++++-
 computing.txt | 29 ++++++++++++++++++++++++++++-
 test1.txt     |  2 ++
 test2.txt     |  2 ++
 4 files changed, 60 insertions(+), 2 deletions(-)
 create mode 100644 test1.txt
 create mode 100644 test2.txt

It apparently worked.  Yes, now we have test1.txt and test2.txt which
we didn't have before

on@penguin:/mnt/chromeos/removable/WD2TB/home$ grep -i '26 Dec' computing.txt
28 Feb 2019, 26 Dec 2023
26 Dec 2016

That 26 Dec 2023 is for the new entry.   So that worked too.

The next thing is to see if we can put repos for notes, noreen, readings, 
and www on CB, then pull from those repos to hard disk.


30 Dec 2023

Next: put 'personal' repos on CB.  That is, repos *not* at github:
notes, noreen, readings, www.

Start with the smallest: readings 

1. In readings on mac, git commit

2. Connect WD2TB to mac.  In reaadings on WDT2B, git pull

3. Connect WD2TB to CB.   In ~jon on CB Linux, git clone WD2TB/readings

Now I suppose readings on CB remote will be WD2TB/readings.
Do we want to git set remote on CB readings to something else? 
What is the remote for readings repo on the Mac?

I expect WD2TB readings remote is on Mac: /Users/jon/readings ... 

But now we want to pull WD2TB readings from CB readings.   Unfortunately 
CB readings will have a *different* path:  /home/jon/readings ...

Do we have to change WD2TB readings remote with git set remote ... ?

If so, then if we want to pull from Mac again we have to set remote back.
And so on - we'd have to set remote again each time we connected WD2TB
to one or the other.

It would be better if we could have multiple remotes.  It seems
git pull command does support that - we have already 'git push origin windows'
that is, 'git push <remote> <branch>'.

So is there a 'git add remote ...' command?

We will have to set or add remote on each personal repo on each ext disk
we use for backup: WD2TB, WDBLUE, Spare.

Can we get revisions we make in CB repo back to Mac repo?
It seems the process would be, in WD2TB repo pull from CB repo.
Now WD2TB repo is up-to-date with CB repo.

Then connect WD2TB to Mac. Can we git push from WD2TB repo to Mac repo?

We want to pull, push from WD2TB repo back to CB repo or Mac repo.
These are two different remotes.   This is better than push, pull
from Mac repo or CB repo to WD2TB repo etc. because then Mac repo 
and CB repo would each need a different remote for each backup hard disk
repo.   Instead, the hard disk repos have to deal with just the
Mac and CB repos.   

It's too bad Mac and CB repos have to have different paths, due to
Mac /Users/jon/... and CB /home/jon/...  That means each hard disk
repo has to deal with two remotes.

I suppose we could try to fix this with symbolic link: on CB
/Users is symbolic link to /home - that way we could just continue
to use the existing remote on each WD2TB personal repo for both
CB and Mac.   But (even if it works) that seems fragile and obscure, and
it's not clear what's going on - it's a trick to disguise what's going on.

On setting up multiple remotes, what's the canonical git manual these days?

https://git-scm.com/book/en/v2 - Pro Git book, toc on this page

https://git-scm.com/book/en/v2/Git-Basics-Working-with-Remotes - chapter

https://git-scm.com/docs/user-manual - reference/user manual, toc here

https://git-scm.com/docs/git-remote - man page, linked from user-manual toc

Later - look on personal repos on Mac.  First, ~/readings

...readings jon$ git remote -v
origin ssh://jon@gorter.me.washington.edu/Users/jon/git/misc (fetch) 
origin ssh://jon@gorter.me.washington.edu/Users/jon/git/misc (push)

Wow, old!  gorter.me was a Mac in the MRFM lab!   I think this means
it doesn't matter what the remote for the main working directories
of the personal repos are, because we never push or pull to those
remotes.   Those directories *are* the remotes, analogous to github.

The remotes for ~/notes and ~/www are also gorter.me...

BUT in ~/noreen, git remote -v prints nothing!  So does git remote (no args)
So those personal repo working dirs really dont' need a remote at all.

After we clone personal repos on CB, we could use git remote remove <name>
to get rid of remotes, just to avoid confusion.

Do we have any notes on how we made noreen repo and how we cloned it
to WD2TB etc?   Maybe look in notes/mac/disk.txt.   Yes: L2101, 25 Oct 2021:

"Make ~/noreen into a github repo, then clone on WD2TB ...

notes/tech/notes.txt L208 describes how I made home repo on mac
then put it on github ... starting with new empty dir. ..." 

In ~/noreen, I used 

 $ git init   
 $ git add .
 $ git commit -am 'initial commit ...'

Then in /Volumes/WD2TB:

 $ git clone ~/noreen/.git 

Then in WD2TB/noreen we have

 $ git remote -v
origin /Users/jon/noreen/.git (fetch)
origin /Users/jon/noreen/.git (push)

So remote origin is the repo it was cloned from.

Edit and commit latest version of Mac ~/readings repo and pull to WD2TB.

...$ git remote -v
origin /Users/jon/readings/.git (fetch)
origin /Users/jon/readings/.git (push)

As expected.

...$ git pull
...
From /Users/jon/readings/
   ... master  -> origin/master
...
 reading.txt | 3 ++-
 1 file changed ...

I think we are ready to try putting readings personal
repo on chromebook and adding it as a remote for WD2TB/readings.

Better read the git docs on remote first, though.   Done, let's go:

Plug WD2TB in to CB

jon@penguin:~$ ls
home  Piety  test.txt
jon@penguin:~$ ls /mnt/chromeos/removable/
WD2TB
jon@penguin:~$ ls /mnt/chromeos/removable/WD2TB/
home

We need to make WD2TB/readings visible.  Navigate to WD2TB in File app,
select readings, alt-click, select Terminal, do *not* select Restart Linux,
instead select Recovery Terminal.  Oh, but that's just in /home/jon. Then:

jon@penguin:~$ ls /mnt/chromeos/removable/WD2TB/
home

So we don't have readings.   Try again and this time Restart Linux.
Save this file first!   Also save design.txt and other.txt in pmacs session
in readings space.

Now try again, select WD2TB/readings in File app, alt-click

"Restart Linux?
Your device didn't shut down properly.  Restart Linux to use Linux apps.
[Open recovery terminal] [Restart Linux]"

Oh, right, last night I just unplugged WD2TB without ejecting it.
Select [Restart Linux].

That doesn't work either.  We just get Term in ~jon, again it hasn't
mounted WD2TB/readings.

Eject and reconnect WD2TB, in File app navigate to WD2TB, select readings,
alt-click, selecg Terminal.  Now terminal opens to WD2TB readings, yay!

jon@penguin:/mnt/chromeos/removable/WD2TB/readings$ cd ~jon
jon@penguin:~$ pwd
/home/jon
jon@penguin:~$ ls
home  Piety  test.txt
jon@penguin:~$ git clone /mnt/chromeos/removable/WD2TB/readings/.git
Cloning into 'readings'...
done.

jon@penguin:~$ ls
home  Piety  readings  test.txt
jon@penguin:~$ cd readings
jon@penguin:~/readings$ ls
arts.txt             brand.txt      movies-to-see.txt     quotes.txt
bach.txt             campus.txt     movies.txt            ras_recommends.txt
baldwin-pynchon.txt  carr.txt       music-to-try.txt      reading.txt
bobjonesu.txt        dna.txt        nietzche_to_rico.txt  rockstars.txt
book-group-list.pdf  ginsberg.txt   notes.txt             seen.txt
bookgroup.txt        innocents.txt  performances.txt      spies.txt
brand2.txt           lanier.txt     proust.txt

jon@penguin:~/readings$ git remote -v
origin  /mnt/chromeos/removable/WD2TB/readings/.git (fetch)
origin  /mnt/chromeos/removable/WD2TB/readings/.git (push)

I suppose we can just leave that remote there.

jon@penguin:~/readings$ pwd
/home/jon/readings 


Now let's add this remote to readings on WD2TB.

jon@penguin:~/readings$ cd /mnt/chromeos/removable/WD2TB/readings
jon@penguin:/mnt/chromeos/removable/WD2TB/readings$ git remote -v
origin  /Users/jon/readings/.git (fetch)
origin  /Users/jon/readings/.git (push)
jon@penguin:/mnt/chromeos/removable/WD2TB/readings$ git remote add \
> chromebook /home/jon/readings/.git
jon@penguin:/mnt/chromeos/removable/WD2TB/readings$ git remote -v
chromebook      /home/jon/readings/.git (fetch)
chromebook      /home/jon/readings/.git (push)
origin  /Users/jon/readings/.git (fetch)
origin  /Users/jon/readings/.git (push)

It apparently worked.   Now edit and commit in CB repo ~/readings/reading.txt 

jon@penguin:~/readings$ git status
On branch master
Your branch is up to date with 'origin/master'.

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
        modified:   reading.txt

no changes added to commit (use "git add" and/or "git commit -a")
jon@penguin:~/readings$ git commit reading.txt -m 'recent update'
[master 1d5b763] recent update
 1 file changed, 2 insertions(+)
jon@penguin:~/readings$ git branch
* master

Now try pulling on WD2TB.  First, before pull:

jon@penguin:/mnt/chromeos/removable/WD2TB/readings$ tail -n 4 reading.txt 
Dec 2023

Lush Life, David Hajda, biography of Jazz musician Billy Strayhorn (loaned by David from book group)
Woody Guthrie: A Life, Joe Klein, w/N for book group (Secret Garden)

Then pull:

jon@penguin:/mnt/chromeos/removable/WD2TB/readings$ git pull chromebook
hint: Pulling without specifying how to reconcile divergent branches is
hint: discouraged. You can squelch this message by running one of the following
hint: commands sometime before your next pull:
hint: 
hint:   git config pull.rebase false  # merge (the default strategy)
hint:   git config pull.rebase true   # rebase
hint:   git config pull.ff only       # fast-forward only
hint: 
hint: You can replace "git config" with "git config --global" to set a default
hint: preference for all repositories. You can also pass --rebase, --no-rebase,
hint: or --ff-only on the command line to override the configured default per
hint: invocation.
remote: Enumerating objects: 5, done.
remote: Counting objects: 100% (5/5), done.
remote: Compressing objects: 100% (3/3), done.
remote: Total 3 (delta 2), reused 0 (delta 0), pack-reused 0
Unpacking objects: 100% (3/3), 352 bytes | 0 bytes/s, done.
From /home/jon/readings/
 * [new branch]      master     -> chromebook/master
You asked to pull from the remote 'chromebook', but did not specify
a branch. Because this is not the default configured remote
for your current branch, you must specify a branch on the command line.

But did it pull?

jon@penguin:/mnt/chromeos/removable/WD2TB/readings$ tail -n 4 reading.txt 
Dec 2023

Lush Life, David Hajda, biography of Jazz musician Billy Strayhorn (loaned by David from book group)
Woody Guthrie: A Life, Joe Klein, w/N for book group (Secret Garden)

No it didn't.  Try again.

jon@penguin:/mnt/chromeos/removable/WD2TB/readings$ git pull chromebook master
hint: Pulling without specifying how to reconcile divergent branches is
hint: discouraged. You can squelch this message by running one of the following
hint: commands sometime before your next pull:
hint: 
hint:   git config pull.rebase false  # merge (the default strategy)
hint:   git config pull.rebase true   # rebase
hint:   git config pull.ff only       # fast-forward only
hint: 
hint: You can replace "git config" with "git config --global" to set a default
hint: preference for all repositories. You can also pass --rebase, --no-rebase,
hint: or --ff-only on the command line to override the configured default per
hint: invocation.
From /home/jon/readings/
 * branch            master     -> FETCH_HEAD
Updating 6061e49..1d5b763
Fast-forward
 reading.txt | 2 ++
 1 file changed, 2 insertions(+)
jon@penguin:/mnt/chromeos/removable/WD2TB/readings$ 
jon@penguin:/mnt/chromeos/removable/WD2TB/readings$ tail -n 4 reading.txt 
Lush Life, David Hajda, biography of Jazz musician Billy Strayhorn (loaned by David from book group)
Woody Guthrie: A Life, Joe Klein, w/N for book group (Secret Garden)
Emerald City and other stories, Jennifer Egan, read a few (found in our house)

It worked!  So we have readings repo on Mac, on CB, and on WD2TB.
We can pull from both Mac and CB to WD2TB.

So we have backup of personal git repo on CB Linux on ext hard disk WD2TB.
Not at github, not at Google Drive - soso it's private and under our control
This was our goal, so we can continue using CB in a similar workflow to Mac.

Next: add this remote on WDBLUE also, back up (that is, pull) there as well.

Remember to use File app to eject WD2TB properly first!  Done.

That term window doesn't know WD2TB was ejected! Can't see files, 
but doesn't complain:

jon@penguin:/mnt/chromeos/removable/WD2TB/readings$ ls
jon@penguin:/mnt/chromeos/removable/WD2TB/readings$ cd ../..
jon@penguin:/mnt/chromeos/removable$ ls
WD2TB
jon@penguin:/mnt/chromeos/removable$ cd WD2TB/
jon@penguin:/mnt/chromeos/removable/WD2TB$ ls
readings
jon@penguin:/mnt/chromeos/removable/WD2TB$ cd readings
jon@penguin:/mnt/chromeos/removable/WD2TB/readings$ ls
jon@penguin:/mnt/chromeos/removable/WD2TB/readings$ 

Close that terminal window, open a new one:

jon@penguin:~$ cd /mnt/chromeos/removable/
jon@penguin:/mnt/chromeos/removable$ ls
WD2TB
jon@penguin:/mnt/chromeos/removable$ ls WD2TB
readings
jon@penguin:/mnt/chromeos/removable$ ls WD2TB/readings
(nothing) 

Weird!  I had already plugged in WDBLUE.  In file app, navigate to WDBLUE,
select readings, alt-click, select Terminal, new Terminal window opens:

jon@penguin:/mnt/chromeos/removable/WDBLUE/readings$ 

meanwhile, try that other terminal again:

jon@penguin:/mnt/chromeos/removable$ ls
WD2TB  WDBLUE

Weird - go back to other term with WDBLUE

jon@penguin:/mnt/chromeos/removable/WDBLUE/readings$ git remote -v
origin  /Users/jon/readings/.git (fetch)
origin  /Users/jon/readings/.git (push)
jon@penguin:/mnt/chromeos/removable/WDBLUE/readings$ git remote add \
chromebook /home/jon/readings/.git
jon@penguin:/mnt/chromeos/removable/WDBLUE/readings$ git remote -v
chromebook      /home/jon/readings/.git (fetch)
chromebook      /home/jon/readings/.git (push)
origin  /Users/jon/readings/.git (fetch)
origin  /Users/jon/readings/.git (push) 

Now try pulling from readings on CB

jon@penguin:/mnt/chromeos/removable/WDBLUE/readings$ git pull chromebook master
hint: Pulling without specifying how to reconcile divergent branches is
hint: discouraged. You can squelch this message by running one of the following
hint: commands sometime before your next pull:
hint: 
hint:   git config pull.rebase false  # merge (the default strategy)
hint:   git config pull.rebase true   # rebase
hint:   git config pull.ff only       # fast-forward only
hint: 
hint: You can replace "git config" with "git config --global" to set a default
hint: preference for all repositories. You can also pass --rebase, --no-rebase,
hint: or --ff-only on the command line to override the configured default per
hint: invocation.
remote: Enumerating objects: 8, done.
remote: Counting objects: 100% (8/8), done.
remote: Compressing objects: 100% (6/6), done.
remote: Total 6 (delta 4), reused 0 (delta 0), pack-reused 0
Unpacking objects: 100% (6/6), 648 bytes | 0 bytes/s, done.
From /home/jon/readings/
 * branch            master     -> FETCH_HEAD
 * [new branch]      master     -> chromebook/master
Updating 4407cae..1d5b763
Fast-forward
 reading.txt | 5 ++++-
 1 file changed, 4 insertions(+), 1 deletion(-)
jon@penguin:/mnt/chromeos/removable/WDBLUE/readings$ tail -n 4 reading.txt
Lush Life, David Hajda, biography of Jazz musician Billy Strayhorn (loaned by David from book group)
Woody Guthrie: A Life, Joe Klein, w/N for book group (Secret Garden)
Emerald City and other stories, Jennifer Egan, read a few (found in our house)

We got the latest version!

Now use File app to eject WDBLUE.

Try pushing from WDBLUE back to repo on Mac.

Plug WDBLUE into mac, then in /Volumes/WDBLUE/readings

Confirm git remote -v shows both chromebook and origin.
Confirm newest entry is at the tail of reading.txt.  Then:

...$ git push origin master
...
... (long explanation why this didn't work)
...
To /Users/jon/readings/.git
 ! [remote rejected] master -> master (branch is currently checked out)
error: failed to push some refs to '/Users/jon/readings.git'

Cut/paste the whole long message with explanation to end
of ~/notes/mac/disk.txt on mac.

Let's not try to fix this now -- we can try to figure it out later
if we ever need to do this.  

For now, we're committed to  continue working on CB only, not Mac - we
currently don't have any way to make repos on CB and Mac up-to-date with
each other, we can only make repos on ext disks up-to-date with latest
on Mac *or* CB, whichever we most recently pull from.

Maybe we could add ext disks as remotes to repos on Mac, and pull 
from Mac?  

Never mind, defer that problem for now, get back to moving other
personal repos to CB.

Later  ... on the mac, write out all  editor buffers and then
git commit in the remaining personal repos: notes, noreen.
The commit command is:

...$ git commit -am 'recent updates, last commit from Mac 
                       before moving repo to ChromeBook'
...

We didn't write out or save mpb-bookmarks.html in www - we've stopped using it.

Then connect WD2TB ext disk and git pull in personal repos on WD2TB:
notes, noreen and even www. Now WD2TB is up-to-date with recent work on
Mac. 

Eject WD2TB from Mac, connect it to CB.

Now, repeat what we did with readings repo starting at L20772:

Use File app to  open a term window on WD2TB notes directory.  Pull
notes repo to CB:

jon@penguin:/mnt/chromeos/removable/WD2TB/notes$ cd ~jon
jon@penguin:~$ ls
home  Piety  readings  test.txt
jon@penguin:~$ git clone /mnt/chromeos/removable/WD2TB/notes/.git
Cloning into 'notes'...
done.
Updating files: 100% (598/598), done.
jon@penguin:~$ ls
home  notes  Piety  readings  test.txt
jon@penguin:~$ cd notes
jon@penguin:~/notes$ ls
ansys.txt  docs-2022  house       misc-2022    python         ump
archive    epics      house-8334  nmodel       retire         uw-access
arts       family     house-9129  nsf-cs       science        uw-lib
car        fiuts      linux       opengpt      show           uwplse
carl       flip       lrb         parallel     spec-explorer  uw_python
carol      friends    mac         piety        tech           windows
christmas  gerd       medical     programming  travel
diary      home       misc        pymodel      tulips

 then git remote add chromebook /home/jon/notes/.git
etc.  Check add with git remote -v.

jon@penguin:~/notes$ cd /mnt/chromeos/removable/WD2TB/notes/
jon@penguin:/mnt/chromeos/removable/WD2TB/notes$ git remote
origin
jon@penguin:/mnt/chromeos/removable/WD2TB/notes$ git remote -v
origin  /Users/jon/notes/.git (fetch)
origin  /Users/jon/notes/.git (push)
jon@penguin:/mnt/chromeos/removable/WD2TB/notes$ git remote add \
> chromebook /home/jon/notes/.git
jon@penguin:/mnt/chromeos/removable/WD2TB/notes$ git remote -v
chromebook      /home/jon/notes/.git (fetch)
chromebook      /home/jon/notes/.git (push)
origin  /Users/jon/notes/.git (fetch)
origin  /Users/jon/notes/.git (push)

Ditto for noreen and www repos - we don't copy it here.  Done.

Now we can begin working on the CB as we used to do on Mac.
To begin with, revise ~/notes/house-9129/sprinkler.txt with today's
water meter reading, and ~/noreen/harborview/progress.txt with 
N's activities today.  Commit both and pull both to repos on WD2TB,
confirm those repos are current.

jon@penguin:~/notes/house-9129$ git commit sprinkler.txt -m 'todays meter reading etc.'
[master 857f9a8] todays meter reading etc.
 1 file changed, 6 insertions(+)

jon@penguin:~/noreen/harborview$ git commit progress.txt -m 'todays excursion'
[master 088f1b6] todays excursion
 1 file changed, 16 insertions(+)

Before commits, we did git diff to confirm intended revisions are there.
Now pull to WD2TB

jon@penguin:/mnt/chromeos/removable/WD2TB/notes$ git pull chromebook master
hint: Pulling without specifying how to reconcile divergent branches is
hint: discouraged. You can squelch this message by running one of the following
hint: commands sometime before your next pull:
hint: 
hint:   git config pull.rebase false  # merge (the default strategy)
hint:   git config pull.rebase true   # rebase
hint:   git config pull.ff only       # fast-forward only
hint: 
hint: You can replace "git config" with "git config --global" to set a default
hint: preference for all repositories. You can also pass --rebase, --no-rebase,
hint: or --ff-only on the command line to override the configured default per
hint: invocation.
remote: Enumerating objects: 7, done.
remote: Counting objects: 100% (7/7), done.
remote: Compressing objects: 100% (4/4), done.
remote: Total 4 (delta 3), reused 0 (delta 0), pack-reused 0
Unpacking objects: 100% (4/4), 444 bytes | 0 bytes/s, done.
From /home/jon/notes/
 * branch            master     -> FETCH_HEAD
 * [new branch]      master     -> chromebook/master
Updating b536bda..857f9a8
Fast-forward
 house-9129/sprinkler.txt | 6 ++++++
 1 file changed, 6 insertions(+)
jon@penguin:/mnt/chromeos/removable/WD2TB/notes$ cd house-9129/
jon@penguin:/mnt/chromeos/removable/WD2TB/notes/house-9129$ tail -n 5 sprinkler.txt 
30 Dec 2023

 3:15 pm - water meter 317127 
Raining lightly all day, but puddles mostly gone in front and back yards.

We got it.

jon@penguin:/mnt/chromeos/removable/WD2TB/noreen$ git pull chromebook master
hint: Pulling without specifying how to reconcile divergent branches is
...
 harborview/progress.txt | 16 ++++++++++++++++
 1 file changed, 16 insertions(+)

jon@penguin:/mnt/chromeos/removable/WD2TB/noreen/harborview$ tail -n 5 progress.
txt
... we see the expected revisions.

So this is all working.  We can edit and commit to repos on CB and pull to  
repos on ext disk WD2TB.

We should commit these notes and push to github - we hope for the last
time - we plan to move them back out of Piety/doc back into notes/piety

 




