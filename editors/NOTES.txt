
notes
=====

Notes on the code in *Piety/editors*.

This is a .txt not an .md file to emphasize its roughness and incompleteness.

### sked ###

Line editor based on the classic Unix ed.

No main program!  Editor commands are just functions defined here, to
call from the Python REPL.

Global variables used by these functions are defined and initialized
in skedinit.py, which must be executed before calling any of the
functions here.
The way skedinit is executed (not imported) makes it possible to 
reload the sked module while preserving work in progress (which 
is stored in the global variables defined in skedinit).  The same
method is used for the other editor modules, edsel and dmacs.
EDPATH enables skedinit to be executed when sked is run from any 
directory.  Note that EDPATH is hard-coded and will have to be edited
to work on other sytems than mine.

This module produces no display output, except print statements that
print to the Python REPL.  However, many functions here include optional
place- holder arguments which are hooks for display functions that could
be defined in other modules.  Therefore this module can serve as the
foundation for display editors.

In this module we usually use print('...\n\r', end='') because it prints
end-of- line  correctly in both the terminal line mode used in the
Python REPL and in the terminal raw character mode used in some
display functions.

In save_buffer and restore_buffer we save buffer items as a dictionary
not an object or tuple so we can add items later without requiring
changes to existing code and without invalidating already existing saved
buffers.  We use the dictionary get method to read dictionary items,
because it does not crash if an item is missing from old saved data,
it just returns an appropriate default.

The items read from the dictionary are assigned to distinct global 
variables at module level so they can be accessed by code or from the 
REPL without verbose notation.

### edsel ###

Display editor that uses the same commands as *sked*.

Display buffer contents in a window as they are updated by the sked editor.

This module has four sections, that define four kinds of functions:

1. Display building blocks that do not depend on sked

2. Display functions that show effects of sked editing commands

Display fcns passed as args to editing commands defined in the sked
module.  The default arguments defined in sked produce no display
output.   These functions, when passed to fcns in sked, do produce
display output.  In this way they are used to define the wrapped display
commands below.  The function here display_<name> is passed to the sked
fcn ed.<name>.

3. Editing commands

Editing functions that generate display output by wrapping functions from
sked and passing the display fcns defined above. Each function here has
the same name as the sked function it wraps.

4. Window management functions that do not depend on sked

We have considered moving out sections 1 and 4, which do not 
depend on sked, to their own separate module titled 'frame'.

This could make for a nicer modular structure where the dependencies
are clearer.   But it also proliferates modules and makes code more verbose
because edsel would need to put the 'frame.' prefix all over.

Before attempting this, let's try adding multiple windows and see if these
too could be provided in a sked-less frame module.

### dmacs ###

Invoke editor functions with emacs keys (control keys or key seqs).

The module name dmacs differs from the editor function name dm
so the function name does not shadow the module name when we do
'from dmacs import dm' so we can type the function name in the REPL
without the module name prefix, just dm() not dmacs.dm().   
Then, if we edit more commands into dm, we can load them without restarting
the session by reload(dmacs).  The argument to reload must be the module name.

### editline ###

This code may be used to edit a line in a text buffer, where 
every line in the buffer ends with a newline character, Python '\n'.
The standard Python readlines function puts it there when it loads the file.
So code in this module has special cases to handle \n.  

Functions in this module must always leave the newline character
at the end of the line.  In particular, kill_line.

Functions in this module also must work correctly with lines that
do not end in \n.  They must not add \n where there was none.
Again, kill_line.

Functions in this module that advance point must not advance point
past the final newline.   In particuler, move_end and forward_char.  
This ensures that when new characters are typed, they are inserted 
ahead of the final newline.

Revised Sep 2023
